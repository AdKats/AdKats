/* 
 * AdKats - Advanced In-Game Admin and Ban Enforcer for Procon Frostbite.
 * 
 * Copyright 2014 A Different Kind, LLC
 * 
 * AdKats was inspired by the gaming community A Different Kind (ADK). Visit http://www.ADKGamers.com/ for more information.
 *
 * The AdKats Frostbite Plugin is free software: You can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version. AdKats is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details. To view this license, visit http://www.gnu.org/licenses/.
 * 
 * Code Credit:
 * Modded Levenshtein Distance algorithm and Tag Parsing from Micovery's InsaneLimits
 * Email System adapted from MorpheusX(AUT)'s "Notify Me!"
 * Metabans integration by Phogue
 * 
 * Development by Daniel J. Gradinjan (ColColonCleaner)
 * 
 * AdKats.cs
 * Version 6.0.0.0
 * 25-DEC-2014
 * 
 * Automatic Update Information
 * <version_code>6.0.0.0</version_code>
 */

using System;
using System.Data;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Net.Mail;
using System.Net.NetworkInformation;
using System.Security.Policy;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Windows.Forms;
using System.CodeDom.Compiler;
using System.Linq;
using System.Threading;
using System.Diagnostics;
using System.Reflection;
using System.Globalization;
using PRoCon.Core;
using PRoCon.Core.Plugin;
using PRoCon.Core.Plugin.Commands;
using PRoCon.Core.Players;
using Microsoft.CSharp;
using MySql.Data.MySqlClient;


namespace PRoConEvents {
    public class AdKats : PRoConPluginAPI, IPRoConPluginInterface {
        //Current Plugin Version
        private const String PluginVersion = "6.0.0.0";

        public enum ConsoleMessageType {
            Normal,
            Info,
            Success,
            Warning,
            Error,
            Exception
        };

        public enum GameVersion {
            BF3,
            BF4
        };

        //Metabans Ref
        internal enum SupportedGames
        {
            BF_3,
            BF_4
        }

        public enum RoundState {
            Loaded,
            Playing,
            Ended
        }

        public enum PopulationState {
            Unknown,
            Low,
            Medium,
            High,
        }

        public enum PlayerType {
            Player,
            Spectator,
            CommanderPC,
            CommanderMobile
        }

        public enum VersionStatus {
            OutdatedBuild,
            StableBuild,
            TestBuild,
            UnknownBuild,
            UnfetchedBuild
        }

        public enum MessageType {
            Say,
            Yell,
            Tell
        }
        
        //State
        private const Boolean FullDebug = false;
        private const Boolean SlowMoOnException = false;
        private Boolean _slowmo;
        private volatile String _pluginChangelog;
        private volatile String _pluginDescription;
        private volatile String _pluginLinks;
        private volatile Boolean _pluginEnabled;
        private volatile Boolean _pluginRebootOnDisable;
        private volatile String _pluginRebootOnDisableSource;
        private volatile Boolean _threadsReady;
        private volatile String _latestPluginVersion;
        private volatile Int32 _latestPluginVersionInt;
        private volatile Int32 _currentPluginVersionInt;
        private volatile String _pluginVersionStatusString;
        private volatile VersionStatus _pluginVersionStatus = VersionStatus.UnfetchedBuild;
        private volatile Boolean _pluginUpdateServerInfoChecked;
        private volatile Boolean _pluginUpdatePatched;
        private volatile String _pluginPatchedVersion;
        private volatile Int32 _pluginPatchedVersionInt;
        private volatile String _pluginUpdateProgress = "NotStarted";
        private volatile String _pluginDescFetchProgress = "NotStarted";
        private AdKatsRecord _pluginUpdateCaller = null;
        private volatile Boolean _useKeepAlive;
        private readonly Dictionary<Int32, Thread> _aliveThreads = new Dictionary<Int32, Thread>();
        private RoundState _roundState = RoundState.Loaded;
        private Int32 _highestTicketCount;
        private Int32 _lowestTicketCount = 500000;
        private volatile Boolean _fetchedPluginInformation;
        private Boolean _firstUserListComplete;
        private Boolean _firstPlayerListStarted;
        private Boolean _firstPlayerListComplete;
        private GameVersion _gameVersion = GameVersion.BF3;
        private Boolean _isTestingAuthorized;
        private Boolean _endingRound;
        private readonly AdKatsServer _serverInfo;
        private Int64 _settingImportID = -1;
        private Boolean _settingsFetched;
        private Boolean _settingsLocked;
        private String _settingsPassword;
        private Int32 _pingKicksThisRound = 0;
        private Int32 _mapBenefitIndex = 0;
        private Int32 _mapDetrimentIndex = 0;
        private Int32 _pingKicksTotal = 0;
        private Int32 _roundID = 0;
        private Boolean _versionTrackingDisabled;
        private Boolean _automaticUpdatesDisabled;
        private String _currentFlagMessage;
        private Boolean _populationPopulating;
        private readonly Dictionary<String, AdKatsPlayer> _populationPopulatingPlayers = new Dictionary<String, AdKatsPlayer>(); 
        private String _AdKatsLRTExtensionToken = String.Empty;

        //Debug
        private volatile Int32 _debugLevel;
        private String _debugSoldierName = "ColColonCleaner";
        private Boolean _toldCol;

        //Timing
        private readonly DateTime _proconStartTime = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _AdKatsStartTime = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _AdKatsRunningTime = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _commandStartTime = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastBanListCall = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastDbBanFetch = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastGUIDBanCountFetch = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastIPBanCountFetch = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastNameBanCountFetch = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastStatLoggerStatusUpdateTime = DateTime.UtcNow - TimeSpan.FromMinutes(60);
        private DateTime _lastSuccessfulBanList = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _populationTransitionTime = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _populationUpdateTime = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastDatabaseTimeout = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastDbActionFetch = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastDbSettingFetch = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastSuccessfulPlayerList = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastUpdateSettingRequest = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _lastUserFetch = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _LastPlayerMoveIssued = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _LastPluginDescFetch = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private DateTime _LastVersionTrackingUpdate = DateTime.UtcNow - TimeSpan.FromHours(1);
        private DateTime _LastTicketRateDisplay = DateTime.UtcNow - TimeSpan.FromSeconds(30);
        private DateTime _lastAutoSurrenderTriggerTime = DateTime.UtcNow - TimeSpan.FromSeconds(10);
        private DateTime _LastBattlelogAction = DateTime.UtcNow - TimeSpan.FromSeconds(2);
        private TimeSpan _BattlelogWaitDuration = TimeSpan.FromSeconds(1);
        private DateTime _LastIPAPIAction = DateTime.UtcNow - TimeSpan.FromSeconds(5);
        private TimeSpan _IPAPIWaitDuration = TimeSpan.FromSeconds(5);
        private DateTime _LastGoogleAction = DateTime.UtcNow - TimeSpan.FromSeconds(0.3);
        private TimeSpan _GoogleWaitDuration = TimeSpan.FromSeconds(0.3);
        private DateTime _lastGlitchedPlayerNotification = DateTime.UtcNow;

        //Server
        private PopulationState _populationStatus = PopulationState.Unknown;
        private readonly Dictionary<PopulationState, TimeSpan> _populationDurations = new Dictionary<PopulationState, TimeSpan>();
        private Int32 _lowPopulationPlayerCount = 20;
        private Int32 _highPopulationPlayerCount = 40;

        //MySQL connection
        private String _mySqlSchemaName = "";
        private String _mySqlHostname = "";
        private String _mySqlPassword = "";
        private String _mySqlPort = "";
        private String _mySqlUsername = "";
        private readonly MySqlConnectionStringBuilder _dbCommStringBuilder = new MySqlConnectionStringBuilder();
        private Boolean _fetchActionsFromDb = true;
        private const Boolean UseConnectionPooling = true;
        private const Int32 MinConnectionPoolSize = 0;
        private const Int32 MaxConnectionPoolSize = 20;
        private const Boolean UseCompressedConnection = false;
        private const Int32 DatabaseTimeoutThreshold = 10;
        private const Int32 DatabaseSuccessThreshold = 5;
        private Boolean _databaseConnectionCriticalState;
        private Int32 _databaseSuccess;
        private Int32 _databaseTimeouts;
        private List<Double> _DatabaseReaderDurations = new List<Double>();
        private Double _DatabaseReadAverageDuration = 100;
        private List<Double> _DatabaseNonQueryDurations = new List<Double>();
        private Double _DatabaseWriteAverageDuration = 100;
        private volatile Boolean _dbSettingsChanged = true;
        private Boolean _dbTimingChecked;
        private Boolean _dbTimingValid;
        private TimeSpan _dbTimingOffset = TimeSpan.Zero;
        private Boolean _globalTimingChecked;
        private Boolean _globalTimingValid;
        private TimeSpan _globalTimingOffset = TimeSpan.Zero;
        private Boolean _timingValidOverride;
        private Hashtable _lastStatLoggerStatusUpdate;
        private String _statLoggerVersion = "BF3";

        //Action fetching
        private const Int32 DbActionFetchFrequency = 10;
        private const Int32 DbSettingFetchFrequency = 300;
        private const Int32 DbBanFetchFrequency = 60;

        //Event trigger dictionaries
        private readonly Dictionary<String, AdKatsRecord> _ActOnIsAliveDictionary = new Dictionary<String, AdKatsRecord>();
        private readonly Dictionary<String, AdKatsRecord> _ActOnSpawnDictionary = new Dictionary<String, AdKatsRecord>();
        private readonly Dictionary<String, AdKatsRecord> _LoadoutConfirmDictionary = new Dictionary<String, AdKatsRecord>();
        private readonly Dictionary<String, AdKatsRecord> _ActionConfirmDic = new Dictionary<String, AdKatsRecord>();
        private readonly Dictionary<String, Int32> _RoundMutedPlayers = new Dictionary<String, Int32>();
        private readonly Dictionary<String, AdKatsRecord> _RoundReports = new Dictionary<String, AdKatsRecord>();
        private readonly HashSet<String> _RoundReportHistory = new HashSet<String>();
        private readonly HashSet<String> _PlayersRequestingCommands = new HashSet<String>(); 

        //Threads
        private Thread _Activator;
        private Thread _Finalizer;
        private Thread _DatabaseCommunicationThread;
        private Thread _MessageProcessingThread;
        private Thread _CommandParsingThread;
        private Thread _PlayerListingThread;
        private Thread _TeamSwapThread;
        private Thread _BanEnforcerThread;
        private Thread _RoundTimerThread;
        private Thread _KillProcessingThread;
        private Thread _HackerCheckerThread;
        private Thread _DisconnectHandlingThread;
        private Thread _AccessFetchingThread;
        private Thread _ActionHandlingThread;
        private Thread _BattlelogCommThread;
        private Thread _IPAPICommThread;

        //Threading queues
        private readonly Queue<AdKatsPlayer> _BanEnforcerCheckingQueue = new Queue<AdKatsPlayer>();
        private readonly Queue<AdKatsBan> _BanEnforcerProcessingQueue = new Queue<AdKatsBan>();
        private readonly Queue<CBanInfo> _CBanProcessingQueue = new Queue<CBanInfo>();
        private readonly Queue<AdKatsCommand> _CommandRemovalQueue = new Queue<AdKatsCommand>();
        private readonly Queue<AdKatsCommand> _CommandUploadQueue = new Queue<AdKatsCommand>();
        private readonly Queue<AdKatsPlayer> _HackerCheckerQueue = new Queue<AdKatsPlayer>();
        private readonly Queue<Kill> _KillProcessingQueue = new Queue<Kill>();
        private readonly Queue<List<CPlayerInfo>> _PlayerListProcessingQueue = new Queue<List<CPlayerInfo>>();
        private readonly Queue<CPlayerInfo> _PlayerRemovalProcessingQueue = new Queue<CPlayerInfo>();
        private readonly Queue<AdKatsRole> _RoleRemovalQueue = new Queue<AdKatsRole>();
        private readonly Queue<AdKatsRole> _RoleUploadQueue = new Queue<AdKatsRole>();
        private readonly Queue<CPluginVariable> _SettingUploadQueue = new Queue<CPluginVariable>();
        private readonly Queue<AdKatsChatMessage> _UnparsedCommandQueue = new Queue<AdKatsChatMessage>();
        private readonly Queue<AdKatsChatMessage> _UnparsedMessageQueue = new Queue<AdKatsChatMessage>();
        private readonly Queue<AdKatsRecord> _UnprocessedActionQueue = new Queue<AdKatsRecord>();
        private readonly Queue<AdKatsRecord> _UnprocessedRecordQueue = new Queue<AdKatsRecord>();
        private readonly Queue<AdKatsStatistic> _UnprocessedStatisticQueue = new Queue<AdKatsStatistic>();
        private readonly Queue<AdKatsUser> _UserRemovalQueue = new Queue<AdKatsUser>();
        private readonly Queue<AdKatsUser> _UserUploadQueue = new Queue<AdKatsUser>();
        private readonly Queue<AdKatsPlayer> _BattlelogFetchQueue = new Queue<AdKatsPlayer>();
        private readonly Queue<AdKatsPlayer> _IPInfoFetchQueue = new Queue<AdKatsPlayer>();

        //Threading wait handles
        private EventWaitHandle _threadMasterWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _WeaponStatsWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _AccessFetchWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _TeamswapWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _StatLoggerStatusWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _ServerInfoWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _RoundEndingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _PlayerListUpdateWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _MessageParsingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _KillProcessingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _HackerCheckerWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _DbCommunicationWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _CommandParsingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _BanEnforcerWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _ActionHandlingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _PlayerProcessingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _PluginDescriptionWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _BattlelogCommWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        private EventWaitHandle _IPInfoWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);

        //Procon MatchCommand
        private readonly MatchCommand _PluginEnabledMatchCommand;
        private readonly MatchCommand _fetchAuthorizedSoldiersMatchCommand;
        private readonly MatchCommand _subscribeAsClientMatchCommand;
        private readonly MatchCommand _issueCommandMatchCommand;

        //Commands global
        private readonly Dictionary<long, AdKatsCommand> _CommandIDDictionary = new Dictionary<long, AdKatsCommand>();
        private readonly Dictionary<String, AdKatsCommand> _CommandKeyDictionary = new Dictionary<String, AdKatsCommand>();
        private readonly Dictionary<String, AdKatsCommand> _CommandNameDictionary = new Dictionary<String, AdKatsCommand>();
        private readonly Dictionary<String, AdKatsCommand> _CommandTextDictionary = new Dictionary<String, AdKatsCommand>();
        private readonly Dictionary<String, String> _CommandDescriptionDictionary = new Dictionary<string, string>();
        private readonly Dictionary<String, Func<AdKats, Double>> _commandTimeoutDictionary = new Dictionary<string, Func<AdKats, double>>();
        private readonly Dictionary<String, DateTime> _commandUsageTimes = new Dictionary<string, DateTime>();
        private Boolean _AllowAdminSayCommands = true;
        private Boolean _bypassCommandConfirmation = false;
        private List<String> _ExternalPlayerCommands = new List<string>();
        private List<String> _ExternalAdminCommands = new List<string>();
        private Int32 _RequiredReasonLength = 4;
        //Commands specific
        private String _ServerVoipAddress = "(TS3) TS.ADKGamers.com:3796";
        //Dynamic access
        public Func<AdKats, AdKatsPlayer, Boolean> AAPerkFunc = ((plugin, aPlayer) => ((plugin._EnableAdminAssistantPerk && aPlayer.player_aa) || (aPlayer.player_reputation > _reputationThresholdGood)));
        public Func<AdKats, AdKatsPlayer, Boolean> TeamSwapFunc = ((plugin, aPlayer) => ((plugin._EnableAdminAssistantPerk && aPlayer.player_aa) || plugin.GetMatchingASPlayersOfGroup("whitelist_teamswap", aPlayer).Any()));

        //Roles
        private readonly Dictionary<long, AdKatsRole> _RoleIDDictionary = new Dictionary<long, AdKatsRole>();
        private readonly Dictionary<String, AdKatsRole> _RoleKeyDictionary = new Dictionary<String, AdKatsRole>();
        private readonly Dictionary<String, AdKatsRole> _RoleNameDictionary = new Dictionary<String, AdKatsRole>();
        private Boolean _PlayerRoleRefetch;

        //Users
        private const Int32 DbUserFetchFrequency = 300;
        private readonly Dictionary<long, AdKatsUser> _userCache = new Dictionary<long, AdKatsUser>();
        private Dictionary<Int64, AdKatsSpecialGroup> _specialPlayerGroupIDDictionary = new Dictionary<Int64, AdKatsSpecialGroup>();
        private Dictionary<String, AdKatsSpecialGroup> _specialPlayerGroupKeyDictionary = new Dictionary<String, AdKatsSpecialGroup>();
        private readonly Dictionary<Int64, AdKatsSpecialPlayer> _specialPlayerCache = new Dictionary<Int64, AdKatsSpecialPlayer>();

        //Games and teams
        private readonly Dictionary<Int64, GameVersion> _gameIDDictionary = new Dictionary<Int64, GameVersion>();
        private readonly Dictionary<Int32, AdKatsTeam> _teamDictionary = new Dictionary<Int32, AdKatsTeam>();
        private readonly Dictionary<String, Int32> _unmatchedRoundDeathCounts = new Dictionary<String, Int32>();
        private readonly HashSet<String> _unmatchedRoundDeaths = new HashSet<String>();  

        //Players
        private readonly Dictionary<String, AdKatsPlayer> _PlayerDictionary = new Dictionary<String, AdKatsPlayer>();
        private readonly Dictionary<String, AdKatsPlayer> _PlayerLeftDictionary = new Dictionary<String, AdKatsPlayer>();
        private readonly Dictionary<Int64, AdKatsPlayer> _FetchedPlayers = new Dictionary<Int64, AdKatsPlayer>(); 

        //Punishment settings
        private readonly List<String> _PunishmentSeverityIndex;
        private Boolean _CombineServerPunishments;
        private Boolean _IROActive = true;
        private Boolean _IROOverridesLowPop;
        private Int32 _IROTimeout = 10;
        private Boolean _OnlyKillOnLowPop = true;
        private String[] _PunishmentHierarchy = {
            "warn", 
            "kill", 
            "kick", 
            "tban60", 
            "tban120", 
            "tbanday",
            "tban2days",
            "tban3days", 
            "tbanweek", 
            "tban2weeks", 
            "tbanmonth", 
            "ban"
        };

        //Teamswap
        private Int32 _TeamSwapTicketWindowHigh = 500000;
        private Int32 _TeamSwapTicketWindowLow;
        private Queue<CPlayerInfo> _Team1MoveQueue = new Queue<CPlayerInfo>();
        private Queue<CPlayerInfo> _Team2MoveQueue = new Queue<CPlayerInfo>();
        private Queue<CPlayerInfo> _TeamswapForceMoveQueue = new Queue<CPlayerInfo>();
        private Queue<CPlayerInfo> _TeamswapOnDeathCheckingQueue = new Queue<CPlayerInfo>();
        private readonly Dictionary<String, CPlayerInfo> _TeamswapOnDeathMoveDic = new Dictionary<String, CPlayerInfo>();

        //AFK manager
        private Boolean _AFKManagerEnable;
        private Boolean _AFKAutoKickEnable;
        private Double _AFKTriggerDurationMinutes = 5;
        private Int32 _AFKTriggerMinimumPlayers = 20;
        private Boolean _AFKIgnoreUserList = true;
        private String[] _AFKIgnoreRoles = { };
        private Boolean _AFKIgnoreChat;

        //Ping enforcer
        private Boolean _pingEnforcerSystemEnable;
        private Int32 _pingEnforcerTriggerMinimumPlayers = 50;
        private Double _pingEnforcerLowTriggerMS = 300;
        private Double _pingEnforcerMedTriggerMS = 300;
        private Double _pingEnforcerHighTriggerMS = 300;
        private Double _pingEnforcerFullTriggerMS = 300;
        private Double _pingMovingAverageDurationSeconds = 180;
        private Boolean _pingEnforcerKickMissingPings = true;
        private Boolean _pingEnforcerIgnoreUserList = true;
        private String _pingEnforcerMessagePrefix = "Please fix your ping and join us again.";
        private String[] _pingEnforcerIgnoreRoles = { };
        private Boolean _attemptManualPingWhenMissing = true;

        //Commander manager
        private Boolean _CMDRManagerEnable;
        private Int32 _CMDRMinimumPlayers = 40;

        //Ban enforcer
        private Boolean _UseBanAppend;
        private String _BanAppend = "Appeal at your_site.com";
        private Boolean _UseBanEnforcer;
        private Boolean _UseBanEnforcerPreviousState;
        private List<AdKatsBan> _BanEnforcerSearchResults = new List<AdKatsBan>();
        private Boolean _BansQueuing;
        private String _CBanAdminName = "BanEnforcer";
        private Boolean _DefaultEnforceGUID = true;
        private Boolean _DefaultEnforceIP;
        private Boolean _DefaultEnforceName;
        private Int64 _GUIDBanCount = -1;
        private Int64 _IPBanCount = -1;
        private Int64 _NameBanCount = -1;
        private readonly DateTime _PermaBanEndTime = DateTime.UtcNow.AddYears(20);
        private TimeSpan _MaxTempBanDuration = TimeSpan.FromDays(3650);
        //Metabans
        private Boolean _useMetabans;
        private String _metabansAPIKey = "";
        private Boolean _metabansConnectionConfirmed = false;
        private String _metabansUsername = "";

        //Reports
        public String[] _AutoReportHandleStrings = { };
        private Boolean _InformReportedPlayers;
        private String[] _PlayerInformExclusionStrings = { };
        private Int32 _MinimumReportHandleSeconds;

        //Email
        private Boolean _UseEmail;

        //Muting
        private Int32 _MutedPlayerChances = 5;
        private String _MutedPlayerKickMessage = "Talking excessively while muted.";
        private String _MutedPlayerKillMessage = "Do not talk while muted. You can speak again next round.";
        private String _MutedPlayerMuteMessage = "You have been muted by an admin, talking will cause punishment. You can speak again next round.";
        private Boolean _MutedPlayerIgnoreCommands = true;

        //Surrender
        private Boolean _surrenderVoteEnable;
        private Double _surrenderVoteMinimumPlayerPercentage = 30;
        private Int32 _surrenderVoteMinimumPlayerCount = 16;
        private Int32 _surrenderVoteMinimumTicketGap = 250;
        private Boolean _surrenderVoteTicketRateGapEnable;
        private Double _surrenderVoteMinimumTicketRateGap = 10;
        private Boolean _surrenderVoteTimeoutEnable;
        private Double _surrenderVoteTimeoutMinutes = 5;
        private Boolean _surrenderVoteActive;
        private Boolean _surrenderVoteSucceeded;
        private DateTime _surrenderVoteStartTime = DateTime.UtcNow;
        private readonly HashSet<String> _surrenderVoteList = new HashSet<String>();
        private readonly HashSet<String> _nosurrenderVoteList = new HashSet<String>(); 
        //Auto-Surrender
        private Boolean _surrenderAutoEnable;
        private Boolean _surrenderAutoSucceeded;
        private Boolean _surrenderAutoUseMetroValues;
        private Boolean _surrenderAutoUseLockerValues;
        private Boolean _surrenderAutoUseAdjustedTicketRates;
        private Int32 _surrenderAutoMinimumTicketGap = 100;
        private Double _surrenderAutoLosingRateMax = 999;
        private Double _surrenderAutoLosingRateMin = 999;
        private Double _surrenderAutoWinningRateMax = 999;
        private Double _surrenderAutoWinningRateMin = 999;
        private Int32 _surrenderAutoTriggerCountToSurrender = 1;
        private Int32 _surrenderAutoTriggerCountCurrent;
        private Int32 _surrenderAutoMinimumPlayers = 10;
        private String _surrenderAutoMessage = "Ending/Scrambling Baserape Round. %WinnerName% Wins!";
        private Boolean _surrenderAutoNukeWinning;
        private Boolean _surrenderAutoTriggerVote;
        private String _surrenderAutoNukeMessage = "Nuking %WinnerName% for baserape!";
            
        //EmailHandler
        private EmailHandler _EmailHandler;
        private Boolean _emailReportsOnlyWhenAdminless;

        //Orchestration
        private List<String> _CurrentReservedSlotPlayers;
        private List<String> _CurrentSpectatorListPlayers;
        private Boolean _FeedMultiBalancerWhitelist;
        private Boolean _FeedMultiBalancerWhitelist_Admins = true;
        private Boolean _FeedMultiBalancerDisperseList;
        private Boolean _FeedServerReservedSlots;
        private Boolean _FeedServerReservedSlots_Admins = true;
        private Boolean _FeedServerSpectatorList;
        private Boolean _FeedServerSpectatorList_Admins;
        private Boolean _FeedStatLoggerSettings;
        private Boolean _PostStatLoggerChatManually;
        private Boolean _PostStatLoggerChatManually_PostServerChatSpam = true;
        private Boolean _PostStatLoggerChatManually_IgnoreCommands = false;
        private Boolean _PostMapBenefitStatistics;
        private Boolean _MULTIBalancerUnswitcherDisabled = false;
        public readonly String[] _subscriptionGroups = {"OnlineSoldiers"};
        private readonly List<AdKatsClient> _subscribedClients = new List<AdKatsClient>();

        //Hacker-checker
        private Boolean _UseHackerChecker;
        private Boolean _UseDpsChecker;
        private Boolean _UseHskChecker;
        private Boolean _UseKpmChecker;
        private Double _DpsTriggerLevel = 50.0;
        private Double _HskTriggerLevel = 60.0;
        private Double _KpmTriggerLevel = 5.0;
        private String _HackerCheckerDPSBanMessage = "DPS Automatic Ban";
        private String _HackerCheckerHSKBanMessage = "HSK Automatic Ban";
        private String _HackerCheckerKPMBanMessage = "KPM Automatic Ban";

        //External commands
        private String _instanceKey = AdKats.GetRandom32BitHashCode();

        //Admin assistants
        public Boolean _EnableAdminAssistantPerk = false;
        public Boolean _EnableAdminAssistants = false;
        public Int32 _MinimumRequiredMonthlyReports = 10;
        public Boolean _UseAAReportAutoHandler = false;

        //Messaging
        private List<String> _PreMessageList;
        private Boolean _RequirePreMessageUse;
        private Boolean _ShowAdminNameInAnnouncement;
        private Boolean _ShowNewPlayerAnnouncement = true;
        private Boolean _ShowPlayerNameChangeAnnouncement = true;
        private Boolean _ShowTargetedPlayerLeftNotification = true;
        private Int32 _YellDuration = 5;
        private Boolean _UseFirstSpawnMessage;
        private Boolean _useFirstSpawnRepMessage;
        private String _FirstSpawnMessage = "FIRST SPAWN MESSAGE";
        private Boolean _DisplayTicketRatesInProconChat;
        private Boolean _InformReputablePlayersOfAdminJoins = true;

        //SpamBot
        private Boolean _spamBotEnabled;
        private List<String> _spamBotSayList;
        private readonly Queue<String> _spamBotSayQueue = new Queue<String>();
        private Int32 _spamBotSayDelaySeconds = 300;
        private DateTime _spamBotSayLastPost = DateTime.UtcNow - TimeSpan.FromSeconds(300);
        private List<String> _spamBotYellList;
        private readonly Queue<String> _spamBotYellQueue = new Queue<String>();
        private Int32 _spamBotYellDelaySeconds = 600;
        private DateTime _spamBotYellLastPost = DateTime.UtcNow - TimeSpan.FromSeconds(600);
        private List<String> _spamBotTellList;
        private readonly Queue<String> _spamBotTellQueue = new Queue<String>();
        private Int32 _spamBotTellDelaySeconds = 900;
        private DateTime _spamBotTellLastPost = DateTime.UtcNow - TimeSpan.FromSeconds(900);
        private Boolean _spamBotExcludeAdminsAndWhitelist;
        //Rules
        private Double _ServerRulesDelay = 0.5;
        private Double _ServerRulesInterval = 5;
        private String[] _ServerRulesList = { "This server has not set rules yet." };
        private Boolean _ServerRulesNumbers = true;
        private Boolean _ServerRulesYell = false;

        //Locking
        private Double _playerLockingManualDuration = 10;
        private Boolean _playerLockingAutomaticLock = false;
        private Double _playerLockingAutomaticDuration = 2.5;

        //Round monitor
        private Boolean _useRoundTimer;
        private Double _maxRoundTimeMinutes = 30;

        //Reputation
        private Dictionary<String, Double> _commandSourceReputationDictionary;
        private Dictionary<String, Double> _commandTargetReputationDictionary;
        private const Double _reputationThresholdGood = 75;
        private const Double _reputationThresholdBad = 0;

        //Weapon stats
        private readonly Dictionary<String, AdKatsWeaponName> _weaponNames = new Dictionary<String, AdKatsWeaponName>();
        private StatLibrary _StatLibrary;

        //Experimental
        private Boolean _useExperimentalTools;
        private Ping _pingProcessor = new Ping();
        private Boolean _UsingAwa;
        private Boolean _WeaponCodesTableTested;
        private Boolean _WeaponCodesTableConfirmed;
        private Boolean _UseGrenadeCookCatcher;
        private Dictionary<String, AdKatsPlayer> _RoundCookers = new Dictionary<String, AdKatsPlayer>();
        private Boolean _UseWeaponLimiter;
        private String _WeaponLimiterExceptionString = "_Flechette|_Slug";
        private String _WeaponLimiterString = "M320|RPG|SMAW|C4|M67|Claymore|FGM-148|FIM92|ROADKILL|Death|_LVG|_HE|_Frag|_XM25|_FLASH|_V40|_M34|_Flashbang|_SMK|_Smoke|_FGM148|_Grenade|_SLAM|_NLAW|_RPG7|_C4|_Claymore|_FIM92|_M67|_SMAW|_SRAW|_Sa18IGLA|_Tomahawk";

        public AdKats() {
            //Create the server reference
            _serverInfo = new AdKatsServer(this);

            //Set defaults for webclient
            System.Net.ServicePointManager.Expect100Continue = false;

            //By default plugin is not enabled or ready
            _pluginEnabled = false;
            _threadsReady = false;
            //Assign the match commands
            _PluginEnabledMatchCommand = new MatchCommand(
                "AdKats",
                "PluginEnabled",
                new List<String>(),
                "AdKats_PluginEnabled",
                new List<MatchArgumentFormat>(),
                new ExecutionRequirements(ExecutionScope.None),
                "Useable by other plugins to check if AdKats is enabled or in process of starting up.");
            _issueCommandMatchCommand = new MatchCommand(
                "AdKats",
                "IssueCommand",
                new List<String>(),
                "AdKats_IssueCommand",
                new List<MatchArgumentFormat>(),
                new ExecutionRequirements(ExecutionScope.None),
                "Useable by other plugins to call AdKats commands.");
            _fetchAuthorizedSoldiersMatchCommand = new MatchCommand(
                "AdKats", 
                "FetchAuthorizedSoldiers", 
                new List<String>(), 
                "AdKats_FetchAuthorizedSoldiers", 
                new List<MatchArgumentFormat>(), 
                new ExecutionRequirements(ExecutionScope.None),
                "Useable by other plugins to fetch authorized soldiers.");
            _subscribeAsClientMatchCommand = new MatchCommand(
                "AdKats",
                "SubscribeAsClient",
                new List<String>(),
                "AdKats_SubscribeAsClient",
                new List<MatchArgumentFormat>(),
                new ExecutionRequirements(ExecutionScope.None),
                "Useable by other plugins to subscribe to group events.");
            //Debug level is 0 by default
            _debugLevel = 0;

            //Init the punishment severity index
            _PunishmentSeverityIndex = new List<String> {
                "warn",
                "kill",
                "kick",
                "tban60",
                "tban120",
                "tbanday",
                "tban2days",
                "tban3days",
                "tbanweek",
                "tban2weeks",
                "tbanmonth",
                "ban"
            };

            //Init the pre-message list
            _PreMessageList = new List<String> {
                "US TEAM: DO NOT BASERAPE, YOU WILL BE PUNISHED.",
                "RU TEAM: DO NOT BASERAPE, YOU WILL BE PUNISHED.",
                "US TEAM: DO NOT ENTER THE STREETS BEYOND 'A', YOU WILL BE PUNISHED.",
                "RU TEAM: DO NOT GO BEYOND THE BLACK LINE ON CEILING BY 'C' FLAG, YOU WILL BE PUNISHED.",
                "THIS SERVER IS NO EXPLOSIVES, YOU WILL BE PUNISHED FOR INFRACTIONS.",
                "JOIN OUR TEAMSPEAK AT TS.ADKGAMERS.COM:3796"
            };

            //Init the spam message lists
            _spamBotSayList = new List<String> {
                "AdminSay1",
                "AdminSay2",
                "AdminSay3"
            };
            foreach (String line in _spamBotSayList)
            {
                _spamBotSayQueue.Enqueue(line);
            }
            _spamBotYellList = new List<String> {
                "AdminYell1",
                "AdminYell2",
                "AdminYell3"
            };
            foreach (String line in _spamBotYellList)
            {
                _spamBotYellQueue.Enqueue(line);
            }
            _spamBotTellList = new List<String> {
                "AdminTell1",
                "AdminTell2",
                "AdminTell3"
            };
            foreach (String line in _spamBotTellList)
            {
                _spamBotTellQueue.Enqueue(line);
            }

            //Fill the population durations
            foreach (var popState in Enum.GetValues(typeof (PopulationState)).Cast<PopulationState>()) {
                _populationDurations[popState] = TimeSpan.Zero;
            }

            //Fetch the plugin description and changelog
            FetchPluginDocumentation();

            //Fill command descriptions
            FillCommandDescDictionary();

            //Prepare the keep-alive
            SetupStatusMonitor();
        }

        public String GetPluginName() {
            return "AdKats - Advanced In-Game Admin";
        }

        public String GetPluginVersion() {
            return PluginVersion;
        }

        public String GetPluginAuthor() {
            return "[ADK]ColColonCleaner";
        }

        public String GetPluginWebsite() {
            return "https://github.com/AdKats/AdKats/";
        }

        public String GetPluginDescription() {
            String concat = @"
            <p>
                <a href='https://github.com/AdKats/AdKats' name=adkats>
                    <img src='https://raw.githubusercontent.com/AdKats/AdKats/master/images/AdKats.jpg' alt='AdKats Advanced In-Game Admin Tools'>
                </a>
            </p>";
            try
            {
                if (!_fetchedPluginInformation)
                {
                    //Wait up to 10 seconds for the description to fetch
                    DebugWrite("Waiting for plugin information...", 1);
                    _PluginDescriptionWaitHandle.WaitOne(10000);
                }

                //Parse out the descriptions
                if (!String.IsNullOrEmpty(_pluginVersionStatusString))
                {
                    concat += _pluginVersionStatusString;
                }
                if (!String.IsNullOrEmpty(_pluginLinks))
                {
                    concat += _pluginLinks;
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching plugin information.", e));
            }
            return concat;
        }

        public List<CPluginVariable> GetDisplayPluginVariables() {
            try {
                var lstReturn = new List<CPluginVariable>();
                const string separator = " | ";

                if (_settingsLocked) {
                    lstReturn.Add(new CPluginVariable("1. Server Settings|Unlock Settings", typeof (String), ""));
                }
                else {
                    lstReturn.Add(new CPluginVariable(String.IsNullOrEmpty(_settingsPassword) ? ("1. Server Settings|Lock Settings - Create Password") : ("1. Server Settings|Lock Settings"), typeof (String), ""));
                }

                //Only fetch the following settings when plugin disabled
                if (!_threadsReady) {
                    if (!_settingsLocked) {
                        if (_useKeepAlive) {
                            lstReturn.Add(new CPluginVariable("0. Instance Settings|Auto-Enable/Keep-Alive", typeof (Boolean), true));
                        }

                        lstReturn.Add(new CPluginVariable("Complete these settings before enabling.", typeof (String), "Once enabled, more settings will appear."));
                        //SQL Settings
                        lstReturn.Add(new CPluginVariable("1. MySQL Settings|MySQL Hostname", typeof (String), _mySqlHostname));
                        lstReturn.Add(new CPluginVariable("1. MySQL Settings|MySQL Port", typeof (String), _mySqlPort));
                        lstReturn.Add(new CPluginVariable("1. MySQL Settings|MySQL Database", typeof (String), _mySqlSchemaName));
                        lstReturn.Add(new CPluginVariable("1. MySQL Settings|MySQL Username", typeof (String), _mySqlUsername));
                        lstReturn.Add(new CPluginVariable("1. MySQL Settings|MySQL Password", typeof (String), _mySqlPassword));
                    }
                    //Debugging Settings
                    lstReturn.Add(new CPluginVariable("2. Debugging|Debug level", typeof(Int32), _debugLevel));
                    //Database Timing
                    if (_dbTimingChecked && !_dbTimingValid)
                    {
                        lstReturn.Add(new CPluginVariable("3. Database Timing Mismatch|Override Timing Confirmation", typeof(Boolean), _timingValidOverride));
                    }
                }
                else {
                    if (_settingsLocked) {
                        lstReturn.Add(new CPluginVariable("1. Server Settings|Server ID (Display)", typeof (int), _serverInfo.ServerID));
                        lstReturn.Add(new CPluginVariable("1. Server Settings|Server IP (Display)", typeof (String), _serverInfo.ServerIP));
                        if (_UseBanEnforcer) {
                            const string banManagementPrefix = "A13-3. Mini Ban Management|";
                            lstReturn.Add(new CPluginVariable(banManagementPrefix + "NAME Ban Count", typeof (int), _NameBanCount));
                            lstReturn.Add(new CPluginVariable(banManagementPrefix + "GUID Ban Count", typeof (int), _GUIDBanCount));
                            lstReturn.Add(new CPluginVariable(banManagementPrefix + "IP Ban Count", typeof (int), _IPBanCount));
                            lstReturn.Add(new CPluginVariable(banManagementPrefix + "Ban Search", typeof (String), ""));
                            lstReturn.AddRange(_BanEnforcerSearchResults.Select(aBan => new CPluginVariable(banManagementPrefix + "BAN" + aBan.ban_id + separator + aBan.ban_record.target_player.player_name + separator + aBan.ban_record.source_name + separator + aBan.ban_record.record_message, "enum.commandActiveEnum(Active|Disabled|Expired)", aBan.ban_status)));
                        }
                        lstReturn.Add(new CPluginVariable("D99. Debugging|Debug level", typeof (int), _debugLevel));
                        lstReturn.Add(new CPluginVariable("D99. Debugging|Debug Soldier Name", typeof (String), _debugSoldierName));
                        return lstReturn;
                    }
                    //Auto-Enable Settings
                    lstReturn.Add(new CPluginVariable("0. Instance Settings|Auto-Enable/Keep-Alive", typeof(Boolean), _useKeepAlive));

                    //Server Settings
                    lstReturn.Add(new CPluginVariable("1. Server Settings|Setting Import", typeof(String), _serverInfo.ServerID));
                    lstReturn.Add(new CPluginVariable("1. Server Settings|Server ID (Display)", typeof(Int32), _serverInfo.ServerID));
                    lstReturn.Add(new CPluginVariable("1. Server Settings|Server IP (Display)", typeof(String), _serverInfo.ServerIP));
                    lstReturn.Add(new CPluginVariable("1. Server Settings|Low Population Value", typeof(Int32), _lowPopulationPlayerCount));
                    lstReturn.Add(new CPluginVariable("1. Server Settings|High Population Value", typeof(Int32), _highPopulationPlayerCount));

                    //SQL Settings
                    lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Hostname", typeof (String), _mySqlHostname));
                    lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Port", typeof (String), _mySqlPort));
                    lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Database", typeof (String), _mySqlSchemaName));
                    lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Username", typeof (String), _mySqlUsername));
                    lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Password", typeof (String), _mySqlPassword));

                    //Punishment Settings
                    lstReturn.Add(new CPluginVariable("7. Punishment Settings|Punishment Hierarchy", typeof (String[]), _PunishmentHierarchy));
                    lstReturn.Add(new CPluginVariable("7. Punishment Settings|Combine Server Punishments", typeof (Boolean), _CombineServerPunishments));
                    lstReturn.Add(new CPluginVariable("7. Punishment Settings|Only Kill Players when Server in low population", typeof (Boolean), _OnlyKillOnLowPop));
                    lstReturn.Add(new CPluginVariable("7. Punishment Settings|Use IRO Punishment", typeof (Boolean), _IROActive));
                    if (_IROActive) {
                        lstReturn.Add(new CPluginVariable("7. Punishment Settings|IRO Timeout Minutes", typeof (Int32), _IROTimeout));
                        lstReturn.Add(new CPluginVariable("7. Punishment Settings|IRO Punishment Overrides Low Pop", typeof (Boolean), _IROOverridesLowPop));
                    }

                    //Email Settings
                    lstReturn.Add(new CPluginVariable("8. Email Settings|Send Emails", typeof(Boolean), _UseEmail));
                    if (_UseEmail) {
                        lstReturn.Add(new CPluginVariable("8. Email Settings|Use SSL?", typeof (Boolean), _EmailHandler.UseSSL));
                        lstReturn.Add(new CPluginVariable("8. Email Settings|SMTP-Server address", typeof (String), _EmailHandler.SMTPServer));
                        lstReturn.Add(new CPluginVariable("8. Email Settings|SMTP-Server port", typeof (int), _EmailHandler.SMTPPort));
                        lstReturn.Add(new CPluginVariable("8. Email Settings|Sender address", typeof (String), _EmailHandler.SenderEmail));
                        lstReturn.Add(new CPluginVariable("8. Email Settings|SMTP-Server username", typeof (String), _EmailHandler.SMTPUser));
                        lstReturn.Add(new CPluginVariable("8. Email Settings|SMTP-Server password", typeof (String), _EmailHandler.SMTPPassword));
                        lstReturn.Add(new CPluginVariable("8. Email Settings|Custom HTML Addition", typeof (String), _EmailHandler.CustomHTMLAddition));
                        lstReturn.Add(new CPluginVariable("8. Email Settings|Extra Recipient Email Addresses", typeof (String[]), _EmailHandler.RecipientEmails.ToArray()));
                        lstReturn.Add(new CPluginVariable("8. Email Settings|Only Send Report Emails When Admins Offline", typeof(Boolean), _emailReportsOnlyWhenAdminless));
                    }

                    //TeamSwap Settings
                    lstReturn.Add(new CPluginVariable("9. TeamSwap Settings|Ticket Window High", typeof (int), _TeamSwapTicketWindowHigh));
                    lstReturn.Add(new CPluginVariable("9. TeamSwap Settings|Ticket Window Low", typeof (int), _TeamSwapTicketWindowLow));

                    //Admin Assistant Settings
                    lstReturn.Add(new CPluginVariable("A10. Admin Assistant Settings|Enable Admin Assistants", typeof (Boolean), _EnableAdminAssistants));
                    if (_EnableAdminAssistants) {
                        lstReturn.Add(new CPluginVariable("A10. Admin Assistant Settings|Minimum Confirmed Reports Per Month", typeof (int), _MinimumRequiredMonthlyReports));
                        lstReturn.Add(new CPluginVariable("A10. Admin Assistant Settings|Enable Admin Assistant Perk", typeof (Boolean), _EnableAdminAssistantPerk));
                        lstReturn.Add(new CPluginVariable("A10. Admin Assistant Settings|Use AA Report Auto Handler", typeof (Boolean), _UseAAReportAutoHandler));
                        if (_UseAAReportAutoHandler) {
                            lstReturn.Add(new CPluginVariable("A10. Admin Assistant Settings|Auto-Report-Handler Strings", typeof (String[]), _AutoReportHandleStrings));
                        }
                    }

                    //Muting Settings
                    lstReturn.Add(new CPluginVariable("A11. Player Mute Settings|On-Player-Muted Message", typeof (String), _MutedPlayerMuteMessage));
                    lstReturn.Add(new CPluginVariable("A11. Player Mute Settings|On-Player-Killed Message", typeof (String), _MutedPlayerKillMessage));
                    lstReturn.Add(new CPluginVariable("A11. Player Mute Settings|On-Player-Kicked Message", typeof (String), _MutedPlayerKickMessage));
                    lstReturn.Add(new CPluginVariable("A11. Player Mute Settings|# Chances to give player before kicking", typeof(int), _MutedPlayerChances));
                    lstReturn.Add(new CPluginVariable("A11. Player Mute Settings|Ignore commands for mute enforcement", typeof(Boolean), _MutedPlayerIgnoreCommands));

                    //Message Settings
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Display Admin Name in Kick and Ban Announcement", typeof(Boolean), _ShowAdminNameInAnnouncement));
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Display New Player Announcement", typeof(Boolean), _ShowNewPlayerAnnouncement));
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Display Player Name Change Announcement", typeof(Boolean), _ShowPlayerNameChangeAnnouncement));
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Display Targeted Player Left Notification", typeof(Boolean), _ShowTargetedPlayerLeftNotification));
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Display Ticket Rates in Procon Chat", typeof(Boolean), _DisplayTicketRatesInProconChat));
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Inform players of reports against them", typeof (Boolean), _InformReportedPlayers));
                    if (_InformReportedPlayers) {
                        lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Player Inform Exclusion Strings", typeof (String[]), _PlayerInformExclusionStrings));
                    }
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Inform reputable players and admins of admin joins", typeof(Boolean), _InformReputablePlayersOfAdminJoins));
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Yell display time seconds", typeof (int), _YellDuration));
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Pre-Message List", typeof(String[]), _PreMessageList.ToArray()));
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Require Use of Pre-Messages", typeof(Boolean), _RequirePreMessageUse));
                    lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Use first spawn message", typeof(Boolean), _UseFirstSpawnMessage));
                    if (_UseFirstSpawnMessage)
                    {
                        lstReturn.Add(new CPluginVariable("A12. Messaging Settings|First spawn message text", typeof(String), _FirstSpawnMessage));
                        lstReturn.Add(new CPluginVariable("A12. Messaging Settings|Use First Spawn Reputation and Infraction Message", typeof(String), _useFirstSpawnRepMessage));
                    }

                    lstReturn.Add(new CPluginVariable("A12-2. SpamBot Settings|SpamBot Enable", typeof(Boolean), _spamBotEnabled));
                    lstReturn.Add(new CPluginVariable("A12-2. SpamBot Settings|SpamBot Say List", typeof(String[]), _spamBotSayList.ToArray()));
                    lstReturn.Add(new CPluginVariable("A12-2. SpamBot Settings|SpamBot Say Delay Seconds", typeof(int), _spamBotSayDelaySeconds));
                    lstReturn.Add(new CPluginVariable("A12-2. SpamBot Settings|SpamBot Yell List", typeof(String[]), _spamBotYellList.ToArray()));
                    lstReturn.Add(new CPluginVariable("A12-2. SpamBot Settings|SpamBot Yell Delay Seconds", typeof(int), _spamBotYellDelaySeconds));
                    lstReturn.Add(new CPluginVariable("A12-2. SpamBot Settings|SpamBot Tell List", typeof(String[]), _spamBotTellList.ToArray()));
                    lstReturn.Add(new CPluginVariable("A12-2. SpamBot Settings|SpamBot Tell Delay Seconds", typeof(int), _spamBotTellDelaySeconds));
                    lstReturn.Add(new CPluginVariable("A12-2. SpamBot Settings|Exclude Admins and Whitelist from Spam", typeof(Boolean), _spamBotExcludeAdminsAndWhitelist));

                    //Ban Settings
                    lstReturn.Add(new CPluginVariable("A13. Banning Settings|Use Additional Ban Message", typeof (Boolean), _UseBanAppend));
                    if (_UseBanAppend) {
                        lstReturn.Add(new CPluginVariable("A13. Banning Settings|Additional Ban Message", typeof (String), _BanAppend));
                    }
                    lstReturn.Add(new CPluginVariable("A13. Banning Settings|Procon Ban Admin Name", typeof (String), _CBanAdminName));
                    const string banEnforcerPrefix = "A13-2. Ban Enforcer Settings|";
                    if (!_UsingAwa) {
                        lstReturn.Add(new CPluginVariable(banEnforcerPrefix + "Use Ban Enforcer", typeof (Boolean), _UseBanEnforcer));
                    }
                    if (_UseBanEnforcer) {
                        lstReturn.Add(new CPluginVariable(banEnforcerPrefix + "Enforce New Bans by NAME", typeof (Boolean), _DefaultEnforceName));
                        lstReturn.Add(new CPluginVariable(banEnforcerPrefix + "Enforce New Bans by GUID", typeof (Boolean), _DefaultEnforceGUID));
                        lstReturn.Add(new CPluginVariable(banEnforcerPrefix + "Enforce New Bans by IP", typeof (Boolean), _DefaultEnforceIP));

                        //Metabans Settings
                        lstReturn.Add(new CPluginVariable(banEnforcerPrefix + "Use Metabans?", typeof (bool), _useMetabans));
                        if (_useMetabans) {
                            lstReturn.Add(new CPluginVariable(banEnforcerPrefix + "Metabans Username", typeof (String), _metabansUsername));
                            lstReturn.Add(new CPluginVariable(banEnforcerPrefix + "Metabans API Key", typeof (String), _metabansAPIKey));
                        }
                    }

                    //External Command Settings
                    lstReturn.Add(new CPluginVariable("A14. External Command Settings|AdkatsLRT Extension Token", typeof(String), _AdKatsLRTExtensionToken));
                    if (!_UseBanEnforcer && !_UsingAwa) {
                        lstReturn.Add(new CPluginVariable("A14. External Command Settings|Fetch Actions from Database", typeof (Boolean), _fetchActionsFromDb));
                    }

                    lstReturn.Add(new CPluginVariable("A15. VOIP Settings|Server VOIP Address", typeof(String), _ServerVoipAddress));

                    lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Feed MULTIBalancer Whitelist", typeof (Boolean), _FeedMultiBalancerWhitelist));
                    if (_FeedMultiBalancerWhitelist) {
                        lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Automatic MULTIBalancer Whitelist for Admins", typeof (Boolean), _FeedMultiBalancerWhitelist_Admins));
                    }
                    lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Feed MULTIBalancer Even Dispersion List", typeof (Boolean), _FeedMultiBalancerDisperseList));
                    lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Feed Server Reserved Slots", typeof (Boolean), _FeedServerReservedSlots));
                    if (_FeedServerReservedSlots) {
                        lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Automatic Reserved Slot for Admins", typeof (Boolean), _FeedServerReservedSlots_Admins));
                    }
                    lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Feed Server Spectator List", typeof (Boolean), _FeedServerSpectatorList));
                    if (_FeedServerSpectatorList) {
                        lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Automatic Spectator Slot for Admins", typeof(Boolean), _FeedServerSpectatorList_Admins));
                    }
                    lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Feed Stat Logger Settings", typeof(Boolean), _FeedStatLoggerSettings));
                    lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Post Stat Logger Chat Manually", typeof(Boolean), _PostStatLoggerChatManually));
                    if (_PostStatLoggerChatManually)
                    {
                        lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Post Server Chat Spam", typeof(Boolean), _PostStatLoggerChatManually_PostServerChatSpam));
                        lstReturn.Add(new CPluginVariable("A16. Orchestration Settings|Exclude Commands from Chat Logs", typeof(Boolean), _PostStatLoggerChatManually_IgnoreCommands));
                    }

                    lstReturn.Add(new CPluginVariable("A17. Round Settings|Round Timer: Enable", typeof (Boolean), _useRoundTimer));
                    if (_useRoundTimer) {
                        lstReturn.Add(new CPluginVariable("A17. Round Settings|Round Timer: Round Duration Minutes", typeof (Double), _maxRoundTimeMinutes));
                    }

                    lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: Enable", typeof (Boolean), _UseHackerChecker));
                    if (_UseHackerChecker) {
                        if (_isTestingAuthorized) {
                            lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|Hacker-Check Player", typeof (String), ""));
                        }
                        //lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: Whitelist", typeof (String[]), _HackerCheckerWhitelist));
                        lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: DPS Checker: Enable", typeof (Boolean), _UseDpsChecker));
                        if (_UseDpsChecker) {
                            lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: DPS Checker: Trigger Level", typeof (Double), _DpsTriggerLevel));
                            lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: DPS Checker: Ban Message", typeof (String), _HackerCheckerDPSBanMessage));
                        }
                        lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: HSK Checker: Enable", typeof (Boolean), _UseHskChecker));
                        if (_UseHskChecker) {
                            lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: HSK Checker: Trigger Level", typeof (Double), _HskTriggerLevel));
                            lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: HSK Checker: Ban Message", typeof (String), _HackerCheckerHSKBanMessage));
                        }
                        lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: KPM Checker: Enable", typeof (Boolean), _UseKpmChecker));
                        if (_UseKpmChecker) {
                            lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: KPM Checker: Trigger Level", typeof (Double), _KpmTriggerLevel));
                            lstReturn.Add(new CPluginVariable("A18. Internal Hacker-Checker Settings|HackerChecker: KPM Checker: Ban Message", typeof (String), _HackerCheckerKPMBanMessage));
                        }
                    }

                    //Server rules settings
                    lstReturn.Add(new CPluginVariable("A19. Server Rules Settings|Rule Print Delay", typeof(Double), _ServerRulesDelay));
                    lstReturn.Add(new CPluginVariable("A19. Server Rules Settings|Rule Print Interval", typeof(Double), _ServerRulesInterval));
                    lstReturn.Add(new CPluginVariable("A19. Server Rules Settings|Server Rule List", typeof(String[]), _ServerRulesList));
                    lstReturn.Add(new CPluginVariable("A19. Server Rules Settings|Server Rule Numbers", typeof(Boolean), _ServerRulesNumbers));
                    lstReturn.Add(new CPluginVariable("A19. Server Rules Settings|Yell Server Rules", typeof(Boolean), _ServerRulesYell));

                    //AFK manager settings
                    lstReturn.Add(new CPluginVariable("B20. AFK Settings|AFK System Enable", typeof(Boolean), _AFKManagerEnable));
                    if (_AFKManagerEnable)
                    {
                        lstReturn.Add(new CPluginVariable("B20. AFK Settings|AFK Ignore Chat", typeof(Boolean), _AFKIgnoreChat));
                        lstReturn.Add(new CPluginVariable("B20. AFK Settings|AFK Auto-Kick Enable", typeof(Boolean), _AFKAutoKickEnable));
                        lstReturn.Add(new CPluginVariable("B20. AFK Settings|AFK Trigger Minutes", typeof(Double), _AFKTriggerDurationMinutes));
                        lstReturn.Add(new CPluginVariable("B20. AFK Settings|AFK Minimum Players", typeof(Int32), _AFKTriggerMinimumPlayers));
                        lstReturn.Add(new CPluginVariable("B20. AFK Settings|AFK Ignore User List", typeof(Boolean), _AFKIgnoreUserList));
                        if (!_AFKIgnoreUserList)
                        {
                            lstReturn.Add(new CPluginVariable("B20. AFK Settings|AFK Ignore Roles", typeof(String[]), _AFKIgnoreRoles));
                        }
                    }

                    //Ping enforcer settings
                    lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Enforcer Enable", typeof(Boolean), _pingEnforcerSystemEnable));
                    if (_pingEnforcerSystemEnable)
                    {
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Moving Average Duration sec", typeof(Double), _pingMovingAverageDurationSeconds));
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Kick Low Population Trigger ms", typeof(Double), _pingEnforcerLowTriggerMS));
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Kick Medium Population Trigger ms", typeof(Double), _pingEnforcerMedTriggerMS));
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Kick High Population Trigger ms", typeof(Double), _pingEnforcerHighTriggerMS));
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Kick Full Population Trigger ms", typeof(Double), _pingEnforcerFullTriggerMS));
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Kick Minimum Players", typeof(Int32), _pingEnforcerTriggerMinimumPlayers));
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Kick Missing Pings", typeof(Boolean), _pingEnforcerKickMissingPings));
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Attempt Manual Ping when Missing", typeof(Boolean), _attemptManualPingWhenMissing));
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Kick Ignore User List", typeof(Boolean), _pingEnforcerIgnoreUserList));
                        if (!_pingEnforcerIgnoreUserList)
                        {
                            lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Kick Ignore Roles", typeof(String[]), _pingEnforcerIgnoreRoles));
                        }
                        lstReturn.Add(new CPluginVariable("B21. Ping Enforcer Settings|Ping Kick Message Prefix", typeof(String), _pingEnforcerMessagePrefix));
                    }

                    //Commander manager settings
                    lstReturn.Add(new CPluginVariable("B22. Commander Manager Settings|Commander Manager Enable", typeof(Boolean), _CMDRManagerEnable));
                    if (_CMDRManagerEnable)
                    {
                        lstReturn.Add(new CPluginVariable("B22. Commander Manager Settings|Minimum Players to Allow Commanders", typeof(Int32), _CMDRMinimumPlayers));
                    }

                    //Player locking settings
                    lstReturn.Add(new CPluginVariable("B23. Player Locking Settings|Player Lock Manual Duration Minutes", typeof(Double), _playerLockingManualDuration));
                    lstReturn.Add(new CPluginVariable("B23. Player Locking Settings|Automatically Lock Players on Admin Action", typeof(Boolean), _playerLockingAutomaticLock));
                    if (_playerLockingAutomaticLock)
                    {
                        lstReturn.Add(new CPluginVariable("B23. Player Locking Settings|Player Lock Automatic Duration Minutes", typeof(Double), _playerLockingAutomaticDuration));
                    }

                    //Surrender Vote settings
                    lstReturn.Add(new CPluginVariable("B24. Surrender Vote Settings|Surrender Vote Enable", typeof(Boolean), _surrenderVoteEnable));
                    if (_surrenderVoteEnable)
                    {
                        lstReturn.Add(new CPluginVariable("B24. Surrender Vote Settings|Percentage Votes Needed for Surrender", typeof(Double), _surrenderVoteMinimumPlayerPercentage));
                        lstReturn.Add(new CPluginVariable("B24. Surrender Vote Settings|Minimum Player Count to Enable Surrender", typeof(Int32), _surrenderVoteMinimumPlayerCount));
                        lstReturn.Add(new CPluginVariable("B24. Surrender Vote Settings|Minimum Ticket Gap to Surrender", typeof(Int32), _surrenderVoteMinimumTicketGap));
                        lstReturn.Add(new CPluginVariable("B24. Surrender Vote Settings|Enable Required Ticket Rate Gap to Surrender", typeof(Boolean), _surrenderVoteTicketRateGapEnable));
                        if (_surrenderVoteTicketRateGapEnable)
                        {
                            lstReturn.Add(new CPluginVariable("B24. Surrender Vote Settings|Minimum Ticket Rate Gap to Surrender", typeof(Double), _surrenderVoteMinimumTicketRateGap));
                        }
                        lstReturn.Add(new CPluginVariable("B24. Surrender Vote Settings|Surrender Vote Timeout Enable", typeof(Boolean), _surrenderVoteTimeoutEnable));
                        if (_surrenderVoteTimeoutEnable)
                        {
                            lstReturn.Add(new CPluginVariable("B24. Surrender Vote Settings|Surrender Vote Timeout Minutes", typeof(Double), _surrenderVoteTimeoutMinutes));
                        }
                    }

                    //Auto-Surrender Settings
                    lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Enable", typeof(Boolean), _surrenderAutoEnable));
                    if (_surrenderAutoEnable)
                    {
                        lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Use Optimal Values for Metro Conquest", typeof(Boolean), _surrenderAutoUseMetroValues));
                        lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Use Optimal Values for Locker Conquest", typeof(Boolean), _surrenderAutoUseLockerValues));
                        if (!_surrenderAutoUseMetroValues && !_surrenderAutoUseLockerValues)
                        {
                            lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Minimum Ticket Gap", typeof(Int32), _surrenderAutoMinimumTicketGap));
                            lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Use Adjusted Ticket Rates", typeof(Boolean), _surrenderAutoUseAdjustedTicketRates));
                            lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Losing Team Rate Window Max", typeof(Double), _surrenderAutoLosingRateMax));
                            lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Losing Team Rate Window Min", typeof(Double), _surrenderAutoLosingRateMin));
                            lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Winning Team Rate Window Max", typeof(Double), _surrenderAutoWinningRateMax));
                            lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Winning Team Rate Window Min", typeof(Double), _surrenderAutoWinningRateMin));
                            lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Trigger Count to Surrender", typeof(Int32), _surrenderAutoTriggerCountToSurrender));
                        }
                        lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Minimum Players", typeof(Int32), _surrenderAutoMinimumPlayers));
                        lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Nuke Winning Team Instead of Surrendering Losing Team", typeof(Boolean), _surrenderAutoNukeWinning));
                        lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Start Surrender Vote Instead of Surrendering Losing Team", typeof(Boolean), _surrenderAutoTriggerVote));
                        if (!_surrenderAutoTriggerVote)
                        {
                            if (!_surrenderAutoNukeWinning)
                            {
                                lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Surrender Message", typeof(String), _surrenderAutoMessage));
                            }
                            else
                            {
                                lstReturn.Add(new CPluginVariable("B25. Auto-Surrender Settings|Auto-Nuke Message", typeof(String), _surrenderAutoNukeMessage));
                            }
                        }
                    }

                    //Statistics Settings
                    lstReturn.Add(new CPluginVariable("B26. Statistics Settings|Post Map Benefit/Detriment Statistics", typeof(Boolean), _PostMapBenefitStatistics));

                    //Debug settings
                    lstReturn.Add(new CPluginVariable("D99. Debugging|Debug level", typeof (int), _debugLevel));
                    lstReturn.Add(new CPluginVariable("D99. Debugging|Debug Soldier Name", typeof(String), _debugSoldierName));
                    lstReturn.Add(new CPluginVariable("D99. Debugging|Disable Automatic Updates", typeof(Boolean), _automaticUpdatesDisabled));
                    lstReturn.Add(new CPluginVariable("D99. Debugging|Disable Version Tracking - Required For TEST Builds", typeof(Boolean), _versionTrackingDisabled));
                    lstReturn.Add(new CPluginVariable("D99. Debugging|Command Entry", typeof (String), ""));
                    
                    //Experimental tools
                    if (_isTestingAuthorized) {
                        lstReturn.Add(new CPluginVariable("X99. Experimental|Use Experimental Tools", typeof (Boolean), _useExperimentalTools));
                        if (_useExperimentalTools) {
                            lstReturn.Add(new CPluginVariable("X99. Experimental|Send Query", typeof (String), ""));
                            lstReturn.Add(new CPluginVariable("X99. Experimental|Send Non-Query", typeof (String), ""));
                            lstReturn.Add(new CPluginVariable("X99. Experimental|Use NO EXPLOSIVES Limiter", typeof (Boolean), _UseWeaponLimiter));
                            if (_UseWeaponLimiter) {
                                lstReturn.Add(new CPluginVariable("X99. Experimental|NO EXPLOSIVES Weapon String", typeof (String), _WeaponLimiterString));
                                lstReturn.Add(new CPluginVariable("X99. Experimental|NO EXPLOSIVES Exception String", typeof (String), _WeaponLimiterExceptionString));
                            }
                            lstReturn.Add(new CPluginVariable("X99. Experimental|Use Grenade Cook Catcher", typeof (Boolean), _UseGrenadeCookCatcher));
                        }
                    }
                    if (!_UsingAwa) {
                        const string userSettingsPrefix = "3. User Settings|";
                        //User Settings
                        lstReturn.Add(new CPluginVariable(userSettingsPrefix + "Add User", typeof (String), ""));
                        if (_userCache.Count > 0) {
                            //Sort access list by access level, then by id
                            List<AdKatsUser> tempAccess = _userCache.Values.ToList();
                            tempAccess.Sort((a1, a2) => (a1.user_role.role_id == a2.user_role.role_id) ? (System.String.CompareOrdinal(a1.user_name, a2.user_name)) : ((a1.user_role.role_id < a2.user_role.role_id) ? (-1) : (1)));
                            String roleEnum = String.Empty;
                            if (_RoleKeyDictionary.Count > 0) {
                                var random = new Random();
                                foreach (AdKatsRole role in _RoleKeyDictionary.Values.ToList()) {
                                    if (String.IsNullOrEmpty(roleEnum)) {
                                        roleEnum += "enum.RoleEnum_" + random.Next(100000, 999999) + "(";
                                    }
                                    else {
                                        roleEnum += "|";
                                    }
                                    roleEnum += role.role_name;
                                }
                                roleEnum += ")";
                            }
                            foreach (AdKatsUser user in tempAccess) {
                                String userPrefix = userSettingsPrefix + "USR" + user.user_id + separator + user.user_name + separator;
                                if (_UseEmail) {
                                    lstReturn.Add(new CPluginVariable(userPrefix + "User Email", typeof (String), user.user_email));
                                }
                                lstReturn.Add(new CPluginVariable(userPrefix + "User Expiration", typeof(String), user.user_expiration.ToShortDateString()));
                                lstReturn.Add(new CPluginVariable(userPrefix + "User Notes", typeof(String), user.user_notes));
                                //Do not display phone input until that operation is available for use
                                //lstReturn.Add(new CPluginVariable(userPrefix + "User Phone", typeof(String), user.user_phone));
                                lstReturn.Add(new CPluginVariable(userPrefix + "User Role", roleEnum, user.user_role.role_name));
                                lstReturn.Add(new CPluginVariable(userPrefix + "Delete User?", typeof (String), ""));
                                lstReturn.Add(new CPluginVariable(userPrefix + "Add Soldier?", typeof (String), ""));
                                String soldierPrefix = userPrefix + "Soldiers" + separator;

                                lstReturn.AddRange(user.soldierDictionary.Values.Select(aPlayer => new CPluginVariable(soldierPrefix + aPlayer.player_id + separator + (_gameIDDictionary.ContainsKey(aPlayer.game_id) ? (_gameIDDictionary[aPlayer.game_id].ToString()) : ("INVALID GAME ID [" + aPlayer.game_id + "]")) + separator + aPlayer.player_name + separator + "Delete Soldier?", typeof (String), "")));
                            }
                        }
                        else {
                            lstReturn.Add(new CPluginVariable(userSettingsPrefix + "No Users in User List", typeof (String), "Add Users with 'Add User'."));
                        }

                        //Role Settings
                        const string roleListPrefix = "4. Role Settings|";
                        lstReturn.Add(new CPluginVariable(roleListPrefix + "Add Role", typeof(String), ""));
                        if (_RoleKeyDictionary.Count > 0)
                        {
                            lock (_RoleKeyDictionary)
                            {
                                foreach (AdKatsRole aRole in _RoleKeyDictionary.Values.ToList())
                                {
                                    lock (_CommandNameDictionary)
                                    {
                                        var random = new Random();
                                        String rolePrefix = roleListPrefix + "RLE" + aRole.role_id + separator + ((RoleIsAdmin(aRole)) ? ("[A]") : ("")) + aRole.role_name + separator;
                                        lstReturn.AddRange(
                                            from
                                                aCommand
                                            in
                                                _CommandNameDictionary.Values
                                            where
                                                aCommand.command_active == AdKatsCommand.CommandActive.Active
                                            where
                                                aRole.role_key != "guest_default" || !aCommand.command_playerInteraction
                                            let
                                                allowed = aRole.RoleAllowedCommands.ContainsKey(aCommand.command_key)
                                            let
                                                display = rolePrefix + "CDE" + aCommand.command_id + separator + aCommand.command_name + ((allowed && aCommand.command_playerInteraction) ? (" [ADMIN]") : (""))
                                            select
                                                new CPluginVariable(display, "enum.roleAllowCommandEnum(Allow|Deny)", allowed ? ("Allow") : ("Deny")));
                                        //Do not display the delete option for default guest
                                        if (aRole.role_key != "guest_default")
                                        {
                                            lstReturn.Add(new CPluginVariable(rolePrefix + "Delete Role? (All assignments will be removed)", typeof(String), ""));
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            lstReturn.Add(new CPluginVariable(roleListPrefix + "Role List Empty", typeof(String), "No valid roles found in database."));
                        }

                        //Role Group Settings
                        const string roleGroupListPrefix = "4-2. Role Group Settings|";
                        if (_RoleKeyDictionary.Count > 0)
                        {
                            lock (_RoleKeyDictionary)
                            {
                                foreach (AdKatsRole aRole in _RoleKeyDictionary.Values.ToList())
                                {
                                    lock (_specialPlayerGroupKeyDictionary)
                                    {
                                        var random = new Random();
                                        String rolePrefix = roleGroupListPrefix + "RLE" + aRole.role_id + separator + ((RoleIsAdmin(aRole)) ? ("[A]") : ("")) + aRole.role_name + separator;
                                        lstReturn.AddRange(
                                            from
                                                aGroup
                                            in
                                                _specialPlayerGroupKeyDictionary.Values
                                            let
                                                allowed = aRole.RoleSetGroups.ContainsKey(aGroup.group_key) ||
                                                (aGroup.group_key == "slot_reserved" && _FeedServerReservedSlots_Admins && RoleIsAdmin(aRole)) ||
                                                (aGroup.group_key == "slot_spectator" && _FeedServerSpectatorList_Admins && RoleIsAdmin(aRole)) ||
                                                (aGroup.group_key == "whitelist_multibalancer" && _FeedMultiBalancerWhitelist_Admins && RoleIsAdmin(aRole)) ||
                                                (aGroup.group_key == "whitelist_spambot" && _spamBotExcludeAdminsAndWhitelist && RoleIsAdmin(aRole))
                                            let
                                                display = rolePrefix + "GPE" + aGroup.group_id + separator + aGroup.group_name
                                            select
                                                new CPluginVariable(display, "enum.roleSetGroupEnum(Assign|Ignore)", allowed ? ("Assign") : ("Ignore")));
                                    }
                                }
                            }
                        }
                        else
                        {
                            lstReturn.Add(new CPluginVariable(roleGroupListPrefix + "Role List Empty", typeof(String), "No valid roles found in database."));
                        }

                        lstReturn.Add(new CPluginVariable("5. Command Settings|Minimum Required Reason Length", typeof(int), _RequiredReasonLength));
                        lstReturn.Add(new CPluginVariable("5. Command Settings|Minimum Report Handle Seconds", typeof(int), _MinimumReportHandleSeconds));
                        lstReturn.Add(new CPluginVariable("5. Command Settings|Maximum Temp-Ban Duration Minutes", typeof(Double), _MaxTempBanDuration.TotalMinutes));
                        lstReturn.Add(new CPluginVariable("5. Command Settings|Allow Commands from Admin Say", typeof(Boolean), _AllowAdminSayCommands));
                        lstReturn.Add(new CPluginVariable("5. Command Settings|Bypass all command confirmation -DO NOT USE-", typeof(Boolean), _bypassCommandConfirmation));
                        lstReturn.Add(new CPluginVariable("5. Command Settings|External plugin player commands", typeof(String[]), _ExternalPlayerCommands.ToArray()));
                        lstReturn.Add(new CPluginVariable("5. Command Settings|External plugin admin commands", typeof(String[]), _ExternalAdminCommands.ToArray()));

                        //Command Settings
                        const string commandListPrefix = "6. Command List|";
                        if (_CommandNameDictionary.Count > 0) {
                            lock (_CommandIDDictionary) {
                                foreach (AdKatsCommand command in _CommandIDDictionary.Values.ToList()) {
                                    if (command.command_active != AdKatsCommand.CommandActive.Invisible) {
                                        String commandPrefix = commandListPrefix + "CDE" + command.command_id + separator + command.command_name + separator;
                                        lstReturn.Add(new CPluginVariable(commandPrefix + "Active", "enum.commandActiveEnum(Active|Disabled)", command.command_active.ToString()));
                                        if (command.command_active != AdKatsCommand.CommandActive.Disabled) {
                                            if (command.command_logging != AdKatsCommand.CommandLogging.Mandatory && command.command_logging != AdKatsCommand.CommandLogging.Unable) {
                                                lstReturn.Add(new CPluginVariable(commandPrefix + "Logging", "enum.commandLoggingEnum(Log|Ignore)", command.command_logging.ToString()));
                                            }
                                            lstReturn.Add(new CPluginVariable(commandPrefix + "Text", typeof (String), command.command_text));
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            lstReturn.Add(new CPluginVariable(commandListPrefix + "Command List Empty", typeof (String), "No valid commands found in database."));
                        }
                    }
                    else {
                        lstReturn.Add(new CPluginVariable("3. Player Access Settings|You are using AdKats WebAdmin", typeof (String), "Manage admin settings there."));
                    }

                    if (_UseBanEnforcer) {
                        const string banManagementPrefix = "A13-3. Mini Ban Management|";
                        lstReturn.Add(new CPluginVariable(banManagementPrefix + "NAME Ban Count", typeof (int), _NameBanCount));
                        lstReturn.Add(new CPluginVariable(banManagementPrefix + "GUID Ban Count", typeof (int), _GUIDBanCount));
                        lstReturn.Add(new CPluginVariable(banManagementPrefix + "IP Ban Count", typeof (int), _IPBanCount));
                        lstReturn.Add(new CPluginVariable(banManagementPrefix + "Ban Search", typeof (String), ""));
                        lstReturn.AddRange(_BanEnforcerSearchResults.Select(aBan => new CPluginVariable(banManagementPrefix + "BAN" + aBan.ban_id + separator + aBan.ban_record.target_player.player_name + separator + aBan.ban_record.source_name + separator + aBan.ban_record.record_message, "enum.commandActiveEnum(Active|Disabled|Expired)", aBan.ban_status)));
                    }
                }
                return lstReturn;
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching display vars.", e));
                return new List<CPluginVariable>();
            }
        }

        public List<CPluginVariable> GetPluginVariables() {
            var lstReturn = new List<CPluginVariable>();

            lstReturn.Add(new CPluginVariable("0. Instance Settings|Auto-Enable/Keep-Alive", typeof(Boolean), _useKeepAlive));

            lstReturn.Add(new CPluginVariable("1. Server Settings|Settings Locked", typeof (Boolean), _settingsLocked, true));
            lstReturn.Add(new CPluginVariable("2. Server Settings|Settings Password", typeof (String), _settingsPassword));

            lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Hostname", typeof (String), _mySqlHostname));
            lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Port", typeof (String), _mySqlPort));
            lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Database", typeof (String), _mySqlSchemaName));
            lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Username", typeof (String), _mySqlUsername));
            lstReturn.Add(new CPluginVariable("2. MySQL Settings|MySQL Password", typeof (String), _mySqlPassword));

            lstReturn.Add(new CPluginVariable("3. Debugging|Debug level", typeof(Int32), _debugLevel));
            lstReturn.Add(new CPluginVariable("3. Debugging|Disable Automatic Updates", typeof(Boolean), _automaticUpdatesDisabled));
            lstReturn.Add(new CPluginVariable("3. Debugging|Disable Version Tracking - Required For TEST Builds", typeof(Boolean), _versionTrackingDisabled));

            lstReturn.Add(new CPluginVariable("4. Database Timing Mismatch|Override Timing Confirmation", typeof(Boolean), _timingValidOverride));

            return lstReturn;
        }

        public void SetPluginVariable(String strVariable, String strValue) {
            if (strValue == null) {
                return;
            }
            try {
                if (strVariable == "UpdateSettings") {
                    //Do nothing. Settings page will be updated after return.
                }
                else if (Regex.Match(strVariable, @"Auto-Enable/Keep-Alive").Success) {
                    Boolean autoEnable = Boolean.Parse(strValue);
                    if (autoEnable != _useKeepAlive) {
                        if (autoEnable)
                            Enable();
                        _useKeepAlive = autoEnable;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Enable/Keep-Alive", typeof (Boolean), _useKeepAlive));
                    }
                }
                else if (Regex.Match(strVariable, @"Override Timing Confirmation").Success) {
                    Boolean dbTimingValidOverride = Boolean.Parse(strValue);
                    if (dbTimingValidOverride != _timingValidOverride) {
                        _timingValidOverride = dbTimingValidOverride;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Override Timing Confirmation", typeof (Boolean), _timingValidOverride));
                    }
                }
                else if (Regex.Match(strVariable, @"Unlock Settings").Success) {
                    if (String.IsNullOrEmpty(strValue) || strValue.Length < 5) {
                        return;
                    }
                    if (strValue != _settingsPassword) {
                        ConsoleError("Password incorrect.");
                        return;
                    }
                    _settingsLocked = false;
                    ConsoleSuccess("Settings unlocked.");
                    QueueSettingForUpload(new CPluginVariable(@"Settings Locked", typeof (Boolean), _settingsLocked));
                }
                else if (Regex.Match(strVariable, @"Lock Settings - Create Password").Success) {
                    if (String.IsNullOrEmpty(strValue) || strValue.Length < 5) {
                        ConsoleError("Password had invalid format/length, unable to submit.");
                        return;
                    }
                    _settingsPassword = strValue;
                    _settingsLocked = true;
                    ConsoleSuccess("Password created. Settings Locked.");
                    QueueSettingForUpload(new CPluginVariable(@"Settings Password", typeof (String), _settingsPassword));
                    QueueSettingForUpload(new CPluginVariable(@"Settings Locked", typeof (Boolean), _settingsLocked));
                }
                else if (Regex.Match(strVariable, @"Lock Settings").Success) {
                    if (String.IsNullOrEmpty(strValue) || strValue.Length < 5) {
                        return;
                    }
                    if (strValue != _settingsPassword) {
                        ConsoleError("Password incorrect.");
                        return;
                    }
                    _settingsLocked = true;
                    ConsoleSuccess("Settings locked.");
                    QueueSettingForUpload(new CPluginVariable(@"Settings Locked", typeof (Boolean), _settingsLocked));
                }
                else if (Regex.Match(strVariable, @"Settings Password").Success) {
                    if (String.IsNullOrEmpty(strValue) || strValue.Length < 5) {
                        return;
                    }
                    _settingsPassword = strValue;
                }
                else if (Regex.Match(strVariable, @"Settings Locked").Success) {
                    _settingsLocked = Boolean.Parse(strValue);
                }
                else if (Regex.Match(strVariable, @"Send Query").Success) {
                    SendQuery(strValue, true);
                }
                else if (Regex.Match(strVariable, @"Send Non-Query").Success) {
                    SendNonQuery("Experimental Query", strValue, true);
                }
                else if (Regex.Match(strVariable, @"Hacker-Check Player").Success) {
                    //Create new thread to run hack check
                    var statCheckingThread = new Thread(new ThreadStart(delegate {
                        try {
                            Thread.CurrentThread.Name = "SpecialHackerCheck";
                            if (String.IsNullOrEmpty(strValue) || !_threadsReady) {
                                return;
                            }
                            ConsoleInfo("Preparing to hacker check " + strValue);
                            if (String.IsNullOrEmpty(strValue) || strValue.Length < 3) {
                                ConsoleError("Player name must be at least 3 characters long.");
                                return;
                            }
                            if (!SoldierNameValid(strValue)) {
                                ConsoleError("Player name contained invalid characters.");
                                return;
                            }
                            var aPlayer = new AdKatsPlayer(this) {
                                player_name = strValue
                            };
                            FetchPlayerStats(aPlayer);
                            if (aPlayer.stats != null) {
                                RunStatSiteHackCheck(aPlayer, true);
                            }
                            else {
                                ConsoleError("Stats not found for " + strValue);
                            }
                        }
                        catch (Exception e) {
                            HandleException(new AdKatsException("Error while manual stat checking player.", e));
                        }
                        LogThreadExit();
                    }));
                    //Start the thread
                    StartAndLogThread(statCheckingThread);
                }
                else if (Regex.Match(strVariable, @"Setting Import").Success) {
                    Int32 tmp = -1;
                    if (int.TryParse(strValue, out tmp)) {
                        if (tmp != -1)
                            QueueSettingImport(tmp);
                    }
                    else {
                        ConsoleError("Invalid Input for Setting Import");
                    }
                }
                else if (Regex.Match(strVariable, @"Using AdKats WebAdmin").Success) {
                    Boolean tmp = false;
                    if (Boolean.TryParse(strValue, out tmp)) {
                        _UsingAwa = tmp;

                        //Update necessary settings for AWA use
                        if (_UsingAwa) {
                            _UseBanEnforcer = true;
                            _fetchActionsFromDb = true;
                            _DbCommunicationWaitHandle.Set();
                        }
                    }
                    else {
                        ConsoleError("Invalid Input for Using AdKats WebAdmin");
                    }
                }

                else if (Regex.Match(strVariable, @"Command Entry").Success) {
                    if (String.IsNullOrEmpty(strValue)) {
                        return;
                    }
                    //Check if the message is a command
                    if (strValue.StartsWith("@") || strValue.StartsWith("!") || strValue.StartsWith("."))
                    {
                        strValue = strValue.Substring(1);
                    }
                    else if (strValue.StartsWith("/@") || strValue.StartsWith("/!") || strValue.StartsWith("/."))
                    {
                        strValue = strValue.Substring(2);
                    }
                    else if (strValue.StartsWith("/")) 
                    {
                        strValue = strValue.Substring(1);
                    }
                    else {
                        ConsoleError("Invalid command format.");
                        return;
                    }
                    var record = new AdKatsRecord {
                        record_source = AdKatsRecord.Sources.Settings,
                        source_name = "SettingsAdmin"
                    };
                    CompleteRecordInformation(record, strValue);
                }
                else if (Regex.Match(strVariable, @"Debug level").Success) {
                    Int32 tmp;
                    if (int.TryParse(strValue, out tmp)) {
                        if (tmp == 8345) {
                            _FetchedPlayers.Clear();
                        }
                        else if (tmp == 23548) {
                            Boolean wasAuth = _isTestingAuthorized;
                            _isTestingAuthorized = true;
                            if (!wasAuth) {
                                ConsoleWrite("Server is priviledged for testing during this instance.");
                            }
                        }
                        else if (tmp != _debugLevel) {
                            _debugLevel = tmp;
                            //Once setting has been changed, upload the change to database
                            QueueSettingForUpload(new CPluginVariable(@"Debug level", typeof (int), _debugLevel));
                        }
                    }
                }
                else if (Regex.Match(strVariable, @"Debug Soldier Name").Success) {
                    if (SoldierNameValid(strValue)) {
                        if (strValue != _debugSoldierName) {
                            _debugSoldierName = strValue;
                            //Once setting has been changed, upload the change to database
                            QueueSettingForUpload(new CPluginVariable(@"Debug Soldier Name", typeof (String), _debugSoldierName));
                        }
                    }
                }
                else if (Regex.Match(strVariable, @"Maximum Temp-Ban Duration Minutes").Success) {
                    Double maxDuration;
                    if (!Double.TryParse(strValue, out maxDuration)) {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (maxDuration <= 0)
                    {
                        ConsoleError("Max duration cannot be negative.");
                        return;
                    }
                    TimeSpan tempMaxDur = TimeSpan.FromMinutes(maxDuration);
                    if (tempMaxDur.TotalDays > 3650) {
                        ConsoleError("Max duration cannot be longer than 10 years.");
                        return;
                    }
                    _MaxTempBanDuration = tempMaxDur;
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"Maximum Temp-Ban Duration Minutes", typeof(Double), _MaxTempBanDuration.TotalMinutes));
                }
                else if (Regex.Match(strVariable, @"Server VOIP Address").Success) {
                    if (strValue != _ServerVoipAddress) {
                        _ServerVoipAddress = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Server VOIP Address", typeof (String), _ServerVoipAddress));
                    }
                }
                else if (Regex.Match(strVariable, @"Rule Print Delay").Success)
                {
                    Double delay;
                    if (!Double.TryParse(strValue, out delay))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_ServerRulesDelay != delay)
                    {
                        if (delay <= 0)
                        {
                            ConsoleError("Delay cannot be negative.");
                            delay = 1.0;
                        }
                        _ServerRulesDelay = delay;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Rule Print Delay", typeof(Double), _ServerRulesDelay));
                    }
                }
                else if (Regex.Match(strVariable, @"Rule Print Interval").Success)
                {
                    Double interval;
                    if (!Double.TryParse(strValue, out interval))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_ServerRulesInterval != interval)
                    {
                        if (interval <= 0)
                        {
                            ConsoleError("Interval cannot be negative.");
                            interval = 5.0;
                        }
                        _ServerRulesInterval = interval;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Rule Print Interval", typeof(Double), _ServerRulesInterval));
                    }
                }
                else if (Regex.Match(strVariable, @"Server Rule List").Success)
                {
                    _ServerRulesList = CPluginVariable.DecodeStringArray(strValue);
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"Server Rule List", typeof(String), CPluginVariable.EncodeStringArray(_ServerRulesList)));
                }
                else if (Regex.Match(strVariable, @"Server Rule Numbers").Success)
                {
                    Boolean ruleNumbers = Boolean.Parse(strValue);
                    if (ruleNumbers != _ServerRulesNumbers)
                    {
                        _ServerRulesNumbers = ruleNumbers;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Server Rule Numbers", typeof(Boolean), _ServerRulesNumbers));
                    }
                }
                else if (Regex.Match(strVariable, @"Yell Server Rules").Success)
                {
                    Boolean ruleYell = Boolean.Parse(strValue);
                    if (ruleYell != _ServerRulesYell)
                    {
                        _ServerRulesYell = ruleYell;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Yell Server Rules", typeof(Boolean), _ServerRulesYell));
                    }
                }
                else if (Regex.Match(strVariable, @"Disable Automatic Updates").Success)
                {
                    Boolean disableAutomaticUpdates = Boolean.Parse(strValue);
                    if (disableAutomaticUpdates != _versionTrackingDisabled)
                    {
                        _automaticUpdatesDisabled = disableAutomaticUpdates;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Disable Automatic Updates", typeof(Boolean), _automaticUpdatesDisabled));
                    }
                }
                else if (Regex.Match(strVariable, @"Disable Version Tracking - Required For TEST Builds").Success)
                {
                    Boolean disableUpdatePosts = Boolean.Parse(strValue);
                    if (disableUpdatePosts != _versionTrackingDisabled)
                    {
                        _versionTrackingDisabled = disableUpdatePosts;
                        if (_versionTrackingDisabled)
                        {
                            if (_threadsReady)
                            {
                                PostVersionTracking();
                            }
                        }
                        else
                        {
                            PostVersionTracking();
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Disable Version Tracking - Required For TEST Builds", typeof(Boolean), _versionTrackingDisabled));
                    }
                }
                else if (Regex.Match(strVariable, @"AFK System Enable").Success)
                {
                    Boolean afkSystemEnable = Boolean.Parse(strValue);
                    if (afkSystemEnable != _AFKManagerEnable)
                    {
                        _AFKManagerEnable = afkSystemEnable;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"AFK System Enable", typeof(Boolean), _AFKManagerEnable));
                    }
                }
                else if (Regex.Match(strVariable, @"AFK Ignore Chat").Success)
                {
                    Boolean afkIgnoreChat = Boolean.Parse(strValue);
                    if (afkIgnoreChat != _AFKIgnoreChat)
                    {
                        _AFKIgnoreChat = afkIgnoreChat;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"AFK Ignore Chat", typeof(Boolean), _AFKIgnoreChat));
                    }
                }
                else if (Regex.Match(strVariable, @"AFK Auto-Kick Enable").Success)
                {
                    Boolean afkAutoKickEnable = Boolean.Parse(strValue);
                    if (afkAutoKickEnable != _AFKAutoKickEnable)
                    {
                        _AFKAutoKickEnable = afkAutoKickEnable;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"AFK Auto-Kick Enable", typeof(Boolean), _AFKAutoKickEnable));
                    }
                }
                else if (Regex.Match(strVariable, @"AFK Trigger Minutes").Success)
                {
                    Double afkAutoKickDurationMinutes;
                    if (!Double.TryParse(strValue, out afkAutoKickDurationMinutes))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_AFKTriggerDurationMinutes != afkAutoKickDurationMinutes)
                    {
                        if (afkAutoKickDurationMinutes < 0)
                        {
                            ConsoleError("Duration cannot be negative.");
                            return;
                        }
                        _AFKTriggerDurationMinutes = afkAutoKickDurationMinutes;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"AFK Trigger Minutes", typeof(Double), _AFKTriggerDurationMinutes));
                    }
                }
                else if (Regex.Match(strVariable, @"AFK Minimum Players").Success)
                {
                    Int32 afkAutoKickMinimumPlayers = Int32.Parse(strValue);
                    if (_AFKTriggerMinimumPlayers != afkAutoKickMinimumPlayers)
                    {
                        if (afkAutoKickMinimumPlayers < 0)
                        {
                            ConsoleError("Minimum players cannot be negative.");
                            return;
                        }
                        _AFKTriggerMinimumPlayers = afkAutoKickMinimumPlayers;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"AFK Minimum Players", typeof(Int32), _AFKTriggerMinimumPlayers));
                    }
                }
                else if (Regex.Match(strVariable, @"AFK Ignore User List").Success)
                {
                    Boolean afkIgnoreUserList = Boolean.Parse(strValue);
                    if (afkIgnoreUserList != _AFKIgnoreUserList)
                    {
                        _AFKIgnoreUserList = afkIgnoreUserList;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"AFK Ignore User List", typeof(Boolean), _AFKIgnoreUserList));
                    }
                }
                else if (Regex.Match(strVariable, @"AFK Ignore Roles").Success)
                {
                    _AFKIgnoreRoles = CPluginVariable.DecodeStringArray(strValue);
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"AFK Ignore Roles", typeof(String), CPluginVariable.EncodeStringArray(_AFKIgnoreRoles)));
                }
                else if (Regex.Match(strVariable, @"Ping Enforcer Enable").Success)
                {
                    Boolean PingSystemEnable = Boolean.Parse(strValue);
                    if (PingSystemEnable != _pingEnforcerSystemEnable)
                    {
                        _pingEnforcerSystemEnable = PingSystemEnable;
                        //Once setting has been changed, upload the change to database
                        if (_isTestingAuthorized) {
                            _pingEnforcerSystemEnable = true;
                        }
                        if (_pingEnforcerSystemEnable) {
                            //Disable latency manager
                            ExecuteCommand("procon.protected.plugins.enable", "CLatencyManager", "False");
                        }
                        QueueSettingForUpload(new CPluginVariable(@"Ping Enforcer Enable", typeof(Boolean), _pingEnforcerSystemEnable));
                    }
                }
                else if (Regex.Match(strVariable, @"Ping Moving Average Duration sec").Success)
                {
                    Double pingMovingAverageDurationSeconds;
                    if (!Double.TryParse(strValue, out pingMovingAverageDurationSeconds))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_pingMovingAverageDurationSeconds != pingMovingAverageDurationSeconds)
                    {
                        if (pingMovingAverageDurationSeconds < 30)
                        {
                            ConsoleError("Duration cannot be less than 30 seconds.");
                            return;
                        }
                        _pingMovingAverageDurationSeconds = pingMovingAverageDurationSeconds;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ping Moving Average Duration sec", typeof(Double), _pingMovingAverageDurationSeconds));
                    }
                }
                else if (Regex.Match(strVariable, @"Ping Kick Low Population Trigger ms").Success)
                {
                    Double pingEnforcerLowTriggerMS;
                    if (!Double.TryParse(strValue, out pingEnforcerLowTriggerMS))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_pingEnforcerLowTriggerMS != pingEnforcerLowTriggerMS)
                    {
                        if (pingEnforcerLowTriggerMS < 10)
                        {
                            ConsoleError("Trigger ms cannot be less than 10.");
                            return;
                        }
                        _pingEnforcerLowTriggerMS = pingEnforcerLowTriggerMS;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ping Kick Low Population Trigger ms", typeof(Double), _pingEnforcerLowTriggerMS));
                    }
                }
                else if (Regex.Match(strVariable, @"Ping Kick Medium Population Trigger ms").Success)
                {
                    Double pingEnforcerMedTriggerMS;
                    if (!Double.TryParse(strValue, out pingEnforcerMedTriggerMS))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_pingEnforcerMedTriggerMS != pingEnforcerMedTriggerMS)
                    {
                        if (pingEnforcerMedTriggerMS < 10)
                        {
                            ConsoleError("Trigger ms cannot be less than 10.");
                            return;
                        }
                        _pingEnforcerMedTriggerMS = pingEnforcerMedTriggerMS;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ping Kick Medium Population Trigger ms", typeof(Double), _pingEnforcerMedTriggerMS));
                    }
                }
                else if (Regex.Match(strVariable, @"Ping Kick High Population Trigger ms").Success)
                {
                    Double pingEnforcerHighTriggerMS;
                    if (!Double.TryParse(strValue, out pingEnforcerHighTriggerMS))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_pingEnforcerHighTriggerMS != pingEnforcerHighTriggerMS)
                    {
                        if (pingEnforcerHighTriggerMS < 10)
                        {
                            ConsoleError("Trigger ms cannot be less than 10.");
                            return;
                        }
                        _pingEnforcerHighTriggerMS = pingEnforcerHighTriggerMS;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ping Kick High Population Trigger ms", typeof(Double), _pingEnforcerHighTriggerMS));
                    }
                }
                else if (Regex.Match(strVariable, @"Ping Kick Full Population Trigger ms").Success)
                {
                    Double pingEnforcerFullTriggerMS;
                    if (!Double.TryParse(strValue, out pingEnforcerFullTriggerMS))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_pingEnforcerFullTriggerMS != pingEnforcerFullTriggerMS)
                    {
                        if (pingEnforcerFullTriggerMS < 10)
                        {
                            ConsoleError("Trigger ms cannot be less than 10.");
                            return;
                        }
                        _pingEnforcerFullTriggerMS = pingEnforcerFullTriggerMS;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ping Kick Full Population Trigger ms", typeof(Double), _pingEnforcerFullTriggerMS));
                    }
                }
                else if (Regex.Match(strVariable, @"Ping Kick Minimum Players").Success)
                {
                    Int32 pingEnforcerTriggerMinimumPlayers = Int32.Parse(strValue);
                    if (_pingEnforcerTriggerMinimumPlayers != pingEnforcerTriggerMinimumPlayers)
                    {
                        if (pingEnforcerTriggerMinimumPlayers < 0)
                        {
                            ConsoleError("Minimum players cannot be negative.");
                            return;
                        }
                        _pingEnforcerTriggerMinimumPlayers = pingEnforcerTriggerMinimumPlayers;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ping Kick Minimum Players", typeof(Int32), _pingEnforcerTriggerMinimumPlayers));
                    }
                }
                else if (Regex.Match(strVariable, @"Kick Missing Pings").Success)
                {
                    Boolean pingEnforcerKickMissingPings = Boolean.Parse(strValue);
                    if (pingEnforcerKickMissingPings != _pingEnforcerKickMissingPings)
                    {
                        _pingEnforcerKickMissingPings = pingEnforcerKickMissingPings;
                        if (_isTestingAuthorized)
                        {
                            _pingEnforcerKickMissingPings = true;
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Kick Missing Pings", typeof(Boolean), _pingEnforcerKickMissingPings));
                    }
                }
                else if (Regex.Match(strVariable, @"Attempt Manual Ping when Missing").Success)
                {
                    Boolean attemptManualPingWhenMissing = Boolean.Parse(strValue);
                    if (attemptManualPingWhenMissing != _attemptManualPingWhenMissing)
                    {
                        _attemptManualPingWhenMissing = attemptManualPingWhenMissing;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Attempt Manual Ping when Missing", typeof(Boolean), _attemptManualPingWhenMissing));
                    }
                }
                else if (Regex.Match(strVariable, @"Ping Kick Ignore User List").Success)
                {
                    Boolean pingEnforcerIgnoreUserList = Boolean.Parse(strValue);
                    if (pingEnforcerIgnoreUserList != _pingEnforcerIgnoreUserList)
                    {
                        _pingEnforcerIgnoreUserList = pingEnforcerIgnoreUserList;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ping Kick Ignore User List", typeof(Boolean), _pingEnforcerIgnoreUserList));
                    }
                }
                else if (Regex.Match(strVariable, @"Ping Kick Ignore Roles").Success)
                {
                    _pingEnforcerIgnoreRoles = CPluginVariable.DecodeStringArray(strValue);
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"Ping Kick Ignore Roles", typeof(String), CPluginVariable.EncodeStringArray(_pingEnforcerIgnoreRoles)));
                }
                else if (Regex.Match(strVariable, @"Ping Kick Message Prefix").Success)
                {
                    if (strValue != _pingEnforcerMessagePrefix)
                    {
                        _pingEnforcerMessagePrefix = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ping Kick Message Prefix", typeof(String), _pingEnforcerMessagePrefix));
                    }
                }
                else if (Regex.Match(strVariable, @"Commander Manager Enable").Success)
                {
                    Boolean CMDRManagerEnable = Boolean.Parse(strValue);
                    if (CMDRManagerEnable != _CMDRManagerEnable)
                    {
                        if (_gameVersion == GameVersion.BF3 && CMDRManagerEnable)
                        {
                            ConsoleError("Commander manager cannot be enabled in BF3");
                            _CMDRManagerEnable = false;
                        }
                        else
                        {
                            _CMDRManagerEnable = CMDRManagerEnable;
                            //Once setting has been changed, upload the change to database
                            if (_isTestingAuthorized)
                            {
                                _CMDRManagerEnable = true;
                            }
                            QueueSettingForUpload(new CPluginVariable(@"Commander Manager Enable", typeof(Boolean), _CMDRManagerEnable));
                        }
                    }
                }
                else if (Regex.Match(strVariable, @"Minimum Players to Allow Commanders").Success)
                {
                    Int32 CMDRMinimumPlayers = Int32.Parse(strValue);
                    if (_CMDRMinimumPlayers != CMDRMinimumPlayers)
                    {
                        if (CMDRMinimumPlayers < 0)
                        {
                            ConsoleError("Minimum players cannot be negative.");
                            return;
                        }
                        _CMDRMinimumPlayers = CMDRMinimumPlayers;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Minimum Players to Allow Commanders", typeof(Int32), _CMDRMinimumPlayers));
                    }
                }
                else if (Regex.Match(strVariable, @"Surrender Vote Enable").Success)
                {
                    Boolean surrenderVoteEnable = Boolean.Parse(strValue);
                    if (surrenderVoteEnable != _surrenderVoteEnable)
                    {
                        _surrenderVoteEnable = surrenderVoteEnable;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Surrender Vote Enable", typeof(Boolean), _surrenderVoteEnable));
                    }
                }
                else if (Regex.Match(strVariable, @"Percentage Votes Needed for Surrender").Success)
                {
                    Double surrenderVoteMinimumPlayerPercentage;
                    if (!Double.TryParse(strValue, out surrenderVoteMinimumPlayerPercentage))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_surrenderVoteMinimumPlayerPercentage != surrenderVoteMinimumPlayerPercentage)
                    {
                        if (surrenderVoteMinimumPlayerPercentage < 0)
                        {
                            ConsoleError("Minimum player percentage cannot be negative.");
                            return;
                        }
                        if (surrenderVoteMinimumPlayerPercentage > 100)
                        {
                            ConsoleError("Minimum player percentage cannot be greater than 100.");
                            return;
                        }
                        _surrenderVoteMinimumPlayerPercentage = surrenderVoteMinimumPlayerPercentage;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Percentage Votes Needed for Surrender", typeof(Double), _surrenderVoteMinimumPlayerPercentage));
                    }
                }
                else if (Regex.Match(strVariable, @"Minimum Player Count to Enable Surrender").Success)
                {
                    Int32 surrenderVoteMinimumPlayerCount = Int32.Parse(strValue);
                    if (_surrenderVoteMinimumPlayerCount != surrenderVoteMinimumPlayerCount)
                    {
                        if (surrenderVoteMinimumPlayerCount < 0)
                        {
                            ConsoleError("Minimum player count cannot be negative.");
                            return;
                        }
                        _surrenderVoteMinimumPlayerCount = surrenderVoteMinimumPlayerCount;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Minimum Player Count to Enable Surrender", typeof(Int32), _surrenderVoteMinimumPlayerCount));
                    }
                }
                else if (Regex.Match(strVariable, @"Minimum Ticket Gap to Surrender").Success)
                {
                    Int32 surrenderVoteMinimumTicketGap = Int32.Parse(strValue);
                    if (_surrenderVoteMinimumTicketGap != surrenderVoteMinimumTicketGap)
                    {
                        if (surrenderVoteMinimumTicketGap < 0)
                        {
                            ConsoleError("Minimum ticket gap cannot be negative.");
                            return;
                        }
                        _surrenderVoteMinimumTicketGap = surrenderVoteMinimumTicketGap;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Minimum Ticket Gap to Surrender", typeof(Int32), _surrenderVoteMinimumTicketGap));
                    }
                }
                else if (Regex.Match(strVariable, @"Enable Required Ticket Rate Gap to Surrender").Success)
                {
                    Boolean surrenderVoteTicketRateGapEnable = Boolean.Parse(strValue);
                    if (surrenderVoteTicketRateGapEnable != _surrenderVoteTicketRateGapEnable)
                    {
                        _surrenderVoteTicketRateGapEnable = surrenderVoteTicketRateGapEnable;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Enable Required Ticket Rate Gap to Surrender", typeof(Boolean), _surrenderVoteTicketRateGapEnable));
                    }
                }
                else if (Regex.Match(strVariable, @"Minimum Ticket Rate Gap to Surrender").Success)
                {
                    Double surrenderVoteMinimumTicketRateGap;
                    if (!Double.TryParse(strValue, out surrenderVoteMinimumTicketRateGap))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_surrenderVoteMinimumTicketRateGap != surrenderVoteMinimumTicketRateGap)
                    {
                        if (surrenderVoteMinimumTicketRateGap < 0)
                        {
                            ConsoleError("Minimum ticket rate gap cannot be negative.");
                            return;
                        }
                        _surrenderVoteMinimumTicketRateGap = surrenderVoteMinimumTicketRateGap;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Minimum Ticket Rate Gap to Surrender", typeof(Double), _surrenderVoteMinimumTicketRateGap));
                    }
                }
                else if (Regex.Match(strVariable, @"Surrender Vote Timeout Enable").Success)
                {
                    Boolean surrenderVoteTimeoutEnable = Boolean.Parse(strValue);
                    if (surrenderVoteTimeoutEnable != _surrenderVoteTimeoutEnable)
                    {
                        _surrenderVoteTimeoutEnable = surrenderVoteTimeoutEnable;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Surrender Vote Timeout Enable", typeof(Boolean), _surrenderVoteTimeoutEnable));
                    }
                }
                else if (Regex.Match(strVariable, @"Surrender Vote Timeout Minutes").Success)
                {
                    Int32 surrenderVoteTimeoutMinutes = Int32.Parse(strValue);
                    if (_surrenderVoteTimeoutMinutes != surrenderVoteTimeoutMinutes)
                    {
                        if (surrenderVoteTimeoutMinutes < 0)
                        {
                            ConsoleError("Timeout cannot be negative.");
                            return;
                        }
                        _surrenderVoteTimeoutMinutes = surrenderVoteTimeoutMinutes;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Surrender Vote Timeout Minutes", typeof(Int32), _surrenderVoteTimeoutMinutes));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Enable").Success)
                {
                    Boolean surrenderAutoEnable = Boolean.Parse(strValue);
                    if (surrenderAutoEnable != _surrenderAutoEnable)
                    {
                        _surrenderAutoEnable = surrenderAutoEnable;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Enable", typeof(Boolean), _surrenderAutoEnable));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Use Optimal Values for Metro").Success)
                {
                    Boolean surrenderAutoUseMetroValues = Boolean.Parse(strValue);
                    if (surrenderAutoUseMetroValues != _surrenderAutoUseMetroValues)
                    {
                        _surrenderAutoUseMetroValues = surrenderAutoUseMetroValues;
                        if (_surrenderAutoUseMetroValues)
                        {
                            _surrenderAutoUseLockerValues = false;
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Use Optimal Values for Metro Conquest", typeof(Boolean), _surrenderAutoUseMetroValues));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Use Optimal Values for Locker").Success)
                {
                    Boolean surrenderAutoUseLockerValues = Boolean.Parse(strValue);
                    if (surrenderAutoUseLockerValues != _surrenderAutoUseLockerValues)
                    {
                        _surrenderAutoUseLockerValues = surrenderAutoUseLockerValues;
                        if (_surrenderAutoUseLockerValues)
                        {
                            _surrenderAutoUseMetroValues = false;
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Use Optimal Values for Locker Conquest", typeof(Boolean), _surrenderAutoUseLockerValues));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Use Adjusted Ticket Rates").Success)
                {
                    Boolean surrenderAutoUseAdjustedTicketRates = Boolean.Parse(strValue);
                    if (surrenderAutoUseAdjustedTicketRates != _surrenderAutoUseAdjustedTicketRates)
                    {
                        _surrenderAutoUseAdjustedTicketRates = surrenderAutoUseAdjustedTicketRates;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Use Adjusted Ticket Rates", typeof(Boolean), _surrenderAutoUseAdjustedTicketRates));
                    }
                }
                else if (Regex.Match(strVariable, @"Nuke Winning Team Instead of Surrendering Losing Team").Success)
                {
                    Boolean surrenderAutoNukeWinning = Boolean.Parse(strValue);
                    if (surrenderAutoNukeWinning != _surrenderAutoNukeWinning)
                    {
                        _surrenderAutoNukeWinning = surrenderAutoNukeWinning;
                        if (_surrenderAutoNukeWinning)
                        {
                            _surrenderAutoTriggerVote = false;
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Nuke Winning Team Instead of Surrendering Losing Team", typeof(Boolean), _surrenderAutoNukeWinning));
                    }
                }
                else if (Regex.Match(strVariable, @"Start Surrender Vote Instead of Surrendering Losing Team").Success)
                {
                    Boolean surrenderAutoTriggerVote = Boolean.Parse(strValue);
                    if (surrenderAutoTriggerVote != _surrenderAutoTriggerVote)
                    {
                        _surrenderAutoTriggerVote = surrenderAutoTriggerVote;
                        if (surrenderAutoTriggerVote) 
                        {
                            _surrenderAutoNukeWinning = false;
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Start Surrender Vote Instead of Surrendering Losing Team", typeof(Boolean), _surrenderAutoTriggerVote));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Minimum Ticket Gap").Success)
                {
                    Int32 surrenderAutoMinimumTicketGap = Int32.Parse(strValue);
                    if (_surrenderAutoMinimumTicketGap != surrenderAutoMinimumTicketGap)
                    {
                        _surrenderAutoMinimumTicketGap = surrenderAutoMinimumTicketGap;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Minimum Ticket Gap", typeof(Int32), _surrenderAutoMinimumTicketGap));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Losing Team Rate Window Max").Success)
                {
                    Double surrenderAutoLosingRateMax;
                    if (!Double.TryParse(strValue, out surrenderAutoLosingRateMax))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_surrenderAutoLosingRateMax != surrenderAutoLosingRateMax)
                    {
                        _surrenderAutoLosingRateMax = surrenderAutoLosingRateMax;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Losing Team Rate Window Max", typeof(Double), _surrenderAutoLosingRateMax));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Losing Team Rate Window Min").Success)
                {
                    Double surrenderAutoLosingRateMin;
                    if (!Double.TryParse(strValue, out surrenderAutoLosingRateMin))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_surrenderAutoLosingRateMin != surrenderAutoLosingRateMin)
                    {
                        _surrenderAutoLosingRateMin = surrenderAutoLosingRateMin;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Losing Team Rate Window Min", typeof(Double), _surrenderAutoLosingRateMin));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Winning Team Rate Window Max").Success)
                {
                    Double surrenderAutoWinningRateMax;
                    if (!Double.TryParse(strValue, out surrenderAutoWinningRateMax))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_surrenderAutoWinningRateMax != surrenderAutoWinningRateMax)
                    {
                        _surrenderAutoWinningRateMax = surrenderAutoWinningRateMax;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Winning Team Rate Window Max", typeof(Double), _surrenderAutoWinningRateMax));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Winning Team Rate Window Min").Success)
                {
                    Double surrenderAutoWinningRateMin;
                    if (!Double.TryParse(strValue, out surrenderAutoWinningRateMin))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_surrenderAutoWinningRateMin != surrenderAutoWinningRateMin)
                    {
                        _surrenderAutoWinningRateMin = surrenderAutoWinningRateMin;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Winning Team Rate Window Min", typeof(Double), _surrenderAutoWinningRateMin));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Message").Success)
                {
                    if (strValue != _surrenderAutoMessage)
                    {
                        _surrenderAutoMessage = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Message", typeof(String), _surrenderAutoMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Nuke Message").Success)
                {
                    if (strValue != _surrenderAutoNukeMessage)
                    {
                        _surrenderAutoNukeMessage = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Nuke Message", typeof(String), _surrenderAutoNukeMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Trigger Count to Surrender").Success)
                {
                    Int32 surrenderAutoTriggerCountToSurrender = Int32.Parse(strValue);
                    if (_surrenderAutoTriggerCountToSurrender != surrenderAutoTriggerCountToSurrender)
                    {
                        _surrenderAutoTriggerCountToSurrender = surrenderAutoTriggerCountToSurrender;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Trigger Count to Surrender", typeof(Int32), _surrenderAutoTriggerCountToSurrender));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Surrender Minimum Players").Success)
                {
                    Int32 surrenderAutoMinimumPlayers = Int32.Parse(strValue);
                    if (_surrenderAutoMinimumPlayers != surrenderAutoMinimumPlayers)
                    {
                        if (surrenderAutoMinimumPlayers < 0)
                        {
                            ConsoleError("Minimum player count cannot be negative.");
                            surrenderAutoMinimumPlayers = 0;
                        }
                        _surrenderAutoMinimumPlayers = surrenderAutoMinimumPlayers;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Minimum Players", typeof(Int32), _surrenderAutoMinimumPlayers));
                    }
                }
                else if (Regex.Match(strVariable, @"Player Lock Manual Duration Minutes").Success)
                {
                    Double playerLockingManualDuration;
                    if (!Double.TryParse(strValue, out playerLockingManualDuration))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_playerLockingManualDuration != playerLockingManualDuration)
                    {
                        if (playerLockingManualDuration < 0)
                        {
                            ConsoleError("Duration cannot be negative.");
                            return;
                        }
                        _playerLockingManualDuration = playerLockingManualDuration;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Player Lock Manual Duration Minutes", typeof(Double), _playerLockingManualDuration));
                    }
                }
                else if (Regex.Match(strVariable, @"Automatically Lock Players on Admin Action").Success)
                {
                    Boolean playerLockingAutomaticLock = Boolean.Parse(strValue);
                    if (playerLockingAutomaticLock != _playerLockingAutomaticLock)
                    {
                        _playerLockingAutomaticLock = playerLockingAutomaticLock;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Automatically Lock Players on Admin Action", typeof(Boolean), _playerLockingAutomaticLock));
                    }
                }
                else if (Regex.Match(strVariable, @"Player Lock Automatic Duration Minutes").Success)
                {
                    Double playerLockingAutomaticDuration;
                    if (!Double.TryParse(strValue, out playerLockingAutomaticDuration))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_playerLockingAutomaticDuration != playerLockingAutomaticDuration)
                    {
                        if (playerLockingAutomaticDuration < 0)
                        {
                            ConsoleError("Duration cannot be negative.");
                            return;
                        }
                        _playerLockingAutomaticDuration = playerLockingAutomaticDuration;
                        //Once setting has been changed, upload the change to database  
                        QueueSettingForUpload(new CPluginVariable(@"Player Lock Automatic Duration Minutes", typeof(Double), _playerLockingAutomaticDuration));
                    }
                }
                else if (Regex.Match(strVariable, @"Feed MULTIBalancer Whitelist").Success) {
                    Boolean feedMTBWhite = Boolean.Parse(strValue);
                    if (feedMTBWhite != _FeedMultiBalancerWhitelist) {
                        _FeedMultiBalancerWhitelist = feedMTBWhite;
                        FetchAllAccess(true);
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Feed MULTIBalancer Whitelist", typeof (Boolean), _FeedMultiBalancerWhitelist));
                    }
                }
                else if (Regex.Match(strVariable, @"Automatic MULTIBalancer Whitelist for Admins").Success) {
                    Boolean feedMTBWhiteUser = Boolean.Parse(strValue);
                    if (feedMTBWhiteUser != _FeedMultiBalancerWhitelist_Admins) {
                        _FeedMultiBalancerWhitelist_Admins = feedMTBWhiteUser;
                        FetchAllAccess(true);
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Automatic MULTIBalancer Whitelist for Admins", typeof (Boolean), _FeedMultiBalancerWhitelist_Admins));
                    }
                }
                else if (Regex.Match(strVariable, @"Feed MULTIBalancer Even Dispersion List").Success) {
                    Boolean feedMTBBlack = Boolean.Parse(strValue);
                    if (feedMTBBlack != _FeedMultiBalancerDisperseList) {
                        _FeedMultiBalancerDisperseList = feedMTBBlack;
                        FetchAllAccess(true);
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Feed MULTIBalancer Even Dispersion List", typeof (Boolean), _FeedMultiBalancerDisperseList));
                    }
                }
                else if (Regex.Match(strVariable, @"Feed Server Reserved Slots").Success) {
                    Boolean feedSRS = Boolean.Parse(strValue);
                    if (feedSRS != _FeedServerReservedSlots) {
                        _FeedServerReservedSlots = feedSRS;
                        FetchAllAccess(true);
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Feed Server Reserved Slots", typeof (Boolean), _FeedServerReservedSlots));
                    }
                }
                else if (Regex.Match(strVariable, @"Automatic Reserved Slot for Admins").Success) {
                    Boolean feedSRSUser = Boolean.Parse(strValue);
                    if (feedSRSUser != _FeedServerReservedSlots_Admins) {
                        _FeedServerReservedSlots_Admins = feedSRSUser;
                        FetchAllAccess(true);
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Automatic Reserved Slot for Admins", typeof (Boolean), _FeedServerReservedSlots_Admins));
                    }
                }
                else if (Regex.Match(strVariable, @"Feed Server Spectator List").Success) {
                    Boolean feedSSL = Boolean.Parse(strValue);
                    if (feedSSL != _FeedServerSpectatorList) {
                        if (_gameVersion != GameVersion.BF4) {
                            ConsoleError("This feature can only be enabled on BF4 servers.");
                            return;
                        }
                        _FeedServerSpectatorList = feedSSL;
                        FetchAllAccess(true);
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Feed Server Spectator List", typeof (Boolean), _FeedServerSpectatorList));
                    }
                }
                else if (Regex.Match(strVariable, @"Automatic Spectator Slot for Admins").Success) {
                    Boolean feedSSLUser = Boolean.Parse(strValue);
                    if (feedSSLUser != _FeedServerSpectatorList_Admins) {
                        _FeedServerSpectatorList_Admins = feedSSLUser;
                        FetchAllAccess(true);
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Automatic Spectator Slot for Admins", typeof (Boolean), _FeedServerSpectatorList_Admins));
                    }
                }
                else if (Regex.Match(strVariable, @"Feed Stat Logger Settings").Success)
                {
                    Boolean feedSLS = Boolean.Parse(strValue);
                    if (feedSLS != _FeedStatLoggerSettings)
                    {
                        _FeedStatLoggerSettings = feedSLS;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Feed Stat Logger Settings", typeof(Boolean), _FeedStatLoggerSettings));
                    }
                }
                else if (Regex.Match(strVariable, @"Post Stat Logger Chat Manually").Success)
                {
                    Boolean PostStatLoggerChatManually = Boolean.Parse(strValue);
                    if (PostStatLoggerChatManually != _PostStatLoggerChatManually)
                    {
                        _PostStatLoggerChatManually = PostStatLoggerChatManually;
                        if (_PostStatLoggerChatManually)
                        {
                            SetExternalPluginSetting("CChatGUIDStatsLogger", "Enable Chatlogging?", "No");
                            SetExternalPluginSetting("CChatGUIDStatsLogger", "Instant Logging of Chat Messages?", "No");
                            SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Enable Chatlogging?", "No");
                            SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Instant Logging of Chat Messages?", "No");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Post Stat Logger Chat Manually", typeof(Boolean), _PostStatLoggerChatManually));
                    }
                }
                else if (Regex.Match(strVariable, @"Post Server Chat Spam").Success)
                {
                    Boolean PostServerChatSpam = Boolean.Parse(strValue);
                    if (PostServerChatSpam != _PostStatLoggerChatManually_PostServerChatSpam)
                    {
                        _PostStatLoggerChatManually_PostServerChatSpam = PostServerChatSpam;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Post Server Chat Spam", typeof(Boolean), _PostStatLoggerChatManually_PostServerChatSpam));
                    }
                }
                else if (Regex.Match(strVariable, @"Exclude Commands from Chat Logs").Success)
                {
                    Boolean PostStatLoggerChatManually_IgnoreCommands = Boolean.Parse(strValue);
                    if (PostStatLoggerChatManually_IgnoreCommands != _PostStatLoggerChatManually_IgnoreCommands)
                    {
                        _PostStatLoggerChatManually_IgnoreCommands = PostStatLoggerChatManually_IgnoreCommands;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Exclude Commands from Chat Logs", typeof(Boolean), _PostStatLoggerChatManually_IgnoreCommands));
                    }
                }
                else if (Regex.Match(strVariable, @"Post Map Benefit/Detriment Statistics").Success)
                {
                    Boolean PostMapBenefitStatistics = Boolean.Parse(strValue);
                    if (PostMapBenefitStatistics != _PostMapBenefitStatistics)
                    {
                        _PostMapBenefitStatistics = PostMapBenefitStatistics;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Post Map Benefit/Detriment Statistics", typeof(Boolean), _PostMapBenefitStatistics));
                    }
                }
                else if (Regex.Match(strVariable, @"Use Experimental Tools").Success) {
                    Boolean useEXP = Boolean.Parse(strValue);
                    if (useEXP != _useExperimentalTools) {
                        _useExperimentalTools = useEXP;
                        if (_useExperimentalTools) {
                            if (_threadsReady) {
                                ConsoleWarn("Using experimental tools. Take caution.");
                            }
                        }
                        else {
                            ConsoleInfo("Experimental tools disabled.");
                            _UseWeaponLimiter = false;
                            _UseGrenadeCookCatcher = false;
                            _UseHackerChecker = false;
                            _UseDpsChecker = false;
                            _UseHskChecker = false;
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Use Experimental Tools", typeof (Boolean), _useExperimentalTools));
                        QueueSettingForUpload(new CPluginVariable(@"Use NO EXPLOSIVES Limiter", typeof (Boolean), _UseWeaponLimiter));
                    }
                }
                else if (Regex.Match(strVariable, @"Round Timer: Enable").Success) {
                    Boolean useTimer = Boolean.Parse(strValue);
                    if (useTimer != _useRoundTimer) {
                        _useRoundTimer = useTimer;
                        if (_useRoundTimer) {
                            if (_threadsReady) {
                                ConsoleInfo("Internal Round Timer activated, will enable on next round.");
                            }
                        }
                        else {
                            ConsoleInfo("Internal Round Timer disabled.");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Round Timer: Enable", typeof (Boolean), _useRoundTimer));
                    }
                }
                else if (Regex.Match(strVariable, @"Round Timer: Round Duration Minutes").Success) {
                    Double duration;
                    if (!Double.TryParse(strValue, out duration))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_maxRoundTimeMinutes != duration) {
                        if (duration <= 0) {
                            duration = 30.0;
                        }
                        _maxRoundTimeMinutes = duration;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Round Timer: Round Duration Minutes", typeof (Double), _maxRoundTimeMinutes));
                    }
                }
                else if (Regex.Match(strVariable, @"Use NO EXPLOSIVES Limiter").Success) {
                    Boolean useLimiter = Boolean.Parse(strValue);
                    if (useLimiter != _UseWeaponLimiter) {
                        _UseWeaponLimiter = useLimiter;
                        if (_UseWeaponLimiter) {
                            if (_threadsReady) {
                                ConsoleInfo("Internal NO EXPLOSIVES punish limit activated.");
                            }
                        }
                        else {
                            ConsoleInfo("Internal NO EXPLOSIVES punish limit disabled.");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Use NO EXPLOSIVES Limiter", typeof (Boolean), _UseWeaponLimiter));
                    }
                }
                else if (Regex.Match(strVariable, @"NO EXPLOSIVES Weapon String").Success) {
                    if (_WeaponLimiterString != strValue) {
                        if (!String.IsNullOrEmpty(strValue)) {
                            _WeaponLimiterString = strValue;
                        }
                        else {
                            ConsoleError("Weapon String cannot be empty.");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"NO EXPLOSIVES Weapon String", typeof (String), _WeaponLimiterString));
                    }
                }
                else if (Regex.Match(strVariable, @"NO EXPLOSIVES Exception String").Success) {
                    if (_WeaponLimiterExceptionString != strValue) {
                        if (!String.IsNullOrEmpty(strValue)) {
                            _WeaponLimiterExceptionString = strValue;
                        }
                        else {
                            ConsoleError("Weapon exception String cannot be empty.");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"NO EXPLOSIVES Exception String", typeof (String), _WeaponLimiterExceptionString));
                    }
                }
                else if (Regex.Match(strVariable, @"Use Grenade Cook Catcher").Success) {
                    Boolean useCookCatcher = Boolean.Parse(strValue);
                    if (useCookCatcher != _UseGrenadeCookCatcher) {
                        _UseGrenadeCookCatcher = useCookCatcher;
                        if (_UseGrenadeCookCatcher) {
                            if (_threadsReady) {
                                ConsoleInfo("Internal Grenade Cook Catcher activated.");
                            }
                        }
                        else {
                            ConsoleInfo("Internal Grenade Cook Catcher disabled.");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Use Grenade Cook Catcher", typeof (Boolean), _UseGrenadeCookCatcher));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: Enable").Success) {
                    Boolean useHackChecker = Boolean.Parse(strValue);
                    if (useHackChecker != _UseHackerChecker) {
                        _UseHackerChecker = useHackChecker;
                        if (_UseHackerChecker) {
                            if (_threadsReady) {
                                ConsoleInfo("Internal Hacker Checker activated.");
                            }
                        }
                        else {
                            ConsoleInfo("Internal Hacker Checker disabled.");
                            _UseDpsChecker = false;
                            QueueSettingForUpload(new CPluginVariable(@"HackerChecker: DPS Checker: Enable", typeof (Boolean), _UseDpsChecker));
                            _UseHskChecker = false;
                            QueueSettingForUpload(new CPluginVariable(@"HackerChecker: HSK Checker: Enable", typeof (Boolean), _UseHskChecker));
                            _UseKpmChecker = false;
                            QueueSettingForUpload(new CPluginVariable(@"HackerChecker: KPM Checker: Enable", typeof (Boolean), _UseKpmChecker));
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: Enable", typeof (Boolean), _UseHackerChecker));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: Whitelist").Success) {
                    //_HackerCheckerWhitelist = CPluginVariable.DecodeStringArray(strValue);
                    //Once setting has been changed, upload the change to database
                    //QueueSettingForUpload(new CPluginVariable(@"HackerChecker: Whitelist", typeof (String), CPluginVariable.EncodeStringArray(_HackerCheckerWhitelist)));
                }
                else if (Regex.Match(strVariable, @"HackerChecker: DPS Checker: Enable").Success) {
                    Boolean useDamageChecker = Boolean.Parse(strValue);
                    if (useDamageChecker != _UseDpsChecker) {
                        _UseDpsChecker = useDamageChecker;
                        if (_UseDpsChecker) {
                            if (_threadsReady) {
                                ConsoleInfo("Internal Damage Mod Checker activated.");
                            }
                        }
                        else {
                            ConsoleInfo("Internal Damage Mod Checker disabled.");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: DPS Checker: Enable", typeof (Boolean), _UseDpsChecker));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: DPS Checker: Trigger Level").Success) {
                    Double triggerLevel;
                    if (!Double.TryParse(strValue, out triggerLevel))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_DpsTriggerLevel != triggerLevel) {
                        if (triggerLevel <= 0) {
                            triggerLevel = 100.0;
                        }
                        _DpsTriggerLevel = triggerLevel;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: DPS Checker: Trigger Level", typeof (Double), _DpsTriggerLevel));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: DPS Checker: Ban Message").Success) {
                    if (_HackerCheckerDPSBanMessage != strValue) {
                        _HackerCheckerDPSBanMessage = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: DPS Checker: Ban Message", typeof (String), _HackerCheckerDPSBanMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: HSK Checker: Enable").Success) {
                    Boolean useAimbotChecker = Boolean.Parse(strValue);
                    if (useAimbotChecker != _UseHskChecker) {
                        _UseHskChecker = useAimbotChecker;
                        if (_UseHskChecker) {
                            if (_threadsReady) {
                                ConsoleInfo("Internal Aimbot Checker activated.");
                            }
                        }
                        else {
                            ConsoleInfo("Internal Aimbot Checker disabled.");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: HSK Checker: Enable", typeof (Boolean), _UseHskChecker));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: HSK Checker: Trigger Level").Success) {
                    Double triggerLevel;
                    if (!Double.TryParse(strValue, out triggerLevel))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_HskTriggerLevel != triggerLevel) {
                        if (triggerLevel <= 0) {
                            triggerLevel = 100.0;
                        }
                        _HskTriggerLevel = triggerLevel;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: HSK Checker: Trigger Level", typeof (Double), _HskTriggerLevel));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: HSK Checker: Ban Message").Success) {
                    if (_HackerCheckerHSKBanMessage != strValue) {
                        _HackerCheckerHSKBanMessage = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: HSK Checker: Ban Message", typeof (String), _HackerCheckerHSKBanMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: KPM Checker: Enable").Success) {
                    Boolean useKPMChecker = Boolean.Parse(strValue);
                    if (useKPMChecker != _UseKpmChecker) {
                        _UseKpmChecker = useKPMChecker;
                        if (_UseKpmChecker) {
                            if (_threadsReady) {
                                ConsoleInfo("Internal KPM Checker activated.");
                            }
                        }
                        else {
                            ConsoleInfo("Internal KPM Checker disabled.");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: KPM Checker: Enable", typeof (Boolean), _UseKpmChecker));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: KPM Checker: Trigger Level").Success) {
                    Double triggerLevel;
                    if (!Double.TryParse(strValue, out triggerLevel))
                    {
                        HandleException(new AdKatsException("Error parsing double value for setting '" + strVariable + "'"));
                        return;
                    }
                    if (_KpmTriggerLevel != triggerLevel) {
                        if (triggerLevel <= 0) {
                            triggerLevel = 100.0;
                        }
                        _KpmTriggerLevel = triggerLevel;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: KPM Checker: Trigger Level", typeof (Double), _KpmTriggerLevel));
                    }
                }
                else if (Regex.Match(strVariable, @"HackerChecker: KPM Checker: Ban Message").Success) {
                    if (_HackerCheckerKPMBanMessage != strValue) {
                        _HackerCheckerKPMBanMessage = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"HackerChecker: KPM Checker: Ban Message", typeof (String), _HackerCheckerKPMBanMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"Fetch Actions from Database").Success)
                {
                    Boolean fetch = Boolean.Parse(strValue);
                    if (fetch != _fetchActionsFromDb)
                    {
                        _fetchActionsFromDb = fetch;
                        _DbCommunicationWaitHandle.Set();
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Fetch Actions from Database", typeof(Boolean), _fetchActionsFromDb));
                    }
                }
                else if (Regex.Match(strVariable, @"AdkatsLRT Extension Token").Success)
                {
                    if (_AdKatsLRTExtensionToken != strValue)
                    {
                        _AdKatsLRTExtensionToken = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"AdkatsLRT Extension Token", typeof(String), _AdKatsLRTExtensionToken));
                        CheckForPluginUpdates(true);
                    }
                }
                else if (Regex.Match(strVariable, @"Use Additional Ban Message").Success) {
                    Boolean use = Boolean.Parse(strValue);
                    if (_UseBanAppend != use) {
                        _UseBanAppend = use;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Use Additional Ban Message", typeof (Boolean), _UseBanAppend));
                    }
                }
                else if (Regex.Match(strVariable, @"Additional Ban Message").Success) {
                    if (strValue.Length > 30) {
                        strValue = strValue.Substring(0, 30);
                        ConsoleError("Ban append cannot be more than 30 characters.");
                    }
                    if (_BanAppend != strValue) {
                        _BanAppend = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Additional Ban Message", typeof (String), _BanAppend));
                    }
                }
                else if (Regex.Match(strVariable, @"Procon Ban Admin Name").Success) {
                    if (strValue.Length > 16) {
                        strValue = strValue.Substring(0, 16);
                        ConsoleError("Procon ban admin id cannot be more than 16 characters.");
                    }
                    if (_CBanAdminName != strValue) {
                        _CBanAdminName = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Procon Ban Admin Name", typeof (String), _CBanAdminName));
                    }
                }
                else if (Regex.Match(strVariable, @"Use Ban Enforcer").Success) {
                    Boolean use = Boolean.Parse(strValue);
                    if (_UseBanEnforcer != use) {
                        _UseBanEnforcer = use;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Use Ban Enforcer", typeof (Boolean), _UseBanEnforcer));
                        if (_UseBanEnforcer) {
                            _fetchActionsFromDb = true;
                            _DbCommunicationWaitHandle.Set();
                        }
                    }
                }
                else if (Regex.Match(strVariable, @"Enforce New Bans by NAME").Success) {
                    Boolean enforceName = Boolean.Parse(strValue);
                    if (_DefaultEnforceName != enforceName) {
                        _DefaultEnforceName = enforceName;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Enforce New Bans by NAME", typeof (Boolean), _DefaultEnforceName));
                    }
                }
                else if (Regex.Match(strVariable, @"Enforce New Bans by GUID").Success) {
                    Boolean enforceGUID = Boolean.Parse(strValue);
                    if (_DefaultEnforceGUID != enforceGUID) {
                        _DefaultEnforceGUID = enforceGUID;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Enforce New Bans by GUID", typeof (Boolean), _DefaultEnforceGUID));
                    }
                }
                else if (Regex.Match(strVariable, @"Enforce New Bans by IP").Success) {
                    Boolean enforceIP = Boolean.Parse(strValue);
                    if (_DefaultEnforceIP != enforceIP) {
                        _DefaultEnforceIP = enforceIP;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Enforce New Bans by IP", typeof (Boolean), _DefaultEnforceIP));
                    }
                }
                else if (Regex.Match(strVariable, @"Ban Search").Success)
                {
                    if (String.IsNullOrEmpty(strValue) || strValue.Length < 3)
                    {
                        ConsoleError("Search query must be 3 or more characters.");
                        return;
                    }
                    lock (_BanEnforcerSearchResults)
                    {
                        _BanEnforcerSearchResults = FetchMatchingBans(strValue, 5); 
                        if (_BanEnforcerSearchResults.Count == 0)
                        {
                            ConsoleError("No players matching '" + strValue + "' have active bans.");
                        }
                    }
                }
                else if (Regex.Match(strVariable, @"Minimum Required Reason Length").Success) {
                    Int32 required = Int32.Parse(strValue);
                    if (_RequiredReasonLength != required) {
                        _RequiredReasonLength = required;
                        if (_RequiredReasonLength < 1) {
                            _RequiredReasonLength = 1;
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Minimum Required Reason Length", typeof (Int32), _RequiredReasonLength));
                    }
                }
                else if (Regex.Match(strVariable, @"Minimum Report Handle Seconds").Success) {
                    Int32 minimumReportHandleSeconds = Int32.Parse(strValue);
                    if (_MinimumReportHandleSeconds != minimumReportHandleSeconds) {
                        _MinimumReportHandleSeconds = minimumReportHandleSeconds;
                        if (_MinimumReportHandleSeconds < 0) {
                            _MinimumReportHandleSeconds = 0;
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Minimum Report Handle Seconds", typeof (Int32), _MinimumReportHandleSeconds));
                    }
                }
                else if (Regex.Match(strVariable, @"Allow Commands from Admin Say").Success)
                {
                    Boolean allowSayCommands = Boolean.Parse(strValue);
                    if (_AllowAdminSayCommands != allowSayCommands)
                    {
                        _AllowAdminSayCommands = allowSayCommands;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Allow Commands from Admin Say", typeof(Boolean), _AllowAdminSayCommands));
                    }
                }
                else if (Regex.Match(strVariable, @"Bypass all command confirmation -DO NOT USE-").Success)
                {
                    Boolean bypassAllConfirmation = Boolean.Parse(strValue);
                    if (_bypassCommandConfirmation != bypassAllConfirmation)
                    {
                        _bypassCommandConfirmation = bypassAllConfirmation;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Bypass all command confirmation -DO NOT USE-", typeof(Boolean), _bypassCommandConfirmation));
                    }
                }
                else if (Regex.Match(strVariable, @"External plugin player commands").Success)
                {
                    _ExternalPlayerCommands = new List<String>(CPluginVariable.DecodeStringArray(strValue));
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"External plugin player commands", typeof(String), CPluginVariable.EncodeStringArray(_ExternalPlayerCommands.ToArray())));
                }
                else if (Regex.Match(strVariable, @"External plugin admin commands").Success)
                {
                    _ExternalAdminCommands = new List<String>(CPluginVariable.DecodeStringArray(strValue));
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"External plugin admin commands", typeof(String), CPluginVariable.EncodeStringArray(_ExternalAdminCommands.ToArray())));
                }
                else if (strVariable.StartsWith("USR")) {
                    //USR1 | ColColonCleaner | User Email
                    //USR1 | ColColonCleaner | User Phone
                    //USR1 | ColColonCleaner | User Role
                    //USR1 | ColColonCleaner | Delete User?
                    //USR1 | ColColonCleaner | Add Soldier?
                    //USR1 | ColColonCleaner | Soldiers | 293492 | ColColonCleaner | Delete Soldier?

                    String[] commandSplit = CPluginVariable.DecodeStringArray(strVariable);
                    String user_id_str = commandSplit[0].TrimStart("USR".ToCharArray()).Trim();
                    Int32 user_id = Int32.Parse(user_id_str);
                    String section = commandSplit[2].Trim();

                    AdKatsUser aUser = null;
                    if (_userCache.TryGetValue(user_id, out aUser)) {
                        switch (section) {
                            case "User Email":
                                if (String.IsNullOrEmpty(strValue) || Regex.IsMatch(strValue, @"^([\w-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([\w-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$")) {
                                    aUser.user_email = strValue;
                                    //Reupload the user
                                    QueueUserForUpload(aUser);
                                }
                                else {
                                    ConsoleError(strValue + " is an invalid email address.");
                                    return;
                                }
                                break;
                            case "User Expiration":
                                DateTime newExpiration;
                                if (DateTime.TryParse(strValue, out newExpiration)) {
                                    aUser.user_expiration = newExpiration;
                                    //Reupload the user
                                    QueueUserForUpload(aUser);
                                }
                                else
                                {
                                    ConsoleError(strValue + " is an invalid date.");
                                }
                                break;
                            case "User Notes":
                                if (String.IsNullOrEmpty(strValue)) {
                                    ConsoleError("User notes cannot be blank.");
                                    return;
                                }
                                aUser.user_notes = strValue;
                                //Reupload the user
                                QueueUserForUpload(aUser);
                                break;
                            case "User Phone":
                                aUser.user_phone = strValue;
                                //Reupload the user
                                QueueUserForUpload(aUser);
                                break;
                            case "User Role":
                                AdKatsRole aRole = null;
                                if (_RoleNameDictionary.TryGetValue(strValue, out aRole)) {
                                    aUser.user_role = aRole;
                                }
                                else {
                                    ConsoleError("Role " + strValue + " not found.");
                                    return;
                                }
                                //Reupload the user
                                QueueUserForUpload(aUser);
                                break;
                            case "Delete User?":
                                if (strValue.ToLower() == "delete") {
                                    QueueUserForRemoval(aUser);
                                }
                                break;
                            case "Add Soldier?":
                                var addSoldierThread = new Thread(new ThreadStart(delegate {
                                    Thread.CurrentThread.Name = "addsoldier";
                                    DebugWrite("Starting a user change thread.", 2);
                                    TryAddUserSoldier(aUser, strValue);
                                    QueueUserForUpload(aUser);
                                    DebugWrite("Exiting a user change thread.", 2);
                                    LogThreadExit();
                                }));
                                StartAndLogThread(addSoldierThread);
                                break;
                            case "Soldiers":
                                if (strVariable.Contains("Delete Soldier?") && strValue.ToLower() == "delete") {
                                    String player_id_str = commandSplit[3].Trim();
                                    Int64 player_id = Int64.Parse(player_id_str);
                                    aUser.soldierDictionary.Remove(player_id);
                                    //Reupload the user
                                    QueueUserForUpload(aUser);
                                }
                                break;
                            default:
                                ConsoleError("Section " + section + " not found.");
                                break;
                        }
                    }
                }
                else if (strVariable.StartsWith("CDE")) {
                    //Trim off all but the command ID and section
                    //5. Command List|CDE1 | Kill Player | Active
                    //5. Command List|CDE1 | Kill Player | Logging
                    //5. Command List|CDE1 | Kill Player | Text

                    String[] commandSplit = CPluginVariable.DecodeStringArray(strVariable);
                    String command_id_str = commandSplit[0].TrimStart("CDE".ToCharArray()).Trim();
                    Int32 command_id = Int32.Parse(command_id_str);
                    String section = commandSplit[2].Trim();

                    AdKatsCommand command = null;
                    if (_CommandIDDictionary.TryGetValue(command_id, out command)) {
                        if (section == "Active") {
                            //Check for valid value
                            if (strValue == "Active") {
                                command.command_active = AdKatsCommand.CommandActive.Active;
                            }
                            else if (strValue == "Disabled") {
                                command.command_active = AdKatsCommand.CommandActive.Disabled;
                            }
                            else if (strValue == "Invisible") {
                                command.command_active = AdKatsCommand.CommandActive.Invisible;
                            }
                            else {
                                ConsoleError("Activity setting " + strValue + " was invalid.");
                                return;
                            }
                        }
                        else if (section == "Logging") {
                            //Check for valid value
                            switch (strValue) {
                                case "Log":
                                    command.command_logging = AdKatsCommand.CommandLogging.Log;
                                    break;
                                case "Mandatory":
                                    command.command_logging = AdKatsCommand.CommandLogging.Mandatory;
                                    break;
                                case "Ignore":
                                    command.command_logging = AdKatsCommand.CommandLogging.Ignore;
                                    break;
                                case "Unable":
                                    command.command_logging = AdKatsCommand.CommandLogging.Unable;
                                    break;
                                default:
                                    ConsoleError("Logging setting " + strValue + " was invalid.");
                                    return;
                            }
                        }
                        else if (section == "Text") {
                            if (String.IsNullOrEmpty(strValue)) {
                                ConsoleError("Command text cannot be blank.");
                                return;
                            }
                            //Make sure command text only contains alphanumeric chars, underscores, and dashes
                            var rgx = new Regex("[^a-zA-Z0-9_-]");
                            strValue = rgx.Replace(strValue, "").ToLower();
                            //Check to make sure text is not a duplicate
                            foreach (AdKatsCommand testCommand in _CommandNameDictionary.Values.ToList()) {
                                if (testCommand.command_text == strValue) {
                                    ConsoleError("Command text cannot be the same as another command.");
                                    return;
                                }
                            }
                            //Assign the command text
                            lock (_CommandTextDictionary) {
                                _CommandTextDictionary.Remove(command.command_text);
                                command.command_text = strValue;
                                _CommandTextDictionary.Add(command.command_text, command);
                            }
                        }
                        else {
                            ConsoleError("Section " + section + " not understood.");
                            return;
                        }
                        //Upload the command changes
                        QueueCommandForUpload(command);
                    }
                    else {
                        ConsoleError("Command " + command_id + " not found in command dictionary.");
                    }
                }
                else if (strVariable.StartsWith("RLE")) {
                    //Trim off all but the role ID and section
                    //RLE1 | Default Guest | CDE3 | Kill Player

                    String[] commandSplit = CPluginVariable.DecodeStringArray(strVariable);
                    String roleIDStr = commandSplit[0].TrimStart("RLE".ToCharArray()).Trim();
                    Int32 roleID = Int32.Parse(roleIDStr);

                    //If second section is a command prefix, this is the allow/deny clause
                    if (commandSplit[2].Trim().StartsWith("CDE"))
                    {
                        String commandIDStr = commandSplit[2].Trim().TrimStart("CDE".ToCharArray());
                        Int32 commandID = Int32.Parse(commandIDStr);

                        //Fetch needed role
                        AdKatsRole aRole = null;
                        if (_RoleIDDictionary.TryGetValue(roleID, out aRole))
                        {
                            //Fetch needed command
                            AdKatsCommand aCommand = null;
                            if (_CommandIDDictionary.TryGetValue(commandID, out aCommand))
                            {
                                switch (strValue.ToLower())
                                {
                                    case "allow":
                                        lock (aRole.RoleAllowedCommands)
                                        {
                                            if (!aRole.RoleAllowedCommands.ContainsKey(aCommand.command_key))
                                            {
                                                aRole.RoleAllowedCommands.Add(aCommand.command_key, aCommand);
                                            }
                                        }
                                        QueueRoleForUpload(aRole);
                                        break;
                                    case "deny":
                                        lock (aRole.RoleAllowedCommands)
                                        {
                                            aRole.RoleAllowedCommands.Remove(aCommand.command_key);
                                        }
                                        QueueRoleForUpload(aRole);
                                        break;
                                    default:
                                        ConsoleError("Unknown setting when assigning command allowance.");
                                        return;
                                }
                            }
                            else
                            {
                                ConsoleError("Command " + commandID + " not found in command dictionary.");
                            }
                        }
                        else
                        {
                            ConsoleError("Role " + roleID + " not found in role dictionary.");
                        }
                    }
                    else if (commandSplit[2].Trim().StartsWith("GPE"))
                    {
                        String groupIDStr = commandSplit[2].Trim().TrimStart("GPE".ToCharArray());
                        Int32 groupID = Int32.Parse(groupIDStr);

                        //Fetch needed role
                        AdKatsRole aRole = null;
                        if (_RoleIDDictionary.TryGetValue(roleID, out aRole))
                        {
                            //Fetch needed group
                            AdKatsSpecialGroup aGroup = null;
                            if (_specialPlayerGroupIDDictionary.TryGetValue(groupID, out aGroup))
                            {
                                switch (strValue.ToLower())
                                {
                                    case "assign":
                                        lock (aRole.RoleSetGroups)
                                        {
                                            if (!aRole.RoleSetGroups.ContainsKey(aGroup.group_key))
                                            {
                                                aRole.RoleSetGroups.Add(aGroup.group_key, aGroup);
                                            }
                                        }
                                        QueueRoleForUpload(aRole);
                                        break;
                                    case "ignore":
                                        lock (aRole.RoleSetGroups)
                                        {
                                            aRole.RoleSetGroups.Remove(aGroup.group_key);
                                        }
                                        QueueRoleForUpload(aRole);
                                        break;
                                    default:
                                        ConsoleError("Unknown setting when changing role group assignment.");
                                        return;
                                }
                            }
                            else
                            {
                                ConsoleError("Group " + groupID + " not found in group dictionary.");
                            }
                        }
                        else
                        {
                            ConsoleError("Role " + roleID + " not found in role dictionary.");
                        }
                    }
                    else if (commandSplit[2].Contains("Delete Role?") && strValue.ToLower() == "delete") {
                        //Fetch needed role
                        AdKatsRole aRole = null;
                        if (_RoleIDDictionary.TryGetValue(roleID, out aRole)) {
                            QueueRoleForRemoval(aRole);
                        }
                        else {
                            ConsoleError("Unable to fetch role for deletion.");
                        }
                    }
                }
                else if (strVariable.StartsWith("BAN")) {
                    //Trim off all but the command ID and section
                    //BAN1 | ColColonCleaner | Some Reason

                    String[] commandSplit = CPluginVariable.DecodeStringArray(strVariable);
                    String banIDStr = commandSplit[0].TrimStart("BAN".ToCharArray()).Trim();
                    Int32 banID = Int32.Parse(banIDStr);

                    AdKatsBan aBan = null;
                    foreach (AdKatsBan innerBan in _BanEnforcerSearchResults.ToList()) {
                        if (innerBan.ban_id == banID) {
                            aBan = innerBan;
                            break;
                        }
                    }
                    if (aBan != null) {
                        switch (strValue) {
                            case "Active":
                                aBan.ban_status = strValue;
                                break;
                            case "Disabled":
                                aBan.ban_status = strValue;
                                break;
                            default:
                                ConsoleError("Unknown setting when assigning ban status.");
                                return;
                        }
                        if (aBan.ban_status == "Disabled")
                        {
                            if (aBan.ban_record.command_action.command_key == "player_ban_perm" ||
                                aBan.ban_record.command_action.command_key == "player_ban_perm_future")
                            {
                                aBan.ban_record.command_action = GetCommandByKey("player_ban_perm_old");
                            }
                            else if (aBan.ban_record.command_action.command_key == "player_ban_temp")
                            {
                                aBan.ban_record.command_action = GetCommandByKey("player_ban_temp_old");
                            }
                            UpdateRecord(aBan.ban_record);
                        }
                        else if (aBan.ban_status == "Active")
                        {
                            if (aBan.ban_record.command_action.command_key == "player_ban_perm_old")
                            {
                                aBan.ban_record.command_action = GetCommandByKey("player_ban_perm");
                            }
                            else if (aBan.ban_record.command_action.command_key == "player_ban_temp_old")
                            {
                                aBan.ban_record.command_action = GetCommandByKey("player_ban_temp");
                            }
                            UpdateRecord(aBan.ban_record);
                        }
                        UpdateBanStatus(aBan);
                        ConsoleSuccess("Ban " + aBan.ban_id + " is now " + strValue);
                    }
                    else {
                        ConsoleError("Unable to update ban. This should not happen.");
                    }
                }
                else if (Regex.Match(strVariable, @"Punishment Hierarchy").Success) {
                    _PunishmentHierarchy = CPluginVariable.DecodeStringArray(strValue);
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"Punishment Hierarchy", typeof (String), CPluginVariable.EncodeStringArray(_PunishmentHierarchy)));
                }
                else if (Regex.Match(strVariable, @"Combine Server Punishments").Success) {
                    Boolean combine = Boolean.Parse(strValue);
                    if (_CombineServerPunishments != combine) {
                        _CombineServerPunishments = combine;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Combine Server Punishments", typeof (Boolean), _CombineServerPunishments));
                    }
                }
                else if (Regex.Match(strVariable, @"Only Kill Players when Server in low population").Success) {
                    Boolean onlyKill = Boolean.Parse(strValue);
                    if (onlyKill != _OnlyKillOnLowPop) {
                        _OnlyKillOnLowPop = onlyKill;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Only Kill Players when Server in low population", typeof (Boolean), _OnlyKillOnLowPop));
                    }
                }
                else if (Regex.Match(strVariable, @"Low Population Value").Success)
                {
                    Int32 lowPopulationPlayerCount = Int32.Parse(strValue);
                    if (lowPopulationPlayerCount != _lowPopulationPlayerCount)
                    {
                        if (lowPopulationPlayerCount < 0)
                        {
                            ConsoleError("Low population value cannot be less than 0.");
                            lowPopulationPlayerCount = 0;
                        }
                        if (lowPopulationPlayerCount > _highPopulationPlayerCount)
                        {
                            ConsoleError("Low population value cannot be greater than high population value.");
                            lowPopulationPlayerCount = _highPopulationPlayerCount;
                        }
                        _lowPopulationPlayerCount = lowPopulationPlayerCount;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Low Population Value", typeof(Int32), _lowPopulationPlayerCount));
                    }
                }
                else if (Regex.Match(strVariable, @"High Population Value").Success)
                {
                    Int32 HighPopulationPlayerCount = Int32.Parse(strValue);
                    if (HighPopulationPlayerCount != _highPopulationPlayerCount)
                    {
                        if (HighPopulationPlayerCount > 64)
                        {
                            ConsoleError("High population value cannot be greater than 64.");
                            HighPopulationPlayerCount = 64;
                        }
                        if (HighPopulationPlayerCount < _lowPopulationPlayerCount)
                        {
                            ConsoleError("High population value cannot be less than low population value.");
                            HighPopulationPlayerCount = _lowPopulationPlayerCount;
                        }
                        _highPopulationPlayerCount = HighPopulationPlayerCount;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"High Population Value", typeof(Int32), _highPopulationPlayerCount));
                    }
                }
                else if (Regex.Match(strVariable, @"Use IRO Punishment").Success) {
                    Boolean iro = Boolean.Parse(strValue);
                    if (iro != _IROActive) {
                        _IROActive = iro;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Use IRO Punishment", typeof (Boolean), _IROActive));
                    }
                }
                else if (Regex.Match(strVariable, @"IRO Punishment Overrides Low Pop").Success) {
                    Boolean overrideIRO = Boolean.Parse(strValue);
                    if (overrideIRO != _IROOverridesLowPop) {
                        _IROOverridesLowPop = overrideIRO;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"IRO Punishment Overrides Low Pop", typeof (Boolean), _IROOverridesLowPop));
                    }
                }
                else if (Regex.Match(strVariable, @"IRO Timeout Minutes").Success) {
                    Int32 timeout = Int32.Parse(strValue);
                    if (timeout != _IROTimeout) {
                        _IROTimeout = timeout;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"IRO Timeout Minutes", typeof(Int32), _IROTimeout));
                    }
                }
                else if (Regex.Match(strVariable, @"MySQL Hostname").Success) {
                    _mySqlHostname = strValue;
                    _dbSettingsChanged = true;
                    _DbCommunicationWaitHandle.Set();
                }
                else if (Regex.Match(strVariable, @"MySQL Port").Success) {
                    Int32 tmp = 3306;
                    if (!Int32.TryParse(strValue, out tmp)) {
                        tmp = 3306;
                    }
                    if (tmp > 0 && tmp < 65536) {
                        _mySqlPort = strValue;
                        _dbSettingsChanged = true;
                        _DbCommunicationWaitHandle.Set();
                    }
                    else {
                        ConsoleError("Invalid value for MySQL Port: '" + strValue + "'. Must be number between 1 and 65535!");
                    }
                }
                else if (Regex.Match(strVariable, @"MySQL Database").Success) {
                    _mySqlSchemaName = strValue;
                    _dbSettingsChanged = true;
                    _DbCommunicationWaitHandle.Set();
                }
                else if (Regex.Match(strVariable, @"MySQL Username").Success) {
                    _mySqlUsername = strValue;
                    _dbSettingsChanged = true;
                    _DbCommunicationWaitHandle.Set();
                }
                else if (Regex.Match(strVariable, @"MySQL Password").Success) {
                    _mySqlPassword = strValue;
                    _dbSettingsChanged = true;
                    _DbCommunicationWaitHandle.Set();
                }
                else if (Regex.Match(strVariable, @"Send Emails").Success) {
                    //Disabled
                    _UseEmail = Boolean.Parse(strValue);
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable("Send Emails", typeof (Boolean), _UseEmail));
                }
                else if (Regex.Match(strVariable, @"Use SSL?").Success) {
                    _EmailHandler.UseSSL = Boolean.Parse(strValue);
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable("Use SSL?", typeof (Boolean), _EmailHandler.UseSSL));
                }
                else if (Regex.Match(strVariable, @"SMTP-Server address").Success) {
                    if (!String.IsNullOrEmpty(strValue)) {
                        _EmailHandler.SMTPServer = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable("SMTP-Server address", typeof (String), _EmailHandler.SMTPServer));
                    }
                }
                else if (Regex.Match(strVariable, @"SMTP-Server port").Success) {
                    Int32 iPort = Int32.Parse(strValue);
                    if (iPort > 0) {
                        _EmailHandler.SMTPPort = iPort;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable("SMTP-Server port", typeof (Int32), _EmailHandler.SMTPPort));
                    }
                }
                else if (Regex.Match(strVariable, @"Sender address").Success) {
                    if (string.IsNullOrEmpty(strValue)) {
                        _EmailHandler.SenderEmail = "SENDER_CANNOT_BE_EMPTY";
                        ConsoleError("No sender for email was given! Canceling Operation.");
                    }
                    else {
                        _EmailHandler.SenderEmail = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable("Sender address", typeof (String), _EmailHandler.SenderEmail));
                    }
                }
                else if (Regex.Match(strVariable, @"SMTP-Server username").Success) {
                    if (string.IsNullOrEmpty(strValue)) {
                        _EmailHandler.SMTPUser = "SMTP_USERNAME_CANNOT_BE_EMPTY";
                        ConsoleError("No username for SMTP was given! Canceling Operation.");
                    }
                    else {
                        _EmailHandler.SMTPUser = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable("SMTP-Server username", typeof (String), _EmailHandler.SMTPUser));
                    }
                }
                else if (Regex.Match(strVariable, @"SMTP-Server password").Success) {
                    if (string.IsNullOrEmpty(strValue)) {
                        _EmailHandler.SMTPPassword = "SMTP_PASSWORD_CANNOT_BE_EMPTY";
                        ConsoleError("No password for SMTP was given! Canceling Operation.");
                    }
                    else {
                        _EmailHandler.SMTPPassword = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable("SMTP-Server password", typeof (String), _EmailHandler.SMTPPassword));
                    }
                }
                else if (Regex.Match(strVariable, @"Custom HTML Addition").Success) {
                    _EmailHandler.CustomHTMLAddition = strValue;
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable("Custom HTML Addition", typeof (String), _EmailHandler.CustomHTMLAddition));
                }
                else if (Regex.Match(strVariable, @"Extra Recipient Email Addresses").Success) {
                    _EmailHandler.RecipientEmails = CPluginVariable.DecodeStringArray(strValue).ToList();
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"Extra Recipient Email Addresses", typeof (String), strValue));
                }
                else if (Regex.Match(strVariable, @"Only Send Report Emails When Admins Offline").Success)
                {
                    Boolean emailReportsOnlyWhenAdminless = Boolean.Parse(strValue);
                    if (emailReportsOnlyWhenAdminless != _emailReportsOnlyWhenAdminless)
                    {
                        _emailReportsOnlyWhenAdminless = emailReportsOnlyWhenAdminless;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Only Send Report Emails When Admins Offline", typeof(Boolean), _emailReportsOnlyWhenAdminless));
                    }
                }
                else if (Regex.Match(strVariable, @"Use Metabans?").Success) {
                    _useMetabans = Boolean.Parse(strValue);
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable("Use Metabans?", typeof (Boolean), _useMetabans));
                }
                else if (Regex.Match(strVariable, @"Metabans API Key").Success) {
                    if (_useMetabans)
                    {
                        if (string.IsNullOrEmpty(strValue))
                        {
                            _metabansAPIKey = "";
                            ConsoleError("No API key for Metabans was given! Canceling Operation.");
                        }
                        else
                        {
                            _metabansAPIKey = strValue;
                            //Once setting has been changed, upload the change to database
                            QueueSettingForUpload(new CPluginVariable(@"Metabans API Key", typeof(String), _metabansAPIKey));
                        }
                    }
                }
                else if (Regex.Match(strVariable, @"Metabans Username").Success) {
                    if (_useMetabans)
                    {
                        if (string.IsNullOrEmpty(strValue))
                        {
                            _metabansUsername = "";
                            ConsoleError("No username for Metabans was given! Canceling Operation.");
                        }
                        else
                        {
                            _metabansUsername = strValue;
                            //Once setting has been changed, upload the change to database
                            QueueSettingForUpload(new CPluginVariable(@"Metabans Username", typeof(String), _metabansUsername));
                        }
                    }
                }
                else if (Regex.Match(strVariable, @"On-Player-Muted Message").Success) {
                    if (_MutedPlayerMuteMessage != strValue) {
                        _MutedPlayerMuteMessage = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"On-Player-Muted Message", typeof (String), _MutedPlayerMuteMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"On-Player-Killed Message").Success) {
                    if (_MutedPlayerKillMessage != strValue) {
                        _MutedPlayerKillMessage = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"On-Player-Killed Message", typeof (String), _MutedPlayerKillMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"On-Player-Kicked Message").Success) {
                    if (_MutedPlayerKickMessage != strValue) {
                        _MutedPlayerKickMessage = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"On-Player-Kicked Message", typeof (String), _MutedPlayerKickMessage));
                    }
                }
                if (Regex.Match(strVariable, @"# Chances to give player before kicking").Success) {
                    Int32 tmp = 5;
                    int.TryParse(strValue, out tmp);
                    if (_MutedPlayerChances != tmp) {
                        _MutedPlayerChances = tmp;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"# Chances to give player before kicking", typeof (Int32), _MutedPlayerChances));
                    }
                }
                else if (Regex.Match(strVariable, @"Ignore commands for mute enforcement").Success) {
                    Boolean ignoreCommands = Boolean.Parse(strValue);
                    if (_MutedPlayerIgnoreCommands != ignoreCommands) {
                        _MutedPlayerIgnoreCommands = ignoreCommands;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ignore commands for mute enforcement", typeof(Boolean), _MutedPlayerIgnoreCommands));
                    }
                }
                else if (Regex.Match(strVariable, @"Ticket Window High").Success) {
                    Int32 tmp = 2;
                    int.TryParse(strValue, out tmp);
                    if (tmp != _TeamSwapTicketWindowHigh) {
                        _TeamSwapTicketWindowHigh = tmp;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ticket Window High", typeof (Int32), _TeamSwapTicketWindowHigh));
                    }
                }
                else if (Regex.Match(strVariable, @"Ticket Window Low").Success) {
                    Int32 tmp = 2;
                    int.TryParse(strValue, out tmp);
                    if (tmp != _TeamSwapTicketWindowLow) {
                        _TeamSwapTicketWindowLow = tmp;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Ticket Window Low", typeof (Int32), _TeamSwapTicketWindowLow));
                    }
                }
                else if (Regex.Match(strVariable, @"Enable Admin Assistants").Success) {
                    Boolean enableAA = Boolean.Parse(strValue);
                    if (_EnableAdminAssistants != enableAA) {
                        _EnableAdminAssistants = enableAA;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Enable Admin Assistants", typeof (Boolean), _EnableAdminAssistants));
                    }
                }
                else if (Regex.Match(strVariable, @"Enable Admin Assistant Perk").Success) {
                    Boolean enableAA = Boolean.Parse(strValue);
                    if (_EnableAdminAssistantPerk != enableAA) {
                        _EnableAdminAssistantPerk = enableAA;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Enable Admin Assistant Perk", typeof (Boolean), _EnableAdminAssistantPerk));
                    }
                }
                else if (Regex.Match(strVariable, @"Use AA Report Auto Handler").Success) {
                    Boolean useAAHandler = Boolean.Parse(strValue);
                    if (useAAHandler != _UseAAReportAutoHandler) {
                        _UseAAReportAutoHandler = useAAHandler;
                        if (_UseAAReportAutoHandler) {
                            if (_threadsReady) {
                                ConsoleInfo("Internal Automatic Report Handler activated.");
                            }
                        }
                        else {
                            ConsoleInfo("Internal Automatic Report Handler disabled.");
                        }
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Use AA Report Auto Handler", typeof (Boolean), _UseAAReportAutoHandler));
                    }
                }
                else if (Regex.Match(strVariable, @"Auto-Report-Handler Strings").Success) {
                    _AutoReportHandleStrings = CPluginVariable.DecodeStringArray(strValue);
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"Auto-Report-Handler Strings", typeof (String), CPluginVariable.EncodeStringArray(_AutoReportHandleStrings)));
                }
                else if (Regex.Match(strVariable, @"Minimum Confirmed Reports Per Month").Success) {
                    Int32 monthlyReports = Int32.Parse(strValue);
                    if (_MinimumRequiredMonthlyReports != monthlyReports) {
                        _MinimumRequiredMonthlyReports = monthlyReports;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Minimum Confirmed Reports Per Month", typeof (Int32), _MinimumRequiredMonthlyReports));
                    }
                }
                else if (Regex.Match(strVariable, @"Yell display time seconds").Success) {
                    Int32 yellTime = Int32.Parse(strValue);
                    if (_YellDuration != yellTime) {
                        if (yellTime < 0) {
                            ConsoleError("Yell duration cannot be negative.");
                            return;
                        }
                        if (yellTime > 10) {
                            ConsoleError("Yell duration cannot be greater than 10 seconds.");
                            return;
                        }
                        _YellDuration = yellTime;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Yell display time seconds", typeof (Int32), _YellDuration));
                    }
                }
                else if (Regex.Match(strVariable, @"Pre-Message List").Success) {
                    _PreMessageList = new List<String>(CPluginVariable.DecodeStringArray(strValue));
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"Pre-Message List", typeof (String), CPluginVariable.EncodeStringArray(_PreMessageList.ToArray())));
                }
                else if (Regex.Match(strVariable, @"Require Use of Pre-Messages").Success) {
                    Boolean require = Boolean.Parse(strValue);
                    if (require != _RequirePreMessageUse) {
                        _RequirePreMessageUse = require;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Require Use of Pre-Messages", typeof (Boolean), _RequirePreMessageUse));
                    }
                }
                else if (Regex.Match(strVariable, @"Use first spawn message").Success) {
                    Boolean useFirstSpawnMessage = Boolean.Parse(strValue);
                    if (useFirstSpawnMessage != _UseFirstSpawnMessage) {
                        _UseFirstSpawnMessage = useFirstSpawnMessage;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Use first spawn message", typeof(Boolean), _UseFirstSpawnMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"First spawn message text").Success)
                {
                    if (_FirstSpawnMessage != strValue)
                    {
                        _FirstSpawnMessage = strValue;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"First spawn message text", typeof(String), _FirstSpawnMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"Use First Spawn Reputation and Infraction Message").Success)
                {
                    Boolean UseFirstSpawnRepMessage = Boolean.Parse(strValue);
                    if (UseFirstSpawnRepMessage != _useFirstSpawnRepMessage)
                    {
                        _useFirstSpawnRepMessage = UseFirstSpawnRepMessage;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Use First Spawn Reputation and Infraction Message", typeof(Boolean), _useFirstSpawnRepMessage));
                    }
                }
                else if (Regex.Match(strVariable, @"SpamBot Enable").Success)
                {
                    Boolean spamBotEnable = Boolean.Parse(strValue);
                    if (spamBotEnable != _spamBotEnabled)
                    {
                        if (spamBotEnable) {
                            _spamBotSayLastPost = UtcDbTime() - TimeSpan.FromSeconds(10);
                            _spamBotYellLastPost = UtcDbTime() - TimeSpan.FromSeconds(10);
                            _spamBotTellLastPost = UtcDbTime() - TimeSpan.FromSeconds(10);
                        }
                        _spamBotEnabled = spamBotEnable;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"SpamBot Enable", typeof(Boolean), _spamBotEnabled));
                    }
                }
                else if (Regex.Match(strVariable, @"SpamBot Say List").Success)
                {
                    List<String> spamBotSayList = new List<String>(CPluginVariable.DecodeStringArray(strValue));
                    if (!_spamBotSayList.SequenceEqual(spamBotSayList)) 
                    {
                        _spamBotSayQueue.Clear();
                        foreach (String line in spamBotSayList.ToList()) 
                        {
                            _spamBotSayQueue.Enqueue(line);
                        }
                    }
                    _spamBotSayList = spamBotSayList;
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"SpamBot Say List", typeof(String), CPluginVariable.EncodeStringArray(_spamBotSayList.ToArray())));
                }
                else if (Regex.Match(strVariable, @"SpamBot Say Delay Seconds").Success)
                {
                    Int32 spamBotSayDelaySeconds = Int32.Parse(strValue);
                    if (_spamBotSayDelaySeconds != spamBotSayDelaySeconds)
                    {
                        if (spamBotSayDelaySeconds < 60) {
                            ConsoleError("SpamBot Say Delay cannot be less than 60 seconds.");
                            spamBotSayDelaySeconds = 60;
                        }
                        _spamBotSayDelaySeconds = spamBotSayDelaySeconds;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"SpamBot Say Delay Seconds", typeof(Int32), _spamBotSayDelaySeconds));
                    }
                }
                else if (Regex.Match(strVariable, @"SpamBot Yell List").Success)
                {
                    List<String> spamBotYellList = new List<String>(CPluginVariable.DecodeStringArray(strValue));
                    if (!_spamBotYellList.SequenceEqual(spamBotYellList))
                    {
                        _spamBotYellQueue.Clear();
                        foreach (String line in spamBotYellList.ToList())
                        {
                            _spamBotYellQueue.Enqueue(line);
                        }
                    }
                    _spamBotYellList = spamBotYellList;
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"SpamBot Yell List", typeof(String), CPluginVariable.EncodeStringArray(_spamBotYellList.ToArray())));
                }
                else if (Regex.Match(strVariable, @"SpamBot Yell Delay Seconds").Success)
                {
                    Int32 spamBotYellDelaySeconds = Int32.Parse(strValue);
                    if (_spamBotYellDelaySeconds != spamBotYellDelaySeconds)
                    {
                        if (spamBotYellDelaySeconds < 60)
                        {
                            ConsoleError("SpamBot Yell Delay cannot be less than 60 seconds.");
                            spamBotYellDelaySeconds = 60;
                        }
                        _spamBotYellDelaySeconds = spamBotYellDelaySeconds;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"SpamBot Yell Delay Seconds", typeof(Int32), _spamBotYellDelaySeconds));
                    }
                }
                else if (Regex.Match(strVariable, @"SpamBot Tell List").Success)
                {
                    List<String> spamBotTellList = new List<String>(CPluginVariable.DecodeStringArray(strValue));
                    if (!_spamBotYellList.SequenceEqual(spamBotTellList))
                    {
                        _spamBotTellQueue.Clear();
                        foreach (String line in spamBotTellList.ToList())
                        {
                            _spamBotTellQueue.Enqueue(line);
                        }
                    }
                    _spamBotTellList = spamBotTellList;
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"SpamBot Tell List", typeof(String), CPluginVariable.EncodeStringArray(_spamBotTellList.ToArray())));
                }
                else if (Regex.Match(strVariable, @"SpamBot Tell Delay Seconds").Success)
                {
                    Int32 spamBotTellDelaySeconds = Int32.Parse(strValue);
                    if (_spamBotTellDelaySeconds != spamBotTellDelaySeconds)
                    {
                        if (spamBotTellDelaySeconds < 60)
                        {
                            ConsoleError("SpamBot Tell Delay cannot be less than 60 seconds.");
                            spamBotTellDelaySeconds = 60;
                        }
                        _spamBotTellDelaySeconds = spamBotTellDelaySeconds;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"SpamBot Tell Delay Seconds", typeof(Int32), _spamBotTellDelaySeconds));
                    }
                }
                else if (Regex.Match(strVariable, @"Exclude Admins and Whitelist from Spam").Success)
                {
                    Boolean spamBotExcludeAdmins = Boolean.Parse(strValue);
                    if (spamBotExcludeAdmins != _spamBotExcludeAdminsAndWhitelist)
                    {
                        _spamBotExcludeAdminsAndWhitelist = spamBotExcludeAdmins;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Exclude Admins and Whitelist from Spam", typeof(Boolean), _spamBotExcludeAdminsAndWhitelist));
                    }
                }
                else if (Regex.Match(strVariable, @"Display Admin Name in Kick and Ban Announcement").Success) {
                    Boolean display = Boolean.Parse(strValue);
                    if (display != _ShowAdminNameInAnnouncement) {
                        _ShowAdminNameInAnnouncement = display;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Display Admin Name in Kick and Ban Announcement", typeof (Boolean), _ShowAdminNameInAnnouncement));
                    }
                }
                else if (Regex.Match(strVariable, @"Display New Player Announcement").Success)
                {
                    Boolean display = Boolean.Parse(strValue);
                    if (display != _ShowNewPlayerAnnouncement) 
                    {
                        _ShowNewPlayerAnnouncement = display;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Display New Player Announcement", typeof(Boolean), _ShowNewPlayerAnnouncement));
                    }
                }
                else if (Regex.Match(strVariable, @"Display Player Name Change Announcement").Success)
                {
                    Boolean display = Boolean.Parse(strValue);
                    if (display != _ShowPlayerNameChangeAnnouncement)
                    {
                        _ShowPlayerNameChangeAnnouncement = display;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Display Player Name Change Announcement", typeof(Boolean), _ShowPlayerNameChangeAnnouncement));
                    }
                }
                else if (Regex.Match(strVariable, @"Display Targeted Player Left Notification").Success)
                {
                    Boolean ShowTargetedPlayerLeftNotification = Boolean.Parse(strValue);
                    if (ShowTargetedPlayerLeftNotification != _ShowTargetedPlayerLeftNotification)
                    {
                        _ShowTargetedPlayerLeftNotification = ShowTargetedPlayerLeftNotification;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Display Targeted Player Left Notification", typeof(Boolean), _ShowTargetedPlayerLeftNotification));
                    }
                }
                else if (Regex.Match(strVariable, @"Display Ticket Rates in Procon Chat").Success)
                {
                    Boolean display = Boolean.Parse(strValue);
                    if (display != _DisplayTicketRatesInProconChat)
                    {
                        _DisplayTicketRatesInProconChat = display;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Display Ticket Rates in Procon Chat", typeof(Boolean), _DisplayTicketRatesInProconChat));
                    }
                }
                else if (Regex.Match(strVariable, @"Inform players of reports against them").Success) {
                    Boolean inform = Boolean.Parse(strValue);
                    if (inform != _InformReportedPlayers) {
                        _InformReportedPlayers = inform;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Inform players of reports against them", typeof (Boolean), _InformReportedPlayers));
                    }
                }
                else if (Regex.Match(strVariable, @"Player Inform Exclusion Strings").Success) {
                    _PlayerInformExclusionStrings = CPluginVariable.DecodeStringArray(strValue);
                    //Once setting has been changed, upload the change to database
                    QueueSettingForUpload(new CPluginVariable(@"Player Inform Exclusion Strings", typeof (String), CPluginVariable.EncodeStringArray(_PlayerInformExclusionStrings)));
                }
                else if (Regex.Match(strVariable, @"Inform reputable players and admins of admin joins").Success)
                {
                    Boolean InformReputablePlayersOfAdminJoins = Boolean.Parse(strValue);
                    if (InformReputablePlayersOfAdminJoins != _InformReputablePlayersOfAdminJoins)
                    {
                        _InformReputablePlayersOfAdminJoins = InformReputablePlayersOfAdminJoins;
                        //Once setting has been changed, upload the change to database
                        QueueSettingForUpload(new CPluginVariable(@"Inform reputable players and admins of admin joins", typeof(Boolean), _InformReputablePlayersOfAdminJoins));
                    }
                }
                else if (Regex.Match(strVariable, @"Add User").Success) {
                    if (SoldierNameValid(strValue)) {
                        var aUser = new AdKatsUser {
                            user_name = strValue,
                            user_expiration = UtcDbTime().AddYears(20),
                            user_notes = "No Notes"
                        };
                        Boolean valid = true;
                        lock (_userCache) {
                            valid = _userCache.Values.All(iUser => aUser.user_name != iUser.user_name);
                        }
                        if (!valid) {
                            ConsoleError("Unable to add " + aUser.user_name + ", a user with that name already exists.");
                            return;
                        }
                        var addUserThread = new Thread(new ThreadStart(delegate {
                            Thread.CurrentThread.Name = "userchange";
                            DebugWrite("Starting a user change thread.", 2);
                            //Attempt to add soldiers matching the user's name
                            TryAddUserSoldier(aUser, aUser.user_name);
                            QueueUserForUpload(aUser);
                            DebugWrite("Exiting a user change thread.", 2);
                            LogThreadExit();
                        }));
                        StartAndLogThread(addUserThread);
                    }
                    else {
                        ConsoleError("User id had invalid formatting, please try again.");
                    }
                }
                else if (Regex.Match(strVariable, @"Add Role").Success) {
                    if (!String.IsNullOrEmpty(strValue)) {
                        String roleName = new Regex("[^a-zA-Z0-9 _-]").Replace(strValue, "");
                        String roleKey = roleName.Replace(' ', '_');
                        if (!String.IsNullOrEmpty(roleName) && !String.IsNullOrEmpty(roleKey)) {
                            var aRole = new AdKatsRole {
                                role_key = roleKey,
                                role_name = roleName
                            };
                            //By default we should include all commands as allowed
                            lock (_CommandNameDictionary) {
                                foreach (AdKatsCommand aCommand in _RoleKeyDictionary["guest_default"].RoleAllowedCommands.Values) {
                                    aRole.RoleAllowedCommands.Add(aCommand.command_key, aCommand);
                                }
                            }
                            //Queue it for upload
                            QueueRoleForUpload(aRole);
                        }
                        else {
                            ConsoleError("Role had invalid characters, please try again.");
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured while updating AdKats settings.", e));
            }
        }

        public void OnPluginLoaded(String strHostName, String strPort, String strPRoConVersion) {
            DebugWrite("Entering OnPluginLoaded", 7);
            try {
                //Set the server IP
                _serverInfo.ServerIP = strHostName + ":" + strPort;
                //Register all events
                RegisterEvents(GetType().Name, 
                    "OnVersion", 
                    "OnServerInfo", 
                    "OnListPlayers", 
                    "OnPunkbusterPlayerInfo", 
                    "OnReservedSlotsList", 
                    "OnPlayerKilled", 
                    "OnPlayerIsAlive", 
                    "OnPlayerSpawned", 
                    "OnPlayerTeamChange", 
                    "OnPlayerSquadChange", 
                    "OnPlayerJoin", 
                    "OnPlayerLeft", 
                    "OnGlobalChat", 
                    "OnTeamChat", 
                    "OnSquadChat", 
                    "OnLevelLoaded", 
                    "OnBanAdded", 
                    "OnBanRemoved", 
                    "OnBanListClear", 
                    "OnBanListSave", 
                    "OnBanListLoad", 
                    "OnBanList", 
                    "OnRoundOverTeamScores", 
                    "OnSpectatorListLoad", 
                    "OnSpectatorListSave", 
                    "OnSpectatorListPlayerAdded", 
                    "OnSpectatorListPlayerRemoved", 
                    "OnSpectatorListCleared", 
                    "OnSpectatorListList", 
                    "OnGameAdminLoad", 
                    "OnGameAdminSave", 
                    "OnGameAdminPlayerAdded", 
                    "OnGameAdminPlayerRemoved", 
                    "OnGameAdminCleared", 
                    "OnGameAdminList", 
                    "OnFairFight", 
                    "OnIsHitIndicator", 
                    "OnCommander", 
                    "OnForceReloadWholeMags", 
                    "OnServerType", 
                    "OnMaxSpectators", 
                    "OnTeamFactionOverride");
            }
            catch (Exception e) {
                HandleException(new AdKatsException("FATAL ERROR on plugin load.", e));
            }
            DebugWrite("Exiting OnPluginLoaded", 7);
        }

        public void OnPluginEnable() {
            try {
                //If the finalizer is still alive, inform the user and disable
                if (_Finalizer != null && _Finalizer.IsAlive) {
                    ConsoleError("Cannot enable plugin while it is shutting down. Please Wait for it to shut down.");
                    _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(2));
                    //Disable the plugin
                    Disable();
                    return;
                }
                //Create a new thread to activate the plugin
                _Activator = new Thread(new ThreadStart(delegate {
                    try {
                        Thread.CurrentThread.Name = "enabler";
                        Thread.Sleep(250);

                        //Add command informing other plugins that AdKats is enabling
                        RegisterCommand(_PluginEnabledMatchCommand);
                        RegisterCommand(_subscribeAsClientMatchCommand);

                        if (_pluginRebootOnDisable) {
                            if (!String.IsNullOrEmpty(_pluginRebootOnDisableSource)) {
                                PlayerTellMessage(_pluginRebootOnDisableSource, "AdKats is Rebooting");
                            }
                            _pluginRebootOnDisable = false;
                            _pluginRebootOnDisableSource = null;
                        }

                        if ((UtcDbTime() - _proconStartTime).TotalSeconds <= 20) {
                            ConsoleWrite("Waiting a few seconds for requirements and other plugins to initialize, please wait...");
                            //Wait on all settings to be imported by procon for initial start, and for all other plugins to start and register.
                            for (Int32 index = 20 - (Int32)(UtcDbTime() - _proconStartTime).TotalSeconds; index > 0; index--)
                            {
                                ConsoleWrite(index + "...");
                                _threadMasterWaitHandle.WaitOne(1000);
                            }
                        }

                        //Make sure the default in-game admin is disabled
                        ExecuteCommand("procon.protected.plugins.enable", "CInGameAdmin", "False");

                        //Initialize the stat library
                        _StatLibrary = new StatLibrary(this);
                        if (_StatLibrary.PopulateWeaponStats())
                        {
                            ConsoleSuccess("Fetched " + _StatLibrary.Weapons.Count + " " + _gameVersion + " weapon stat definitions.");
                        }
                        else
                        {
                            ConsoleError("Failed to fetch weapon stat definitions. AdKats cannot be started.");
                            Disable();
                            LogThreadExit();
                            return;
                        }

                        //Fetch all reputation information
                        if (PopulateCommandReputationDictionaries()) 
                        {
                            ConsoleSuccess("Fetched reputation definitions.");
                        }
                        else
                        {
                            ConsoleError("Failed to fetch reputation definitions. AdKats cannot be started.");
                            Disable();
                            LogThreadExit();
                            return;
                        }

                        //Fetch all weapon names
                        if (PopulateWeaponNameDictionaries()) 
                        {
                            ConsoleSuccess("Fetched weapon names.");
                        }
                        else
                        {
                            ConsoleError("Failed to fetch weapon names. AdKats cannot be started.");
                            Disable();
                            LogThreadExit();
                            return;
                        }

                        //Fetch all special player group information
                        if (PopulateSpecialGroupDictionaries())
                        {
                            ConsoleSuccess("Fetched special player group definitions.");
                        }
                        else
                        {
                            ConsoleError("Failed to fetch special player group definitions. AdKats cannot be started.");
                            Disable();
                            LogThreadExit();
                            return;
                        }

                        //Fetch global timing
                        TimeSpan diffUTCGlobal;
                        _globalTimingValid = TestGlobalTiming(false, true, out diffUTCGlobal);
                        _globalTimingOffset = diffUTCGlobal;

                        //Don't directly depend on stat logger being controllable at this time, connection is unstable
                        /*if (useDatabase)
                        {
                            //Confirm Stat Logger active and properly configured
                            ConsoleWrite("Confirming proper setup for CChatGUIDStatsLoggerBF3, please wait...");

                            if (gameVersion == GameVersion.BF3)
                            {
                                if (confirmStatLoggerSetup())
                                {
                                    ConsoleSuccess("^bCChatGUIDStatsLoggerBF3^n enabled and active!");
                                }
                                else
                                {
                                    //Stat logger could not be enabled or managed
                                    ConsoleWarn("The stat logger plugin could not be found or controlled. Running AdKats in backup mode.");
                                    return;
                                }
                            }
                        }*/

                        //Inform of IP
                        ConsoleSuccess("Server IP is " + _serverInfo.ServerIP + "");

                        //Set the enabled variable
                        _pluginEnabled = true;
                        _LastVersionTrackingUpdate = UtcDbTime() - TimeSpan.FromHours(1);

                        //Init and start all the threads
                        InitWaitHandles();
                        OpenAllHandles();
                        InitThreads();
                        StartThreads();
                    }
                    catch (Exception e) {
                        HandleException(new AdKatsException("Error while enabling AdKats.", e));
                    }
                    LogThreadExit();
                }));

                ConsoleWrite("^b^2ENABLED!^n^0 Beginning startup sequence...");
                //Start the thread
                StartAndLogThread(_Activator);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while initializing activator thread.", e));
            }
        }

        public void OnPluginDisable() {
            //If the plugin is already disabling then cancel
            if (_Finalizer != null && _Finalizer.IsAlive)
                return;
            try {
                //Create a new thread to disabled the plugin
                _Finalizer = new Thread(new ThreadStart(delegate {
                    try {
                        Thread.CurrentThread.Name = "finalizer";
                        ConsoleInfo("Shutting down AdKats.");
                        //Disable settings
                        _pluginEnabled = false;
                        _threadsReady = false;
                        //Remove all match commands
                        UnregisterCommand(_PluginEnabledMatchCommand);
                        UnregisterCommand(_issueCommandMatchCommand);
                        UnregisterCommand(_fetchAuthorizedSoldiersMatchCommand);
                        UnregisterCommand(_subscribeAsClientMatchCommand);
                        //Open all handles. Threads will finish on their own.
                        OpenAllHandles();

                        //Check to make sure all threads have completed and stopped
                        Int32 attempts = 0;
                        Boolean alive = false;
                        do {
                            OpenAllHandles();
                            attempts++;
                            Thread.Sleep(500);
                            alive = false;
                            String aliveThreads = "";
                            lock (_aliveThreads) {
                                foreach (Thread aliveThread in _aliveThreads.Values.ToList()) {
                                    alive = true;
                                    aliveThreads += (aliveThread.Name + "[" + aliveThread.ManagedThreadId + "] ");
                                }
                            }
                            if (aliveThreads.Length > 0) {
                                if (attempts > 20) {
                                    ConsoleWarn("Threads still exiting: " + aliveThreads);
                                }
                                else {
                                    DebugWrite("Threads still exiting: " + aliveThreads, 2);
                                }
                            }
                        } while (alive);

                        //Reset all caches and storage
                        if (_UserRemovalQueue != null)
                            _UserRemovalQueue.Clear();
                        if (_UserUploadQueue != null)
                            _UserUploadQueue.Clear();
                        if (_TeamswapForceMoveQueue != null)
                            _TeamswapForceMoveQueue.Clear();
                        if (_TeamswapOnDeathCheckingQueue != null)
                            _TeamswapOnDeathCheckingQueue.Clear();
                        if (_TeamswapOnDeathMoveDic != null)
                            _TeamswapOnDeathMoveDic.Clear();
                        if (_UnparsedCommandQueue != null)
                            _UnparsedCommandQueue.Clear();
                        if (_UnparsedMessageQueue != null)
                            _UnparsedMessageQueue.Clear();
                        if (_UnprocessedActionQueue != null)
                            _UnprocessedActionQueue.Clear();
                        if (_UnprocessedRecordQueue != null)
                            _UnprocessedRecordQueue.Clear();
                        if (_UnprocessedStatisticQueue != null) {
                            _UnprocessedStatisticQueue.Clear();
                        }
                        if (_BanEnforcerCheckingQueue != null)
                            _BanEnforcerCheckingQueue.Clear();
                        _toldCol = false;
                        if (_Team2MoveQueue != null)
                            _Team2MoveQueue.Clear();
                        if (_Team1MoveQueue != null)
                            _Team1MoveQueue.Clear();
                        if (_RoundCookers != null)
                            _RoundCookers.Clear();
                        if (_RoundReports != null)
                            _RoundReports.Clear();
                        if (_RoundReportHistory != null)
                            _RoundReportHistory.Clear();
                        if (_RoundMutedPlayers != null)
                            _RoundMutedPlayers.Clear();
                        if (_PlayerDictionary != null)
                            _PlayerDictionary.Clear();
                        if (_PlayerLeftDictionary != null)
                            _PlayerLeftDictionary.Clear();
                        _firstPlayerListComplete = false;
                        _firstUserListComplete = false;
                        _firstPlayerListStarted = false;
                        if (_userCache != null)
                            _userCache.Clear();
                        if (FrostbitePlayerInfoList != null)
                            FrostbitePlayerInfoList.Clear();
                        if (_CBanProcessingQueue != null)
                            _CBanProcessingQueue.Clear();
                        if (_BanEnforcerProcessingQueue != null)
                            _BanEnforcerProcessingQueue.Clear();
                        if (_ActOnSpawnDictionary != null)
                            _ActOnSpawnDictionary.Clear();
                        if (_ActOnIsAliveDictionary != null)
                            _ActOnIsAliveDictionary.Clear();
                        if (_ActionConfirmDic != null)
                            _ActionConfirmDic.Clear();
                        if(_LoadoutConfirmDictionary != null)
                            _LoadoutConfirmDictionary.Clear();
                        _unmatchedRoundDeathCounts.Clear();
                        _unmatchedRoundDeaths.Clear();
                        _endingRound = false;
                        _surrenderVoteList.Clear();
                        _nosurrenderVoteList.Clear();
                        _surrenderVoteActive = false;
                        _surrenderVoteSucceeded = false;
                        _slowmo = false;
                        _pluginUpdateServerInfoChecked = false;
                        if (_subscribedClients.Any()) {
                            ConsoleWarn("All active subscriptions removed.");
                            _subscribedClients.Clear();
                        }
                        //Now that plugin is disabled, update the settings page to reflect
                        UpdateSettingPage();
                        ConsoleWrite("^b^1AdKats " + GetPluginVersion() + " Disabled! =(^n^0");
                        //Automatic Enable
                        if (_pluginRebootOnDisable && !_useKeepAlive) {
                            Enable();
                        }
                    }
                    catch (Exception e) {
                        HandleException(new AdKatsException("Error occured while disabling Adkats.", e));
                    }
                }));

                //Start the finalizer thread
                _Finalizer.Start();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured while initializing AdKats disable thread.", e));
            }
        }

        private void FetchPluginDocumentation() {
            if (_aliveThreads.Values.Any(aThread => aThread.Name == "descfetching")) {
                return;
            }
            _PluginDescriptionWaitHandle.Reset();
            //Create a new thread to fetch the plugin description and changelog
            var descFetcher = new Thread(new ThreadStart(delegate {
                try {
                    Thread.CurrentThread.Name = "descfetching";
                    _pluginDescFetchProgress = "Started";
                    //Create web client
                    var client = new WebClient();
                    //Download the readme and changelog
                    DebugWrite("Fetching plugin links...", 2);
                    try
                    {
                        _pluginLinks = client.DownloadString("https://raw.github.com/AdKats/AdKats/master/LINKS.md");
                        DebugWrite("Plugin links fetched.", 1);
                    }
                    catch (Exception)
                    {
                        try
                        {
                            _pluginLinks = client.DownloadString("http://api.gamerethos.net/adkats/fetch/links");
                            DebugWrite("Plugin links fetched from backup location.", 1);
                        }
                        catch (Exception)
                        {
                            ConsoleError("Failed to fetch plugin links.");
                        }
                    }
                    _pluginDescFetchProgress = "LinksFetched";
                    DebugWrite("Fetching plugin readme...", 2);
                    try
                    {
                        _pluginDescription = client.DownloadString("https://raw.github.com/AdKats/AdKats/master/README.md");
                        DebugWrite("Plugin readme fetched.", 1);
                    }
                    catch (Exception)
                    {
                        try
                        {
                            _pluginDescription = client.DownloadString("http://api.gamerethos.net/adkats/fetch/readme");
                            DebugWrite("Plugin readme fetched from backup location.", 1);
                        }
                        catch (Exception)
                        {
                            ConsoleError("Failed to fetch plugin readme.");
                        }
                    }
                    _pluginDescFetchProgress = "DescFetched";
                    DebugWrite("Fetching plugin changelog...", 2);
                    try
                    {
                        _pluginChangelog = client.DownloadString("https://raw.github.com/AdKats/AdKats/master/CHANGELOG.md");
                        DebugWrite("Plugin changelog fetched.", 1);
                    }
                    catch (Exception)
                    {
                        try
                        {
                            _pluginChangelog = client.DownloadString("http://api.gamerethos.net/adkats/fetch/changelog");
                            DebugWrite("Plugin changelog fetched from backup location.", 1);
                        }
                        catch (Exception)
                        {
                            ConsoleError("Failed to fetch plugin changelog.");
                        }
                    }
                    _pluginDescFetchProgress = "ChangeFetched";
                    if (!String.IsNullOrEmpty(_pluginDescription)) {
                        //Extract the latest stable version
                        String latestStableVersion = ExtractString(_pluginDescription, "latest_stable_release");
                        if (!String.IsNullOrEmpty(latestStableVersion)) {
                            //Convert it to an integer
                            String trimmedLatestStableVersion = latestStableVersion.Replace(".", "");
                            _latestPluginVersion = latestStableVersion;
                            _latestPluginVersionInt = Int32.Parse(trimmedLatestStableVersion);
                            //Get current plugin version
                            _currentPluginVersionInt = Int32.Parse(PluginVersion.Replace(".", ""));

                            String versionStatus = String.Empty;
                            //Add the appropriate message to plugin description
                            if (_latestPluginVersionInt > _currentPluginVersionInt) {
                                if (_pluginUpdatePatched) {
                                    versionStatus = @"
                                    <h2 style='color:#DF0101;'>
                                        You are running an outdated version! The update has been patched, reboot PRoCon to run version " + latestStableVersion + @"!
                                    </h2>";
                                }
                                else {
                                    versionStatus = @"
                                    <h2 style='color:#DF0101;'>
                                        You are running an outdated version! Version " + latestStableVersion + @" is available for download!
                                    </h2>
                                    <a href='https://sourceforge.net/projects/adkats/files/latest/download' target='_blank'>
                                        Download Version " + latestStableVersion + @"!
                                    </a><br/>
                                    Download link below.";
                                }
                                _pluginVersionStatus = VersionStatus.OutdatedBuild;
                            }
                            else if (_latestPluginVersionInt == _currentPluginVersionInt) {
                                versionStatus = @"
                                <h2 style='color:#01DF01;'>
                                    Congrats! You are running the latest stable version!
                                </h2>";
                                _pluginVersionStatus = VersionStatus.StableBuild;
                            }
                            else if (_latestPluginVersionInt < _currentPluginVersionInt) {
                                versionStatus = @"
                                <h2 style='color:#FF8000;'>
                                    CAUTION! You are running a TEST version! Functionality might not be completely tested.
                                </h2>";
                                _pluginVersionStatus = VersionStatus.TestBuild;
                            }
                            else {
                                _pluginVersionStatus = VersionStatus.UnknownBuild;
                            }
                            //Prepend the message
                            _pluginVersionStatusString = versionStatus;
                            _pluginDescFetchProgress = "VersionStatusSet";
                            //Check for plugin updates
                            CheckForPluginUpdates(false);
                            _pluginDescFetchProgress = "UpdateChecked";
                        }
                    }
                    else if (!_fetchedPluginInformation) {
                        ConsoleError("Unable to fetch required documentation files. AdKats cannot be started.");
                        Disable();
                        LogThreadExit();
                        return;
                    }
                    DebugWrite("Setting desc fetch handle.", 1);
                    _fetchedPluginInformation = true;
                    _LastPluginDescFetch = UtcDbTime();
                    _PluginDescriptionWaitHandle.Set();
                    _pluginDescFetchProgress = "Completed";
                }
                catch (Exception e) {
                    HandleException(new AdKatsException("Error while fetching plugin description and changelog.", e));
                }
                LogThreadExit();
            }));
            //Start the thread
            StartAndLogThread(descFetcher);
        }

        private void SetupStatusMonitor() {
            //Create a new thread to handle keep-alive
            //This thread will remain running for the duration the layer is online
            var statusMonitorThread = new Thread(new ThreadStart(delegate {
                try {
                    Thread.CurrentThread.Name = "StatusMonitor";
                    DateTime lastKeepAliveCheck = UtcDbTime();
                    ExecuteCommand("procon.protected.send", "serverInfo");
                    DateTime lastServerInfoRequest = UtcDbTime();
                    while (true)
                    {
                        try
                        {
                            if (_isTestingAuthorized && _gameVersion == GameVersion.BF3)
                            {
                                ConsoleWarn((GC.GetTotalMemory(true) / 1024 / 1024) + "MB Estimated Memory Used.");
                            }

                            //Check for unswitcher disable every 20 seconds
                            if (_pluginEnabled && _MULTIBalancerUnswitcherDisabled && (UtcDbTime() - _LastPlayerMoveIssued).TotalSeconds > 20)
                            {
                                DebugWrite("MULTIBalancer Unswitcher Re-Enabled", 3);
                                ExecuteCommand("procon.protected.plugins.call", "MULTIbalancer", "UpdatePluginData", "AdKats", "bool", "DisableUnswitcher", "False");
                                _MULTIBalancerUnswitcherDisabled = false;
                            }

                            //Check for plugin updates at interval
                            if ((UtcDbTime() - _LastPluginDescFetch).TotalHours > 1 ||
                                (_isTestingAuthorized && (UtcDbTime() - _LastPluginDescFetch).TotalMinutes > 20))
                            {
                                FetchPluginDocumentation();
                            }

                            //Post usage stats at interval
                            if ((!_versionTrackingDisabled || _pluginVersionStatus == VersionStatus.TestBuild || _isTestingAuthorized) &&
                                (UtcDbTime() - _LastVersionTrackingUpdate).TotalHours > 1 &&
                                (_threadsReady || (UtcDbTime() - _proconStartTime).TotalSeconds > 30))
                            {
                                PostVersionTracking();
                            }

                            //Run SpamBot
                            if (_pluginEnabled && _spamBotEnabled)
                            {
                                if ((UtcDbTime() - _spamBotSayLastPost).TotalSeconds > _spamBotSayDelaySeconds)
                                {
                                    if (_spamBotExcludeAdminsAndWhitelist)
                                    {
                                        if (!String.IsNullOrEmpty(_spamBotSayQueue.Peek()))
                                            OnlineNonWhitelistSayMessage(_spamBotSayQueue.Peek());
                                    }
                                    else
                                    {
                                        if (!String.IsNullOrEmpty(_spamBotSayQueue.Peek()))
                                            AdminSayMessage(_spamBotSayQueue.Peek());
                                    }
                                    _spamBotSayLastPost = UtcDbTime();
                                    _spamBotSayQueue.Enqueue(_spamBotSayQueue.Dequeue());
                                }
                                if ((UtcDbTime() - _spamBotYellLastPost).TotalSeconds > _spamBotYellDelaySeconds)
                                {
                                    if (_spamBotExcludeAdminsAndWhitelist)
                                    {
                                        if (!String.IsNullOrEmpty(_spamBotYellQueue.Peek()))
                                            OnlineNonWhitelistYellMessage(_spamBotYellQueue.Peek());
                                    }
                                    else
                                    {
                                        if (!String.IsNullOrEmpty(_spamBotYellQueue.Peek()))
                                            AdminYellMessage(_spamBotYellQueue.Peek());
                                    }
                                    _spamBotYellQueue.Enqueue(_spamBotYellQueue.Dequeue());
                                    _spamBotYellLastPost = UtcDbTime();
                                }
                                if ((UtcDbTime() - _spamBotTellLastPost).TotalSeconds > _spamBotTellDelaySeconds)
                                {
                                    if (_spamBotExcludeAdminsAndWhitelist)
                                    {
                                        if (!String.IsNullOrEmpty(_spamBotTellQueue.Peek()))
                                            OnlineNonWhitelistTellMessage(_spamBotTellQueue.Peek());
                                    }
                                    else
                                    {
                                        if (!String.IsNullOrEmpty(_spamBotTellQueue.Peek()))
                                            AdminTellMessage(_spamBotTellQueue.Peek());
                                    }
                                    _spamBotTellQueue.Enqueue(_spamBotTellQueue.Dequeue());
                                    _spamBotTellLastPost = UtcDbTime();
                                }
                            }

                            //Check for keep alive every 30 seconds
                            if ((UtcDbTime() - lastKeepAliveCheck).TotalSeconds > 30)
                            {
                                //ConsoleInfo("Average Read: " + Math.Round(_DatabaseReadAverageDuration, 3) + "s " + _DatabaseReaderDurations.Count + " | Average Write: " + Math.Round(_DatabaseWriteAverageDuration, 3) + "s " + _DatabaseNonQueryDurations.Count);
                                lastKeepAliveCheck = UtcDbTime();

                                if (_pluginEnabled && _threadsReady && _firstPlayerListComplete)
                                {
                                    AdminSayMessage("/AdKatsInstanceCheck " + _instanceKey + " " + Math.Round((UtcDbTime() - _AdKatsRunningTime).TotalSeconds), false);
                                }

                                //Enable if auto-enable wanted
                                if (_useKeepAlive && !_pluginEnabled)
                                {
                                    Enable();
                                }

                                if (_aliveThreads.Count() >= 20)
                                {
                                    String aliveThreads = "";
                                    lock (_aliveThreads)
                                    {
                                        foreach (Thread value in _aliveThreads.Values.ToList())
                                            aliveThreads = aliveThreads + (value.Name + "[" + value.ManagedThreadId + "] ");
                                    }
                                    ConsoleWarn("Thread warning: " + aliveThreads);
                                }

                                //Perform AFK processing
                                if (_AFKManagerEnable && _AFKAutoKickEnable && (_PlayerDictionary.Count > _AFKTriggerMinimumPlayers))
                                {
                                    //Double list conversion
                                    List<AdKatsPlayer> afkPlayers = _PlayerDictionary.Values.ToList().Where(
                                        aPlayer =>
                                            (UtcDbTime() - aPlayer.lastAction).TotalMinutes > _AFKTriggerDurationMinutes &&
                                            aPlayer.player_type != PlayerType.Spectator &&
                                            !PlayerIsAdmin(aPlayer)).Take(_PlayerDictionary.Count - _AFKTriggerMinimumPlayers).ToList();
                                    if (_AFKIgnoreUserList)
                                    {
                                        IEnumerable<string> userSoldierGuids = FetchAllUserSoldiers().Select(aPlayer => aPlayer.player_guid);
                                        afkPlayers = afkPlayers.Where(aPlayer => !userSoldierGuids.Contains(aPlayer.player_guid)).ToList();
                                    }
                                    else
                                    {
                                        afkPlayers = afkPlayers.Where(aPlayer => !_AFKIgnoreRoles.Contains(aPlayer.player_role.role_key)).ToList();
                                    }
                                    foreach(var aPlayer in afkPlayers)
                                    {
                                        String afkTime = FormatTimeString(UtcDbTime() - aPlayer.lastAction, 2);
                                        DebugWrite("Kicking " + aPlayer.player_name + " for being AFK " + afkTime + ".", 3);
                                        var record = new AdKatsRecord
                                        {
                                            record_source = AdKatsRecord.Sources.InternalAutomated,
                                            server_id = _serverInfo.ServerID,
                                            command_type = GetCommandByKey("player_kick"),
                                            command_numeric = 0,
                                            target_name = aPlayer.player_name,
                                            target_player = aPlayer,
                                            source_name = "AFKManager",
                                            record_message = "AFK time exceeded [" + afkTime + "/" + GetPlayerTeamKey(aPlayer) + "]. Please rejoin once you return."
                                        };
                                        QueueRecordForProcessing(record);
                                        //Only take one
                                        break;
                                    }

                                    //TODO: Once MULTIBalancer adds registered commands, check for availability
                                }
                            }

                            if (_threadsReady && (UtcDbTime() - lastServerInfoRequest).TotalSeconds > 10)
                            {
                                ExecuteCommand("procon.protected.send", "serverInfo");
                                ExecuteCommand("procon.protected.send", "admin.listPlayers", "all");
                                lastServerInfoRequest = UtcDbTime();
                            }

                            //Sleep 1 second between loops
                            Thread.Sleep(TimeSpan.FromSeconds(1));
                        }
                        catch (Exception e)
                        {
                            HandleException(new AdKatsException("Error in status monitor. Skipping current loop.", e));
                        }
                    }
                }
                catch (Exception e) {
                    HandleException(new AdKatsException("Error while running status monitor.", e));
                }
            }));
            //Start the thread
            statusMonitorThread.Start();
        }

        public void InitWaitHandles() {
            //Initializes all wait handles 
            _threadMasterWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _TeamswapWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _PlayerProcessingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _AccessFetchWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _KillProcessingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _PlayerListUpdateWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _MessageParsingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _CommandParsingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _DbCommunicationWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _ActionHandlingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _BanEnforcerWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _HackerCheckerWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _ServerInfoWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _StatLoggerStatusWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _PluginDescriptionWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            _BattlelogCommWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        }

        public void OpenAllHandles() {
            _threadMasterWaitHandle.Set();
            _TeamswapWaitHandle.Set();
            _PlayerProcessingWaitHandle.Set();
            _AccessFetchWaitHandle.Set();
            _KillProcessingWaitHandle.Set();
            _PlayerListUpdateWaitHandle.Set();
            _MessageParsingWaitHandle.Set();
            _CommandParsingWaitHandle.Set();
            _DbCommunicationWaitHandle.Set();
            _ActionHandlingWaitHandle.Set();
            _BanEnforcerWaitHandle.Set();
            _HackerCheckerWaitHandle.Set();
            _ServerInfoWaitHandle.Set();
            _StatLoggerStatusWaitHandle.Set();
            _BattlelogCommWaitHandle.Set();
            _EmailHandler._EmailProcessingWaitHandle.Set();
        }

        public void InitThreads() {
            try {
                //Creats all threads with their starting methods and set to run in the background
                _PlayerListingThread = new Thread(PlayerListingThreadLoop) {
                    IsBackground = true
                };

                _AccessFetchingThread = new Thread(AccessFetchingThreadLoop) {
                    IsBackground = true
                };

                _KillProcessingThread = new Thread(KillProcessingThreadLoop) {
                    IsBackground = true
                };

                _MessageProcessingThread = new Thread(MessagingThreadLoop) {
                    IsBackground = true
                };

                _CommandParsingThread = new Thread(CommandParsingThreadLoop) {
                    IsBackground = true
                };

                _DatabaseCommunicationThread = new Thread(DatabaseCommunicationThreadLoop) {
                    IsBackground = true
                };

                _ActionHandlingThread = new Thread(ActionHandlingThreadLoop) {
                    IsBackground = true
                };

                _TeamSwapThread = new Thread(TeamswapThreadLoop) {
                    IsBackground = true
                };

                _BanEnforcerThread = new Thread(BanEnforcerThreadLoop) {
                    IsBackground = true
                };

                _HackerCheckerThread = new Thread(HackerCheckerThreadLoop)
                {
                    IsBackground = true
                };

                _BattlelogCommThread = new Thread(BattlelogCommThreadLoop)
                {
                    IsBackground = true
                };

                _IPAPICommThread = new Thread(IPAPICommThreadLoop)
                {
                    IsBackground = true
                };
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured while initializing threads.", e));
            }
        }

        public void StartThreads() {
            DebugWrite("Entering StartThreads", 7);
            try {
                //Start the main thread
                OnlineAdminSayMessage("AdKats starting.");
                //Reset the master wait handle
                _threadMasterWaitHandle.Reset();
                //DB Comm is the heart of AdKats, everything revolves around that thread
                StartAndLogThread(_DatabaseCommunicationThread);
                //Battlelog comm and IP API threads are independant
                StartAndLogThread(_BattlelogCommThread);
                StartAndLogThread(_IPAPICommThread);
                //Other threads are started within the db comm thread
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while starting processing threads.", e));
            }
            DebugWrite("Exiting StartThreads", 7);
        }

        private void Disable() {
            //Call Disable
            ExecuteCommand("procon.protected.plugins.enable", "AdKats", "False");
            //Set enabled false so threads begin exiting
            _pluginEnabled = false;
            _threadsReady = false;
        }

        private void Enable() {
            if (Thread.CurrentThread.Name == "finalizer")
            {
                var pluginRebootThread = new Thread(new ThreadStart(delegate {
                    DebugWrite("Starting a reboot thread.", 5);
                    try {
                        Thread.CurrentThread.Name = "RebootThread";
                        Thread.Sleep(1000);
                        //Call Enable
                        ExecuteCommand("procon.protected.plugins.enable", "AdKats", "True");
                    }
                    catch (Exception) {
                        HandleException(new AdKatsException("Error while running reboot."));
                    }
                    DebugWrite("Exiting a reboot thread.", 5);
                    LogThreadExit();
                }));
                StartAndLogThread(pluginRebootThread);
            }
            else
            {
                //Call Enable
                ExecuteCommand("procon.protected.plugins.enable", "AdKats", "True");
            }
        }

        public void OnPluginLoadingEnv(List<String> lstPluginEnv) {
            foreach (String env in lstPluginEnv) {
                DebugWrite("^9OnPluginLoadingEnv: " + env, 7);
            }
            switch (lstPluginEnv[1]) {
                case "BF3":
                    _gameVersion = GameVersion.BF3;
                    break;
                case "BF4":
                    _gameVersion = GameVersion.BF4;
                    break;
            }
            DebugWrite("^1Game Version: " + _gameVersion, 1);
            //Initialize the email handler
            _EmailHandler = new EmailHandler(this);
            //Update faction info
            //Load initial factions
            OnTeamFactionOverride(0, -1);
            OnTeamFactionOverride(1, 0);
            OnTeamFactionOverride(2, 1);
            OnTeamFactionOverride(3, 0);
            OnTeamFactionOverride(4, 1);
            UpdateFactions();
        }

        public override void OnVersion(String serverType, String version) {
            _serverInfo.GamePatchVersion = version;
        }

        public override void OnTeamFactionOverride(Int32 targetTeamID, Int32 overrideTeamId) {
            try
            {
                lock (_teamDictionary)
                {
                    switch (overrideTeamId)
                    {
                        case -1:
                            //Check for already existing Neutral team
                            if (_serverInfo.GetRoundElapsedTime().TotalSeconds > 20 &&
                                _teamDictionary.ContainsKey(targetTeamID) &&
                                _teamDictionary[targetTeamID].TeamKey == "Neutral" &&
                                _roundState == RoundState.Playing)
                            {
                                DebugWrite("Neutral Team already set for team " + targetTeamID + ", cancelling override.", 4);
                                break;
                            }
                            _teamDictionary[targetTeamID] = new AdKatsTeam(this, targetTeamID, "Neutral", "Neutral Team", "Neutral Team");
                            DebugWrite("Assigning team ID " + targetTeamID + " to Neutral ", 4);
                            break;
                        case 0:
                            //Check for already existing US team
                            if (_serverInfo.GetRoundElapsedTime().TotalSeconds > 20 &&
                                _teamDictionary.ContainsKey(targetTeamID) &&
                                _teamDictionary[targetTeamID].TeamKey == "US" &&
                                _roundState == RoundState.Playing)
                            {
                                DebugWrite("Team US already set for team " + targetTeamID + ", cancelling override.", 4);
                                break;
                            }
                            _teamDictionary[targetTeamID] = new AdKatsTeam(this, targetTeamID, "US", "US Army", "United States Army");
                            DebugWrite("Assigning team ID " + targetTeamID + " to US ", 4);
                            break;
                        case 1:
                            //Check for already existing US team
                            if (_serverInfo.GetRoundElapsedTime().TotalSeconds > 20 && 
                                _teamDictionary.ContainsKey(targetTeamID) &&
                                _teamDictionary[targetTeamID].TeamKey == "RU" &&
                                _roundState == RoundState.Playing)
                            {
                                DebugWrite("Team RU already set for team " + targetTeamID + ", cancelling override.", 4);
                                break;
                            }
                            _teamDictionary[targetTeamID] = new AdKatsTeam(this, targetTeamID, "RU", "Russian Army", "Russian Federation Army");
                            DebugWrite("Assigning team ID " + targetTeamID + " to RU", 4);
                            break;
                        case 2:
                            //Check for already existing US team
                            if (_serverInfo.GetRoundElapsedTime().TotalSeconds > 20 
                                && _teamDictionary.ContainsKey(targetTeamID) &&
                                _teamDictionary[targetTeamID].TeamKey == "CN" &&
                                _roundState == RoundState.Playing)
                            {
                                DebugWrite("Team CN already set for team " + targetTeamID + ", cancelling override.", 4);
                                break;
                            }
                            _teamDictionary[targetTeamID] = new AdKatsTeam(this, targetTeamID, "CN", "Chinese Army", "Chinese People's Liberation Army");
                            DebugWrite("Assigning team ID " + targetTeamID + " to CN", 4);
                            break;
                        default:
                            ConsoleError("Team ID " + overrideTeamId + " was not understood.");
                            break;
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while processing team faction override.", e));
            }
        }

        public override void OnFairFight(bool isEnabled) {
            _serverInfo.FairFightEnabled = isEnabled;
        }

        public override void OnIsHitIndicator(bool isEnabled) {
            _serverInfo.HitIndicatorEnabled = isEnabled;
        }

        public override void OnCommander(bool isEnabled) {
            _serverInfo.CommanderEnabled = isEnabled;
        }

        public override void OnForceReloadWholeMags(bool isEnabled) {
            _serverInfo.ForceReloadWholeMags = isEnabled;
        }

        public override void OnServerType(String serverType) {
            _serverInfo.ServerType = serverType;
        }

        //procon.public.accounts.create
        //procon.public.accounts.delete
        //procon.public.accounts.setPassword
        public override void OnGameAdminLoad() {
            ConsoleInfo("OnGameAdminLoad");
        }

        public override void OnGameAdminSave()
        {
            ConsoleInfo("OnGameAdminSave");
        }

        public override void OnGameAdminPlayerAdded(String soldierName)
        {
            ConsoleInfo("OnGameAdminPlayerAdded " + soldierName);
        }

        public override void OnGameAdminPlayerRemoved(String soldierName)
        {
            ConsoleInfo("OnGameAdminPlayerRemoved " + soldierName);
        }

        public override void OnGameAdminCleared()
        {
            ConsoleInfo("OnGameAdminCleared");
        }

        public override void OnGameAdminList(List<String> soldierNames)
        {
            foreach (var soldierName in soldierNames)
            {
                ConsoleInfo("OnGameAdminList " + soldierName);
            }
        }

        
        public void UpdateFactions() {
            if (_gameVersion == GameVersion.BF3) {
                OnTeamFactionOverride(1, 0);
                OnTeamFactionOverride(2, 1);
                OnTeamFactionOverride(3, 0);
                OnTeamFactionOverride(4, 1);
            }
            else if (_gameVersion == GameVersion.BF4) {
                _teamDictionary[0] = new AdKatsTeam(this, 0, "Spectator", "Spectators", "Server Spectators");
                DebugWrite("Assigning team ID " + 0 + " to Spectator", 4);
                ExecuteCommand("procon.protected.send", "vars.teamFactionOverride");
            }
        }

        
        public override void OnPlayerTeamChange(String soldierName, Int32 teamId, Int32 squadId) {
            DebugWrite("Entering OnPlayerTeamChange", 7);
            try {
                if (!_firstPlayerListComplete) 
                {
                    return;
                }
                if (_PlayerDictionary.ContainsKey(soldierName)) {
                    AdKatsPlayer aPlayer = _PlayerDictionary[soldierName];
                    if (aPlayer.RequiredTeam != null && 
                        aPlayer.RequiredTeam.TeamID != teamId &&
                        !PlayerIsAdmin(aPlayer) && 
                        _roundState == RoundState.Playing)
                    {
                        OnlineAdminSayMessage(soldierName + " attempted to team switch after being admin moved.");
                        PlayerTellMessage(soldierName, "You were moved to " + aPlayer.RequiredTeam.TeamKey + " team, please remain on that team.");
                        _threadMasterWaitHandle.WaitOne(500);
                        ExecuteCommand("procon.protected.send", "admin.movePlayer", soldierName, aPlayer.RequiredTeam.TeamID + "", "1", "true");
                    }
                    else
                    {
                        aPlayer.frostbitePlayerInfo.TeamID = teamId;
                        aPlayer.frostbitePlayerInfo.SquadID = squadId;
                    }
                }
                //When a player changes team, tell teamswap to recheck queues
                _TeamswapWaitHandle.Set();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling player team change.", e));
            }
            DebugWrite("Exiting OnPlayerTeamChange", 7);
        }

        public override void OnPlayerSquadChange(string soldierName, int teamId, int squadId)
        {
            DebugWrite("Entering OnPlayerSquadChange", 7);
            try
            {
                if (!_firstPlayerListComplete)
                {
                    return;
                }
                if (_PlayerDictionary.ContainsKey(soldierName))
                {
                    AdKatsPlayer aPlayer = _PlayerDictionary[soldierName];
                    aPlayer.frostbitePlayerInfo.TeamID = teamId;
                    aPlayer.frostbitePlayerInfo.SquadID = squadId;
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while handling player squad change.", e));
            }
            DebugWrite("Exiting OnPlayerSquadChange", 7);
        }

        public override void OnListPlayers(List<CPlayerInfo> players, CPlayerSubset cpsSubset) {
            DebugWrite("Entering OnListPlayers", 7);
            try {
                //Only handle the list if it is an "All players" list
                if (cpsSubset.Subset == CPlayerSubset.PlayerSubsetType.All) {
                    //Return if small duration (5 seconds) since last player list
                    if ((UtcDbTime() - _lastSuccessfulPlayerList) < TimeSpan.FromSeconds(5)) {
                        return;
                    }
                    //Only perform the following if all threads are ready
                    if (_threadsReady) {
                        QueuePlayerListForProcessing(players);
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured while listing players.", e));
            }
            DebugWrite("Exiting OnListPlayers", 7);
        }

        private void QueuePlayerListForProcessing(List<CPlayerInfo> players) {
            DebugWrite("Entering QueuePlayerListForProcessing", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue player list for processing", 6);
                    lock (_PlayerListProcessingQueue) {
                        _PlayerListProcessingQueue.Enqueue(players);
                        DebugWrite("Player list queued for processing", 6);
                        _PlayerProcessingWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing player list for processing.", e));
            }
            DebugWrite("Exiting QueuePlayerListForProcessing", 7);
        }

        private void QueuePlayerForRemoval(CPlayerInfo player) {
            DebugWrite("Entering QueuePlayerForRemoval", 7);
            try {
                if (_pluginEnabled && _firstPlayerListComplete) {
                    DebugWrite("Preparing to queue player list for processing", 6);
                    lock (_PlayerRemovalProcessingQueue) {
                        _PlayerRemovalProcessingQueue.Enqueue(player);
                        DebugWrite("Player removal queued for processing", 6);
                        _PlayerProcessingWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing player for removal.", e));
            }
            DebugWrite("Exiting QueuePlayerForRemoval", 7);
        }

        public void PlayerListingThreadLoop() {
            try {
                DebugWrite("PLIST: Starting Player Listing Thread", 1);
                Thread.CurrentThread.Name = "playerlisting";
                DateTime loopStart = UtcDbTime();
                while (true) {
                    try {
                        DebugWrite("PLIST: Entering Player Listing Thread Loop", 7);
                        if (!_pluginEnabled) {
                            DebugWrite("PLIST: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }

                        Boolean playerListFetched = false;
                        AdKatsPlayer pingPickedPlayer = null;

                        //Get all unparsed inbound lists
                        //Only allow player list fetching if the user list is already fetched
                        List<CPlayerInfo> inboundPlayerList = null;
                        if (_PlayerListProcessingQueue.Count > 0 && _firstUserListComplete) {
                            DebugWrite("PLIST: Preparing to lock player list queues to retrive new player lists", 7);
                            lock (_PlayerListProcessingQueue) {
                                DebugWrite("PLIST: Inbound player lists found. Grabbing.", 6);
                                while (_PlayerListProcessingQueue.Any()) {
                                    inboundPlayerList = _PlayerListProcessingQueue.Dequeue();
                                    playerListFetched = true;
                                    _firstPlayerListStarted = true;
                                }
                                //Clear the queue for next run
                                _PlayerListProcessingQueue.Clear();
                            }
                        }
                        else {
                            inboundPlayerList = new List<CPlayerInfo>();
                        }

                        //Get all unparsed inbound player removals
                        Queue<CPlayerInfo> inboundPlayerRemoval = null;
                        if (_PlayerRemovalProcessingQueue.Count > 0) {
                            DebugWrite("PLIST: Preparing to lock player removal queue to retrive new player removals", 7);
                            lock (_PlayerRemovalProcessingQueue) {
                                DebugWrite("PLIST: Inbound player removals found. Grabbing.", 6);
                                if (_PlayerRemovalProcessingQueue.Any()) {
                                    inboundPlayerRemoval = new Queue<CPlayerInfo>(_PlayerRemovalProcessingQueue.ToArray());
                                }
                                //Clear the queue for next run
                                _PlayerRemovalProcessingQueue.Clear();
                            }
                        }
                        else {
                            inboundPlayerRemoval = new Queue<CPlayerInfo>();
                        }

                        if (!inboundPlayerList.Any() && !inboundPlayerRemoval.Any() && !_PlayerRoleRefetch && !playerListFetched) {
                            DebugWrite("PLIST: No inbound player lists or removals found. Waiting for Input.", 5);
                            //Wait for input
                            if (!_firstPlayerListStarted)
                            {
                                ExecuteCommand("procon.protected.send", "admin.listPlayers", "all");
                                Thread.Sleep(1000);
                            }
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _PlayerProcessingWaitHandle.Reset();
                            _PlayerProcessingWaitHandle.WaitOne(TimeSpan.FromSeconds(60));
                            loopStart = UtcDbTime();
                            if (_firstPlayerListComplete) {
                                //Case where all players are gone after first player list
                                _lastSuccessfulPlayerList = UtcDbTime();
                            }
                            continue;
                        }

                        var removedPlayers = new List<string>();
                        lock (_PlayerDictionary)
                        {
                            //Firstly, go through removal queue, remove all names, and log them.
                            while (inboundPlayerRemoval.Any())
                            {
                                if (!_pluginEnabled)
                                {
                                    break;
                                }
                                CPlayerInfo playerInfo = inboundPlayerRemoval.Dequeue();
                                AdKatsPlayer aPlayer;
                                if (_PlayerDictionary.TryGetValue(playerInfo.SoldierName, out aPlayer)) {
                                    //Show leaving messages
                                    Boolean toldAdmins = false;
                                    if (!aPlayer.TargetedRecords.Any(aRecord => 
                                        aRecord.command_action.command_key == "player_kick" || 
                                        aRecord.command_action.command_key == "player_ban_temp" || 
                                        aRecord.command_action.command_key == "player_ban_perm")) {
                                        List<AdKatsRecord> meaningfulRecords = aPlayer.TargetedRecords.Where(
                                            aRecord =>
                                                aRecord.command_action.command_key != "banenforcer_enforce" &&
                                                aRecord.command_action.command_key != "player_changeip" &&
                                                aRecord.command_action.command_key != "player_changename" &&
                                                aRecord.command_action.command_key != "player_repboost" &&
                                                aRecord.command_action.command_key != "player_pm_send" &&
                                                aRecord.command_action.command_key != "player_pm_reply" &&
                                                aRecord.command_action.command_key != "player_pm_start" &&
                                                aRecord.command_action.command_key != "player_pm_transmit" &&
                                                aRecord.command_action.command_key != "player_pm_cancel" &&
                                                !aRecord.command_action.command_key.Contains("self_")).ToList();
                                        if (meaningfulRecords.Any())
                                        {
                                            List<String> types = (from record in meaningfulRecords select record.command_action.command_name).Distinct().ToList();
                                            String typeString = types.Aggregate("[", (current, type) => current + (type + ", "));
                                            typeString = typeString.Trim().TrimEnd(',') + "]";
                                            if (_ShowTargetedPlayerLeftNotification) 
                                            {
                                                toldAdmins = true;
                                                OnlineAdminSayMessage(aPlayer.GetVerboseName() + " left from " + GetPlayerTeamKey(aPlayer) + " " + typeString);
                                            }
                                            List<AdKatsRecord> reports = aPlayer.TargetedRecords.Where(aRecord => aRecord.command_type.command_key == "player_report" || aRecord.command_type.command_key == "player_calladmin").ToList();
                                            var reporters = new Dictionary<string, AdKatsPlayer>();
                                            foreach (AdKatsRecord report in reports.Where(report => report.source_player != null))
                                            {
                                                reporters[report.source_player.player_name] = report.source_player;
                                            }
                                            foreach (AdKatsPlayer player in reporters.Values)
                                            {
                                                PlayerSayMessage(player.player_name, "Player " + aPlayer.GetVerboseName() + " you reported has left the server.");
                                            }
                                        }
                                    }
                                    if (!toldAdmins && aPlayer.player_type == PlayerType.Spectator) {
                                        OnlineAdminSayMessage(((PlayerIsAdmin(aPlayer)) ? ("Admin ") : ("")) + aPlayer.GetVerboseName() + " stopped spectating the server.");
                                    }
                                    //Shut down any running conversations
                                    if (aPlayer.conversationPartner != null) {
                                        var partner = aPlayer.conversationPartner;
                                        if (PlayerIsExternal(aPlayer.conversationPartner))
                                        {
                                            QueueRecordForProcessing(new AdKatsRecord
                                            {
                                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                                server_id = partner.player_server.ServerID,
                                                record_orchestrate = true,
                                                command_type = GetCommandByKey("player_pm_cancel"),
                                                command_numeric = 0,
                                                target_name = partner.player_name,
                                                target_player = partner,
                                                source_name = aPlayer.player_name,
                                                source_player = aPlayer,
                                                record_message = aPlayer.GetVerboseName() + " has left their server. Private conversation closed."
                                            });
                                        }
                                        else
                                        {
                                            PlayerSayMessage(partner.player_name, aPlayer.GetVerboseName() + " has left the server. Private conversation closed.");
                                            partner.conversationPartner = null;
                                        }
                                        aPlayer.conversationPartner = null;
                                    }
                                    if ((_roundState == RoundState.Loaded || (_roundState == RoundState.Playing && _serverInfo.GetRoundElapsedTime().TotalMinutes < 2)) &&
                                        !PlayerIsAdmin(aPlayer)) 
                                    {
                                        _mapDetrimentIndex++;
                                    }
                                    //Remove from populators
                                    _populationPopulatingPlayers.Remove(aPlayer.player_name);
                                    //Add player to the left dictionary
                                    aPlayer.player_online = false;
                                    aPlayer.player_server = null;
                                    aPlayer.player_spawnedOnce = false;
                                    aPlayer.ClearPingEntries();
                                    aPlayer.RequiredTeam = null;
                                    DequeuePlayer(aPlayer);
                                    _PlayerLeftDictionary.Add(aPlayer.player_name, aPlayer);
                                }
                                RemovePlayerFromDictionary(playerInfo.SoldierName, false);
                                removedPlayers.Add(playerInfo.SoldierName);
                            }
                            var validPlayers = new List<String>();
                            if (inboundPlayerList.Count > 0) {
                                DebugWrite("Listing Players", 5);
                                //Reset the player counts of all teams and recount everything
                                //Loop over all players in the list
                                Int32 team1PC = 0;
                                Int32 team2PC = 0;
                                Int32 team3PC = 0;
                                Int32 team4PC = 0;

                                List<Double> durations = new List<Double>();
                                var trimmedInboundPlayers = inboundPlayerList.Where(player => !removedPlayers.Contains(player.SoldierName));
                                Int32 index = 0;
                                foreach (CPlayerInfo playerInfo in trimmedInboundPlayers) {
                                    index++;
                                    Stopwatch timer = new Stopwatch();
                                    timer.Start();
                                    if (!_pluginEnabled) {
                                        break;
                                    }
                                    //Check for glitched players
                                    if (String.IsNullOrEmpty(playerInfo.GUID)) {
                                        if ((UtcDbTime() - _lastGlitchedPlayerNotification).TotalMinutes > 5)
                                        {
                                            OnlineAdminSayMessage(playerInfo.SoldierName + " is glitched in the server. Their soldier is invalid.");
                                            ConsoleWarn(playerInfo.SoldierName + " is glitched in the server. Their soldier is invalid.");
                                            _lastGlitchedPlayerNotification = UtcDbTime();
                                        }
                                        continue;
                                    }
                                    validPlayers.Add(playerInfo.SoldierName);
                                    //Check if the player is already in the player dictionary
                                    AdKatsPlayer aPlayer = null;
                                    if (_PlayerDictionary.TryGetValue(playerInfo.SoldierName, out aPlayer)) {
                                        //They are
                                        if (aPlayer.frostbitePlayerInfo.Score != playerInfo.Score || aPlayer.frostbitePlayerInfo.Kills != playerInfo.Kills || aPlayer.frostbitePlayerInfo.Deaths != playerInfo.Deaths) {
                                            aPlayer.lastAction = UtcDbTime();
                                        }
                                        aPlayer.frostbitePlayerInfo = playerInfo;
                                        switch (aPlayer.frostbitePlayerInfo.Type)
                                        {
                                            case 0:
                                                aPlayer.player_type = PlayerType.Player;
                                                break;
                                            case 1:
                                                aPlayer.player_type = PlayerType.Spectator;
                                                break;
                                            case 2:
                                                aPlayer.player_type = PlayerType.CommanderPC;
                                                break;
                                            case 3:
                                                aPlayer.player_type = PlayerType.CommanderMobile;
                                                break;
                                            default:
                                                ConsoleError("Player type " + aPlayer.frostbitePlayerInfo.Type + " is not valid.");
                                                break;
                                        }
                                        Double ping = aPlayer.frostbitePlayerInfo.Ping;
                                        Boolean proconFetched = false;
                                        if (_attemptManualPingWhenMissing && ping < 0 && !String.IsNullOrEmpty(aPlayer.player_ip))
                                        {
                                            PingReply reply = null;
                                            try {
                                                reply = _pingProcessor.Send(aPlayer.player_ip);
                                            }
                                            catch (Exception e) {
                                                HandleException(new AdKatsException("Error fetching manual player ping.", e));
                                            }
                                            if (reply != null && reply.Status == IPStatus.Success) {
                                                ping = reply.RoundtripTime;
                                                proconFetched = true;
                                            }
                                            else
                                            {
                                                DebugWrite("Ping status for " + aPlayer.GetVerboseName() + ": " + reply.Status, 5);
                                                ping = -1;
                                            }
                                        }
                                        if (_roundState == RoundState.Playing) {
                                            aPlayer.AddPingEntry(ping);
                                            //Automatic ping kick
                                            if (_pingEnforcerSystemEnable && 
                                                aPlayer.player_type == PlayerType.Player && 
                                                !PlayerIsAdmin(aPlayer) && 
                                                !GetMatchingASPlayersOfGroup("whitelist_ping", aPlayer).Any() &&
                                                !_pingEnforcerIgnoreRoles.Contains(aPlayer.player_role.role_key) &&
                                                !(_pingEnforcerIgnoreUserList && FetchAllUserSoldiers().Any(sPlayer => sPlayer.player_guid == aPlayer.player_guid)))
                                            {
                                                var playerCount = _PlayerDictionary.Values.Count(player => player.player_type == PlayerType.Player);
                                                if (playerCount > _pingEnforcerTriggerMinimumPlayers) 
                                                {
                                                    Double currentTriggerMS = 1000;
                                                    //Get current ping limit
                                                    if (playerCount >= _serverInfo.InfoObject.MaxPlayerCount - 1) 
                                                    {
                                                        currentTriggerMS = _pingEnforcerFullTriggerMS;
                                                    }
                                                    else if (_populationStatus == PopulationState.High) 
                                                    {
                                                        currentTriggerMS = _pingEnforcerHighTriggerMS;
                                                    }
                                                    else if (_populationStatus == PopulationState.Medium) 
                                                    {
                                                        currentTriggerMS = _pingEnforcerMedTriggerMS;
                                                    }
                                                    else if (_populationStatus == PopulationState.Low) 
                                                    {
                                                        currentTriggerMS = _pingEnforcerLowTriggerMS;
                                                    }
                                                    //Warn players of limit and spikes
                                                    if (ping > currentTriggerMS)
                                                    {
                                                        if (aPlayer.player_pings_full &&
                                                            aPlayer.player_ping_avg < currentTriggerMS && 
                                                            ping > (aPlayer.player_ping_avg * 1.5))
                                                        {
                                                            PlayerSayMessage(aPlayer.player_name, "Warning, your ping is spiking. Current: [" + Math.Round(ping) + "ms] Avg: [" + Math.Round(aPlayer.player_ping_avg, 1) + "ms]" + ((proconFetched) ? ("[PR]") : ("")));
                                                        }
                                                        else {
                                                            PlayerSayMessage(aPlayer.player_name, "Warning, your ping is over the limit. [" + Math.Round(aPlayer.player_ping, 1) + "ms]" + ((proconFetched)?("[PR]"):("")));
                                                        }
                                                    }
                                                    //Are they over the limit, or missing
                                                    if (((aPlayer.player_ping_avg > currentTriggerMS && aPlayer.player_ping > aPlayer.player_ping_avg) || (_pingEnforcerKickMissingPings && aPlayer.player_ping_avg < 0)) && aPlayer.player_pings_full)
                                                    {
                                                        //Are they worse than the current picked player
                                                        if (pingPickedPlayer == null || (aPlayer.player_ping_avg > pingPickedPlayer.player_ping_avg && pingPickedPlayer.player_ping_avg > 0)) {
                                                            pingPickedPlayer = aPlayer;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else {
                                            aPlayer.ClearPingEntries();
                                        }
                                        //Automatic Dispersion for 6 and 7
                                        if (_isTestingAuthorized &&
                                            (_serverInfo.ServerName.Contains("#7") || _serverInfo.ServerName.Contains("#6") || _serverInfo.ServerName.Contains("EU #5")) && 
                                            !GetMatchingASPlayersOfGroup("blacklist_dispersion", aPlayer).Any()) {
                                            Boolean addDispersion = false;
                                            if (
                                                (aPlayer.frostbitePlayerInfo.Kdr > 2 && aPlayer.frostbitePlayerInfo.Kills > 45) || 
                                                aPlayer.frostbitePlayerInfo.Kdr > 15 ||
                                                (aPlayer.frostbitePlayerInfo.Kdr > 3 && aPlayer.frostbitePlayerInfo.Kills > 30))
                                            {
                                                if (_roundID != 0)
                                                {
                                                    IEnumerable<AdKatsRecord> locRecords = FetchRecentRecords(aPlayer.player_id, GetCommandByKey("player_log").command_id, 1000, 50, true, false).Where(aRecord => aRecord.record_message == "Dispersion Trigger" && aRecord.server_id == _serverInfo.ServerID);
                                                    if (!locRecords.Any(aRecord => aRecord.command_numeric == _roundID))
                                                    {
                                                        var triggerRecord = new AdKatsRecord
                                                        {
                                                            record_source = AdKatsRecord.Sources.InternalAutomated,
                                                            server_id = _serverInfo.ServerID,
                                                            command_type = GetCommandByKey("player_log"),
                                                            command_numeric = _roundID,
                                                            target_name = aPlayer.player_name,
                                                            target_player = aPlayer,
                                                            source_name = "DispersionManager",
                                                            record_message = "Dispersion Trigger"
                                                        };
                                                        //Automatic dispersion disabled
                                                        ///QueueRecordForProcessing(triggerRecord);
                                                        //OnlineAdminSayMessage(aPlayer.player_name + " hit a dispersion trigger. Not adding yet.");
                                                    }
                                                    if (locRecords.Count() > 3) {
                                                        addDispersion = true;
                                                    }
                                                }
                                            }
                                            else if (aPlayer.frostbitePlayerInfo.Kills > 70) {
                                                addDispersion = true;
                                            }
                                            if (addDispersion)
                                            {
                                                var record = new AdKatsRecord
                                                {
                                                    record_source = AdKatsRecord.Sources.InternalAutomated,
                                                    server_id = _serverInfo.ServerID,
                                                    command_type = GetCommandByKey("player_blacklistdisperse"),
                                                    command_numeric = 0,
                                                    target_name = aPlayer.player_name,
                                                    target_player = aPlayer,
                                                    source_name = "DispersionManager",
                                                    record_message = "Server Balance"
                                                };
                                                //Automatic dispersion disabled
                                                //QueueRecordForProcessing(record);
                                            }
                                        }
                                        if (_CMDRManagerEnable &&
                                            _firstPlayerListComplete &&
                                            (aPlayer.player_type == PlayerType.CommanderPC || aPlayer.player_type == PlayerType.CommanderMobile) &&
                                            _PlayerDictionary.Values.Count(player => player.player_type == PlayerType.Player) < (0.75 * _CMDRMinimumPlayers))
                                        {
                                            var record = new AdKatsRecord
                                            {
                                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                                server_id = _serverInfo.ServerID,
                                                command_type = GetCommandByKey("player_kick"),
                                                command_numeric = 0,
                                                target_name = aPlayer.player_name,
                                                target_player = aPlayer,
                                                source_name = "CMDRManager",
                                                record_message = "Commanders not allowed until " + _CMDRMinimumPlayers + " active players"
                                            };
                                            QueueRecordForProcessing(record);
                                        }
                                    }
                                    else {
                                        //Player is not already online, handle fetching
                                        //First check if the player is rejoining current session
                                        aPlayer = _PlayerLeftDictionary.Values.FirstOrDefault(oPlayer => oPlayer.player_guid == playerInfo.GUID);
                                        if (aPlayer != null) {
                                            DebugWrite("Player " + playerInfo.SoldierName + " rejoined the server.", 3);
                                            //Remove them from the left dictionary
                                            _PlayerLeftDictionary.Remove(playerInfo.SoldierName);
                                            //check for name changes
                                            if (!String.IsNullOrEmpty(playerInfo.SoldierName) && playerInfo.SoldierName != aPlayer.player_name)
                                            {
                                                aPlayer.player_name_previous = aPlayer.player_name;
                                                aPlayer.player_name = playerInfo.SoldierName;
                                                var record = new AdKatsRecord
                                                {
                                                    record_source = AdKatsRecord.Sources.InternalAutomated,
                                                    server_id = _serverInfo.ServerID,
                                                    command_type = GetCommandByKey("player_changename"),
                                                    command_numeric = 0,
                                                    target_name = aPlayer.player_name,
                                                    target_player = aPlayer,
                                                    source_name = "AdKats",
                                                    record_message = aPlayer.player_name_previous
                                                };
                                                QueueRecordForProcessing(record);
                                                DebugWrite(aPlayer.player_name_previous + " changed their name to " + playerInfo.SoldierName + ". Updating the database.", 2);
                                                if (_ShowPlayerNameChangeAnnouncement)
                                                {
                                                    OnlineAdminSayMessage(aPlayer.player_name_previous + " changed their name to " + playerInfo.SoldierName);
                                                }
                                                UpdatePlayer(aPlayer);
                                            }
                                            if (aPlayer.TargetedRecords.Any(aRecord => aRecord.command_action.command_key == "player_kick" && (UtcDbTime() - aRecord.record_time).TotalMinutes < 30) && aPlayer.TargetedRecords.All(aRecord => aRecord.command_action.command_key != "banenforcer_enforce"))
                                            {
                                                OnlineAdminSayMessage("Kicked player " + aPlayer.GetVerboseName() + " rejoined the server.");
                                            }
                                        }
                                        else
                                        {
                                            //If they aren't in the list, fetch their profile from the database
                                            aPlayer = FetchPlayer(true, false, false, null, -1, playerInfo.SoldierName, playerInfo.GUID, null);
                                            if (aPlayer == null)
                                            {
                                                //Do not handle the player if not returned
                                                continue;
                                            }
                                        }
                                        aPlayer.player_online = true;
                                        //Get their location
                                        QueuePlayerForIPInfoFetch(aPlayer);
                                        //Get their persona ID
                                        QueuePlayerForBattlelogInfoFetch(aPlayer);
                                        //Last Punishment
                                        var punishments = FetchRecentRecords(aPlayer.player_id, GetCommandByKey("player_punish").command_id, 1000, 1, true, false);
                                        if (punishments.Any())
                                        {
                                            aPlayer.LastPunishment = punishments.FirstOrDefault();
                                        }
                                        //Last Forgive
                                        var forgives = FetchRecentRecords(aPlayer.player_id, GetCommandByKey("player_forgive").command_id, 1000, 1, true, false);
                                        if (forgives.Any()) 
                                        {
                                            aPlayer.LastForgive = forgives.FirstOrDefault();
                                        }
                                        aPlayer.player_server = _serverInfo;
                                        //Add the frostbite player info
                                        aPlayer.frostbitePlayerInfo = playerInfo;
                                        String joinLocation = String.Empty;
                                        AdKatsTeam playerTeam = null;
                                        if (aPlayer.frostbitePlayerInfo != null) {
                                            _teamDictionary.TryGetValue(aPlayer.frostbitePlayerInfo.TeamID, out playerTeam);
                                        }
                                        switch (aPlayer.frostbitePlayerInfo.Type)
                                        {
                                            case 0:
                                                aPlayer.player_type = PlayerType.Player;
                                                if (playerTeam == null || playerTeam.TeamID == 0)
                                                {
                                                    joinLocation += "player";
                                                }
                                                else
                                                {
                                                    joinLocation += playerTeam.TeamKey + " player";
                                                }
                                                break;
                                            case 1:
                                                aPlayer.player_type = PlayerType.Spectator;
                                                joinLocation += "spectator";
                                                break;
                                            case 2:
                                                aPlayer.player_type = PlayerType.CommanderPC;
                                                joinLocation += "commander";
                                                break;
                                            case 3:
                                                aPlayer.player_type = PlayerType.CommanderMobile;
                                                if (playerTeam != null) {
                                                    joinLocation += playerTeam.TeamKey + " ";
                                                }
                                                joinLocation += "tablet commander";
                                                break;
                                            default:
                                                ConsoleError("Player type " + aPlayer.frostbitePlayerInfo.Type + " is not valid.");
                                                break;
                                        }
                                        if (_firstPlayerListComplete)
                                        {
                                            var isAdmin = PlayerIsAdmin(aPlayer);
                                            //Notify reputable players
                                            if ((isAdmin || aPlayer.player_aa) && _InformReputablePlayersOfAdminJoins)
                                            {
                                                List<AdKatsPlayer> reputablePlayers = _PlayerDictionary.Values.Where(iPlayer => iPlayer.player_reputation >= _reputationThresholdGood && !PlayerIsAdmin(iPlayer)).ToList();
                                                String message = ((isAdmin) ? ("Admin ") : ("Admin assistant ")) + aPlayer.GetVerboseName() + " joined the server as a " + joinLocation + ".";
                                                OnlineAdminSayMessage(message);
                                                foreach (var reputablePlayer in reputablePlayers)
                                                {
                                                    PlayerSayMessage(reputablePlayer.player_name, message);
                                                }
                                            }
                                            else if (aPlayer.player_type == PlayerType.Spectator)
                                            {
                                                OnlineAdminSayMessage(aPlayer.GetVerboseName() + " is now spectating the server.");
                                            }
                                            //If populating, add player
                                            if (_populationPopulating && 
                                                _populationStatus == PopulationState.Low &&
                                                aPlayer.player_type == PlayerType.Player && 
                                                _populationPopulatingPlayers.Count < _lowPopulationPlayerCount) 
                                            {
                                                _populationPopulatingPlayers[aPlayer.player_name] = aPlayer;
                                            }
                                            //Increment benefit index
                                            if ((_roundState == RoundState.Playing || _roundState == RoundState.Loaded) &&
                                                !PlayerIsAdmin(aPlayer)) 
                                            {
                                                _mapBenefitIndex++;
                                            }
                                        }
                                        //Set their last death/spawn times
                                        aPlayer.lastDeath = UtcDbTime();
                                        aPlayer.lastSpawn = UtcDbTime();
                                        aPlayer.lastAction = UtcDbTime();
                                        //Add them to the dictionary
                                        _PlayerDictionary.Add(playerInfo.SoldierName, aPlayer);
                                        //Update rep
                                        UpdatePlayerReputation(aPlayer, false);
                                        //If using ban enforcer, check the player's ban status
                                        if (_UseBanEnforcer)
                                        {
                                            QueuePlayerForBanCheck(aPlayer);
                                        }
                                        else if (_UseHackerChecker)
                                        {
                                            //Queue the player for a hacker check
                                            QueuePlayerForHackerCheck(aPlayer);
                                        }
                                    }
                                    if (aPlayer.player_type == PlayerType.Player)
                                    {
                                        switch (playerInfo.TeamID)
                                        {
                                            case 0:
                                                //Do nothing, team 0 is the joining team
                                                break;
                                            case 1:
                                                team1PC++;
                                                break;
                                            case 2:
                                                team2PC++;
                                                break;
                                            case 3:
                                                team3PC++;
                                                break;
                                            case 4:
                                                team4PC++;
                                                break;
                                            default:
                                                ConsoleError("Team ID " + playerInfo.TeamID + " for player " + playerInfo.SoldierName + " was invalid.");
                                                break;
                                        }
                                    }
                                    if (_CMDRManagerEnable && 
                                        _firstPlayerListComplete &&
                                        (aPlayer.player_type == PlayerType.CommanderPC || aPlayer.player_type == PlayerType.CommanderMobile) &&
                                        _PlayerDictionary.Values.Count(player => player.player_type == PlayerType.Player) < _CMDRMinimumPlayers) {
                                        var record = new AdKatsRecord
                                        {
                                            record_source = AdKatsRecord.Sources.InternalAutomated,
                                            server_id = _serverInfo.ServerID,
                                            command_type = GetCommandByKey("player_kick"),
                                            command_numeric = 0,
                                            target_name = aPlayer.player_name,
                                            target_player = aPlayer,
                                            source_name = "CMDRManager",
                                            record_message = "Commanders not allowed until " + _CMDRMinimumPlayers + " active players"
                                        };
                                        QueueRecordForProcessing(record);
                                    }
                                    timer.Stop();
                                    durations.Add(timer.Elapsed.TotalSeconds);
                                    if (!_firstPlayerListComplete)
                                    {
                                        ConsoleWrite(index + "/" + trimmedInboundPlayers.Count() + " players loaded. " + Math.Round(durations.Sum() / durations.Count, 2) + "s per player.");
                                    }
                                }
                                _teamDictionary[1].UpdatePlayerCount(team1PC);
                                _teamDictionary[2].UpdatePlayerCount(team2PC);
                                _teamDictionary[3].UpdatePlayerCount(team3PC);
                                _teamDictionary[4].UpdatePlayerCount(team4PC);
                                //Make sure the player dictionary is clean of any straglers
                                Int32 straglerCount = 0;
                                Int32 dicCount = _PlayerDictionary.Count;
                                foreach (string playerName in _PlayerDictionary.Keys.Where(playerName => !validPlayers.Contains(playerName)).ToList()) {
                                    straglerCount++;
                                    DebugWrite("PLIST: Removing " + playerName + " from current player list (VIA CLEANUP).", 4);
                                    AdKatsPlayer aPlayer;
                                    if (_PlayerDictionary.TryGetValue(playerName, out aPlayer))
                                    {
                                        //Shut down any running conversations
                                        if (aPlayer.conversationPartner != null)
                                        {
                                            var partner = aPlayer.conversationPartner;
                                            if (PlayerIsExternal(aPlayer.conversationPartner))
                                            {
                                                QueueRecordForProcessing(new AdKatsRecord
                                                {
                                                    record_source = AdKatsRecord.Sources.InternalAutomated,
                                                    server_id = partner.player_server.ServerID,
                                                    record_orchestrate = true,
                                                    command_type = GetCommandByKey("player_pm_cancel"),
                                                    command_numeric = 0,
                                                    target_name = partner.player_name,
                                                    target_player = partner,
                                                    source_name = aPlayer.player_name,
                                                    source_player = aPlayer,
                                                    record_message = aPlayer.GetVerboseName() + " has left their server. Private conversation closed."
                                                });
                                            }
                                            else
                                            {
                                                PlayerSayMessage(partner.player_name, aPlayer.GetVerboseName() + " has left the server. Private conversation closed.");
                                                partner.conversationPartner = null;
                                            }
                                            aPlayer.conversationPartner = null;
                                        }
                                        //Remove from populators
                                        _populationPopulatingPlayers.Remove(aPlayer.player_name);
                                        //Add player to the left dictionary
                                        aPlayer.player_online = false;
                                        aPlayer.player_server = null;
                                        aPlayer.player_spawnedOnce = false;
                                        aPlayer.ClearPingEntries();
                                        aPlayer.RequiredTeam = null;
                                        DequeuePlayer(aPlayer);
                                        _PlayerLeftDictionary.Add(aPlayer.player_name, aPlayer);
                                    }
                                    _PlayerDictionary.Remove(playerName);
                                }
                                if (straglerCount > 1 && straglerCount > (dicCount / 2)) {
                                    var record = new AdKatsRecord {
                                        record_source = AdKatsRecord.Sources.InternalAutomated,
                                        isDebug = true,
                                        server_id = _serverInfo.ServerID,
                                        command_type = GetCommandByKey("player_calladmin"),
                                        command_numeric = straglerCount,
                                        target_name = "Server",
                                        target_player = null,
                                        source_name = "AdKats",
                                        record_message = "Server Crashed (" + dicCount + " Players Lost)"
                                    };
                                    //Process the record
                                    QueueRecordForProcessing(record);
                                    ConsoleError(record.record_message);
                                    //Set round ended
                                    _roundState = RoundState.Ended;
                                    //Clear populators
                                    _populationPopulatingPlayers.Clear();
                                }
                            }
                            if (_PlayerRoleRefetch) {
                                //Update roles for all online players
                                foreach (AdKatsPlayer aPlayer in _PlayerDictionary.Values) {
                                    AssignPlayerRole(aPlayer);
                                }
                                _PlayerRoleRefetch = false;
                            }

                            if (_firstPlayerListComplete)
                            {
                                Int32 playerCount = _PlayerDictionary.Values.Count(player => player.player_type == PlayerType.Player);
                                if (playerCount < _lowPopulationPlayerCount)
                                {
                                    switch (_populationStatus)
                                    {
                                        case PopulationState.Unknown:
                                            _populationTransitionTime = UtcDbTime();
                                            OnlineAdminSayMessage("Server in populating mode.");
                                            break;
                                        case PopulationState.Low:
                                            //Current state
                                            _populationDurations[PopulationState.Low] += (UtcDbTime() - _populationUpdateTime);
                                            break;
                                        case PopulationState.Medium:
                                            _populationTransitionTime = UtcDbTime();
                                            _populationDurations[PopulationState.Medium] += (UtcDbTime() - _populationTransitionTime);
                                            OnlineAdminSayMessage("Server now in populating mode, with " + playerCount + " populators.");
                                            break;
                                        case PopulationState.High:
                                            _populationTransitionTime = UtcDbTime();
                                            _populationDurations[PopulationState.High] += (UtcDbTime() - _populationTransitionTime);
                                            OnlineAdminSayMessage("Server now in populating mode, with " + playerCount + " populators.");
                                            break;
                                        default:
                                            break;
                                    }
                                    if (!_populationPopulating)
                                    {
                                        _populationPopulatingPlayers.Clear();
                                        _populationPopulating = true;
                                        foreach (var popPlayer in _PlayerDictionary.Values.Where(player => player.player_type == PlayerType.Player).ToList())
                                        {
                                            _populationPopulatingPlayers[popPlayer.player_name] = popPlayer;
                                        }
                                    }
                                    _populationStatus = PopulationState.Low;
                                }
                                else if (playerCount < _highPopulationPlayerCount)
                                {
                                    switch (_populationStatus)
                                    {
                                        case PopulationState.Unknown:
                                            _populationTransitionTime = UtcDbTime();
                                            break;
                                        case PopulationState.Low:
                                            _populationTransitionTime = UtcDbTime();
                                            _populationDurations[PopulationState.Low] += (UtcDbTime() - _populationTransitionTime);
                                            break;
                                        case PopulationState.Medium:
                                            //Current state
                                            _populationDurations[PopulationState.Medium] += (UtcDbTime() - _populationUpdateTime);
                                            break;
                                        case PopulationState.High:
                                            _populationTransitionTime = UtcDbTime();
                                            _populationDurations[PopulationState.High] += (UtcDbTime() - _populationTransitionTime);
                                            break;
                                        default:
                                            break;
                                    }
                                    _populationStatus = PopulationState.Medium;
                                }
                                else
                                {
                                    switch (_populationStatus)
                                    {
                                        case PopulationState.Unknown:
                                            _populationTransitionTime = UtcDbTime();
                                            break;
                                        case PopulationState.Low:
                                            _populationTransitionTime = UtcDbTime();
                                            _populationDurations[PopulationState.Low] += (UtcDbTime() - _populationTransitionTime);
                                            break;
                                        case PopulationState.Medium:
                                            _populationTransitionTime = UtcDbTime();
                                            _populationDurations[PopulationState.Medium] += (UtcDbTime() - _populationTransitionTime);
                                            break;
                                        case PopulationState.High:
                                            //Current state
                                            _populationDurations[PopulationState.High] += (UtcDbTime() - _populationUpdateTime);
                                            break;
                                        default:
                                            break;
                                    }
                                    if (_populationPopulating)
                                    {
                                        foreach (var popPlayer in _populationPopulatingPlayers.Values.Where(aPlayer =>
                                                                                                                aPlayer.player_online &&
                                                                                                                _PlayerDictionary.ContainsKey(aPlayer.player_name) &&
                                                                                                                aPlayer.player_type == PlayerType.Player))
                                        {
                                            QueueRecordForProcessing(new AdKatsRecord
                                            {
                                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                                server_id = _serverInfo.ServerID,
                                                command_type = GetCommandByKey("player_population_success"),
                                                command_numeric = 0,
                                                target_name = popPlayer.player_name,
                                                target_player = popPlayer,
                                                source_name = "PopulationManager",
                                                record_message = "Populated Server " + _serverInfo.ServerID
                                            });
                                        }
                                        _populationPopulatingPlayers.Clear();
                                        _populationPopulating = false;
                                    }
                                    _populationStatus = PopulationState.High;
                                }
                                _populationUpdateTime = UtcDbTime();
                            }
                        }

                        if (pingPickedPlayer != null)
                        {
                            var record = new AdKatsRecord
                            {
                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                server_id = _serverInfo.ServerID,
                                command_type = GetCommandByKey("player_kick"),
                                command_numeric = 0,
                                target_name = pingPickedPlayer.player_name,
                                target_player = pingPickedPlayer,
                                source_name = "PingEnforcer",
                                record_message = _pingEnforcerMessagePrefix + " " + ((pingPickedPlayer.player_ping_avg > 0) ? ("Cur:[" + Math.Round(pingPickedPlayer.player_ping) + "ms] Avg:[" + Math.Round(pingPickedPlayer.player_ping_avg) + "ms]") : ("[Missing]"))
                            };
                            QueueRecordForProcessing(record);
                            OnlineAdminSayMessage((++_pingKicksThisRound) + " players kicked for ping during this round. " + Math.Round(++_pingKicksTotal / (UtcDbTime() - _AdKatsRunningTime).TotalHours, 2) + " kicks/hour.");
                        }

                        //Update last successful player list time
                        _lastSuccessfulPlayerList = UtcDbTime();
                        //Set required handles 
                        _PlayerListUpdateWaitHandle.Set();
                        _TeamswapWaitHandle.Set();
                        //Push online player subscription
                        if (playerListFetched && _pluginEnabled)
                        {
                            foreach (AdKatsClient client in 
                                    _subscribedClients.Where(aClient => 
                                        aClient.SubscriptionGroup == "OnlineSoldiers" && 
                                        aClient.SubscriptionEnabled).ToList()) {
                                SendOnlineSoldiers(client);
                            }
                        }
                        if (!_firstPlayerListComplete && playerListFetched && _pluginEnabled) 
                        {
                            _AdKatsRunningTime = UtcDbTime();
                            _firstPlayerListComplete = true;
                            OnlineAdminSayMessage("Player listing complete [" + _PlayerDictionary.Count + " players]. Performing final startup.");
                            ConsoleSuccess("Player listing complete [" + _PlayerDictionary.Count + " players].");

                            ConsoleInfo("Performing final startup.");
                            //Register external plugin commands
                            RegisterCommand(_issueCommandMatchCommand);
                            RegisterCommand(_fetchAuthorizedSoldiersMatchCommand);
                            _threadMasterWaitHandle.WaitOne(500);

                            OnlineAdminTellMessage("AdKats startup complete [" + FormatTimeString(UtcDbTime() - _AdKatsStartTime, 3) + "]. Commands are now online.");
                            foreach (String playerName in _PlayersRequestingCommands) {
                                AdKatsPlayer aPlayer;
                                if (_PlayerDictionary.TryGetValue(playerName, out aPlayer)) {
                                    if (!PlayerIsAdmin(aPlayer)) {
                                        PlayerTellMessage(aPlayer.player_name, "Commands are now online. Thank you for your patience.");
                                    }
                                }
                            }
                            ConsoleSuccess("AdKats " + GetPluginVersion() + " startup complete [" + FormatTimeString(UtcDbTime() - _AdKatsStartTime, 3) + "]. Commands are now online.");
                        }
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            ConsoleWarn("player listing thread was force aborted. Exiting.");
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in player listing thread. Skipping loop.", e));
                    }
                }
                DebugWrite("PLIST: Ending Player Listing Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in player listing thread.", e));
            }
        }

        public override void OnPunkbusterPlayerInfo(CPunkbusterInfo cpbiPlayer) {
            try {
                DebugWrite("OPPI: OnPunkbusterPlayerInfo fired!", 7);
                AdKatsPlayer aPlayer;
                if (_PlayerDictionary.TryGetValue(cpbiPlayer.SoldierName, out aPlayer)) {
                    DebugWrite("OPPI: PB player already in the player list.", 7);
                    Boolean updatePlayer = false;
                    //Update the player with pb info
                    aPlayer.PBPlayerInfo = cpbiPlayer;
                    aPlayer.player_pbguid = cpbiPlayer.GUID;
                    aPlayer.player_slot = cpbiPlayer.SlotID;
                    String player_ip = cpbiPlayer.Ip.Split(':')[0];
                    if (player_ip != aPlayer.player_ip && !String.IsNullOrEmpty(player_ip)) {
                        updatePlayer = true;
                        if (!String.IsNullOrEmpty(aPlayer.player_ip)) {
                            DebugWrite(aPlayer.GetVerboseName() + " changed their IP from " + aPlayer.player_ip + " to " + player_ip + ". Updating the database.", 2);
                            var record = new AdKatsRecord {
                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                server_id = _serverInfo.ServerID,
                                command_type = GetCommandByKey("player_changeip"),
                                command_numeric = 0,
                                target_name = aPlayer.player_name,
                                target_player = aPlayer,
                                source_name = "AdKats",
                                record_message = aPlayer.player_ip
                            };
                            QueueRecordForProcessing(record);
                        }
                    }
                    aPlayer.player_ip = player_ip;
                    //Update IP location
                    QueuePlayerForIPInfoFetch(aPlayer);
                    if (updatePlayer) {
                        DebugWrite("OPPI: Queueing existing player " + aPlayer.GetVerboseName() + " for update.", 4);
                        UpdatePlayer(aPlayer);
                        //If using ban enforcer, queue player for update
                        if (_UseBanEnforcer) {
                            QueuePlayerForBanCheck(aPlayer);
                        }
                    }
                }
                DebugWrite("OPPI: Player slot: " + cpbiPlayer.SlotID, 7);
                DebugWrite("OPPI: OnPunkbusterPlayerInfo finished!", 7);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured while processing punkbuster info.", e));
            }
        }

        private void FetchAllAccess(Boolean async) {
            if (async) {
                _AccessFetchWaitHandle.Set();
            }
            else if (_threadsReady) {
                lock (_userCache) {
                    DateTime start = UtcDbTime();
                    FetchCommands();
                    DebugWrite("Command fetch took " + (UtcDbTime() - start).TotalMilliseconds + "ms.", 4);
                    start = UtcDbTime();
                    FetchRoles();
                    DebugWrite("Role fetch took " + (UtcDbTime() - start).TotalMilliseconds + "ms.", 4);
                    start = UtcDbTime();
                    if (!_firstUserListComplete)
                    {
                        OnlineAdminSayMessage("Fetching user list.");
                        ConsoleInfo("Fetching user list.");
                    }
                    FetchUserList();
                    DebugWrite("User fetch took " + (UtcDbTime() - start).TotalMilliseconds + "ms.", 4);
                    start = UtcDbTime();
                }
            }
        }

        private void AccessFetchingThreadLoop() {
            try {
                DebugWrite("FACC: Starting Access Fetching Thread", 1);
                Thread.CurrentThread.Name = "AccessFetching";
                DateTime loopStart = UtcDbTime();
                while (true) {
                    try {
                        DebugWrite("FACC: Entering Access Fetching Thread Loop", 7);
                        if (!_pluginEnabled) {
                            DebugWrite("FACC: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }

                        FetchAllAccess(false);

                        DebugWrite("FACC: Access fetch waiting for Input.", 5);
                        if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                            DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                        _AccessFetchWaitHandle.Reset();
                        _AccessFetchWaitHandle.WaitOne(TimeSpan.FromSeconds(300));
                        loopStart = UtcDbTime();
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            ConsoleWarn("Access Fetching thread was force aborted. Exiting.");
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in Access Fetching thread. Skipping loop.", e));
                    }
                }
                DebugWrite("FACC: Ending Access Fetching Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in Access Fetching thread.", e));
            }
        }

        private void StartRoundTicketLogger(Int32 startingSeconds)
        {
            try
            {
                if (!_pluginEnabled || !_threadsReady)
                {
                    return;
                }
                var roundLoggerThread = new Thread(new ThreadStart(delegate
                {
                    try
                    {
                        Thread.CurrentThread.Name = "roundticketlogger";
                        Int32 TPCSCounter = 0;
                        Boolean TPCSActionTaken = false;
                        Int32 roundTimeSeconds = startingSeconds;
                        using (MySqlConnection connection = GetDatabaseConnection())
                        {
                            using (MySqlCommand command = connection.CreateCommand())
                            {
                                command.CommandText = @"
                                SELECT
	                                IFNULL(MAX(`round_id`), 0) AS `max_round_id`
                                FROM
	                                `tbl_extendedroundstats`
                                WHERE 
                                    `server_id` = @server_id";
                                command.Parameters.AddWithValue("server_id", _serverInfo.ServerID);
                                using (MySqlDataReader reader = SafeExecuteReader(command))
                                {
                                    if (reader.Read())
                                    {
                                        Int32 oldRoundID = reader.GetInt32("max_round_id");
                                        _roundID = oldRoundID + 1;
                                        DebugWrite("New Round. ExtendedRoundID is " + _roundID, 2);
                                    }
                                    else
                                    {
                                        _roundID = 1;
                                    }
                                }
                            }
                        }
                        ProconChatWrite(BoldMessage("New Round. ExtendedRoundID is " + _roundID));

                        var watch = new Stopwatch();
                        while (true)
                        {
                            if (!_pluginEnabled)
                            {
                                break;
                            }
                            AdKatsTeam team1 = _teamDictionary[1];
                            AdKatsTeam team2 = _teamDictionary[2];
                            watch.Reset();
                            watch.Start();
                            if (_roundState == RoundState.Loaded)
                            {
                                _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(2));
                                continue;
                            }
                            if (_roundState == RoundState.Ended ||
                                !_pluginEnabled ||
                                (team1.TeamPlayerCount == 0 && team1.Populated && team2.TeamPlayerCount == 0 && team2.Populated))
                            {
                                break;
                            }

                            using (MySqlConnection connection = GetDatabaseConnection())
                            {
                                using (MySqlCommand command = connection.CreateCommand())
                                {
                                    //Set the insert command structure
                                    command.CommandText = @"
                                    INSERT INTO 
                                        `tbl_extendedroundstats` 
                                    (
                                        `server_id`, 
                                        `round_id`, 
                                        `round_elapsedTimeSec`, 
                                        `team1_count`, 
                                        `team2_count`, 
                                        `team1_score`, 
                                        `team2_score`, 
                                        `team1_spm`, 
                                        `team2_spm`, 
                                        `team1_tickets`, 
                                        `team2_tickets`,
                                        `team1_tpm`, 
                                        `team2_tpm`,
                                        `roundstat_time`
                                    ) 
                                    VALUES 
                                    (
                                        @server_id, 
                                        @round_id, 
                                        @round_elapsedTimeSec, 
                                        @team1_count, 
                                        @team2_count, 
                                        @team1_score, 
                                        @team2_score, 
                                        @team1_spm, 
                                        @team2_spm, 
                                        @team1_tickets, 
                                        @team2_tickets,
                                        @team1_tpm, 
                                        @team2_tpm,
                                        UTC_TIMESTAMP()
                                    )";
                                    command.Parameters.AddWithValue("@server_id", _serverInfo.ServerID);
                                    command.Parameters.AddWithValue("@round_id", _roundID);
                                    command.Parameters.AddWithValue("@round_elapsedTimeSec", roundTimeSeconds);
                                    command.Parameters.AddWithValue("@team1_count", team1.TeamPlayerCount);
                                    command.Parameters.AddWithValue("@team2_count", team2.TeamPlayerCount);
                                    command.Parameters.AddWithValue("@team1_score", Math.Round(team1.TeamTotalScore, 2));
                                    command.Parameters.AddWithValue("@team2_score", Math.Round(team2.TeamTotalScore, 2));
                                    command.Parameters.AddWithValue("@team1_spm", Math.Round(team1.TeamScoreDifferenceRate, 2));
                                    command.Parameters.AddWithValue("@team2_spm", Math.Round(team2.TeamScoreDifferenceRate, 2));
                                    command.Parameters.AddWithValue("@team1_tickets", team1.TeamTicketCount);
                                    command.Parameters.AddWithValue("@team2_tickets", team2.TeamTicketCount);
                                    command.Parameters.AddWithValue("@team1_tpm", Math.Round(team1.TeamTicketDifferenceRate, 2));
                                    command.Parameters.AddWithValue("@team2_tpm", Math.Round(team2.TeamTicketDifferenceRate, 2));
                                    if (team1.TeamPlayerCount > 0 || team2.TeamPlayerCount > 0)
                                    {
                                        try
                                        {
                                            //Attempt to execute the query
                                            if (SafeExecuteNonQuery(command) > 0)
                                            {
                                                DebugWrite("round stat pushed to database", 5);
                                            }
                                        }
                                        catch (Exception e) {
                                            HandleException(new AdKatsException("Invalid round stats when posting. " +
                                                FormatTimeString(_serverInfo.GetRoundElapsedTime(), 2) + "|" +

                                                team1.TeamPlayerCount + "|" + 

                                                team2.TeamPlayerCount + "|" + 

                                                Math.Round(team1.TeamTotalScore, 2) + "|" +
 
                                                Math.Round(team2.TeamTotalScore, 2) + "|" +

                                                Math.Round(team1.TeamScoreDifferenceRate, 2) + "|" +
                                                team1.TeamScoreDifferenceRate + "|" +

                                                Math.Round(team2.TeamScoreDifferenceRate, 2) + "|" +
                                                team2.TeamScoreDifferenceRate + "|" + 

                                                team1.TeamTicketCount + "|" + 

                                                team2.TeamTicketCount + "|" +

                                                Math.Round(team1.TeamTicketDifferenceRate, 2) + "|" +
                                                team1.TeamTicketDifferenceRate + "|" +

                                                Math.Round(team2.TeamTicketDifferenceRate, 2) + "|" +
                                                team2.TeamTicketDifferenceRate));
                                        }
                                    }
                                }
                            }

                            watch.Stop();
                            if (watch.Elapsed.TotalSeconds < 30)
                            {
                                _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(30) - watch.Elapsed);
                            }
                            roundTimeSeconds += 30;
                        }
                    }
                    catch (Exception e)
                    {
                        HandleException(new AdKatsException("Error in round stat logger thread", e));
                    }
                    LogThreadExit();
                }));

                if (_aliveThreads.Values.All(thread => thread.Name != "roundticketlogger"))
                {
                    //Start the thread
                    StartAndLogThread(roundLoggerThread);
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while starting round ticket logger", e));
            }
        }

        public override void OnServerInfo(CServerInfo serverInfo) {
            DebugWrite("Entering OnServerInfo", 7);
            try
            {
                if (_pluginEnabled) {
                    lock (_serverInfo) {
                        if (serverInfo != null) {
                            //Get the server info
                            _serverInfo.SetInfoObject(serverInfo);
                            if (serverInfo.TeamScores != null) {
                                List<TeamScore> listCurrTeamScore = serverInfo.TeamScores;
                                //During round change, teams don't exist
                                if (listCurrTeamScore.Count > 0 && _roundState == RoundState.Playing) {
                                    foreach (TeamScore score in listCurrTeamScore) {
                                        AdKatsTeam currentTeam;
                                        if (_teamDictionary.TryGetValue(score.TeamID, out currentTeam)) {
                                            currentTeam.UpdateTicketCount(score.Score);
                                            currentTeam.UpdateTotalScore(_PlayerDictionary.Values.Where(aPlayer => aPlayer.frostbitePlayerInfo.TeamID == score.TeamID).Aggregate<AdKatsPlayer, double>(0, (current, aPlayer) => current + aPlayer.frostbitePlayerInfo.Score));
                                        }
                                        else {
                                            ConsoleError("Team ID " + score.TeamID + " could not be recognized.");
                                        }
                                    }
                                }
                                else {
                                    DebugWrite("Server info fired while changing rounds, no teams to parse.", 5);
                                }
                            }
                            if (!(_teamDictionary.ContainsKey(1) && _teamDictionary.ContainsKey(2))) {
                                ConsoleError("Unable to process server info. Teams not loaded.");
                                return;
                            }
                            AdKatsTeam team1 = _teamDictionary[1];
                            AdKatsTeam team2 = _teamDictionary[2];
                            AdKatsTeam winningTeam = null;
                            AdKatsTeam losingTeam = null;
                            AdKatsTeam baserapingTeam = null;
                            AdKatsTeam baserapedTeam = null;
                            if (team1.TeamTicketCount > team2.TeamTicketCount)
                            {
                                winningTeam = team1;
                                losingTeam = team2;
                            }
                            else
                            {
                                winningTeam = team2;
                                losingTeam = team1;
                            }
                            if (_DisplayTicketRatesInProconChat && _roundState == RoundState.Playing)
                            {
                                String flagMessage = "";
                                if (_serverInfo.InfoObject.GameMode == "ConquestLarge0" ||
                                    _serverInfo.InfoObject.GameMode == "Chainlink0")
                                {
                                    AdKatsTeam flagWinningTeam, flagLosingTeam;
                                    if (team2.TeamAdjustedTicketDifferenceRate < team1.TeamAdjustedTicketDifferenceRate)
                                    {
                                        //Team1 has more flags than Team2
                                        flagWinningTeam = team1;
                                        flagLosingTeam = team2;
                                    }
                                    else
                                    {
                                        //Team2 has more flags than Team1
                                        flagWinningTeam = team2;
                                        flagLosingTeam = team1;
                                    }
                                    Double winRate = flagWinningTeam.TeamAdjustedTicketDifferenceRate;
                                    Double loseRate = flagLosingTeam.TeamAdjustedTicketDifferenceRate;
                                    if (_serverInfo.InfoObject.GameMode == "ConquestLarge0" && _gameVersion == GameVersion.BF4)
                                    {
                                        if (winRate > -25 && loseRate > -25)
                                        {
                                            flagMessage = " | Flags appear equal for both teams.";
                                        }
                                        else if (loseRate <= -25 && loseRate > -34)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by 1 flag.";
                                        }
                                        else if (loseRate <= -34 && loseRate > -38)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by 1-3 flags.";
                                        }
                                        else if (loseRate <= -38 && loseRate > -44)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by 3 flags.";
                                        }
                                        else if (loseRate <= -44 && loseRate > -48)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by 3-5 flags.";
                                        }
                                        else if (loseRate <= -48 && loseRate > -54)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by 5 flags.";
                                        }
                                        else if (loseRate <= -54 && loseRate > -58)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by 5-7 flags.";
                                        }
                                        else if (loseRate <= -58 && loseRate > -64)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by 7 flags.";
                                        }
                                        else if (loseRate <= -64 && loseRate > -68)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by 7-9 flags.";
                                        }
                                        else if (loseRate <= -68 && loseRate > -74)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by 9 flags.";
                                        }
                                        else if (loseRate < -74)
                                        {
                                            flagMessage = " | Appears " + flagWinningTeam.TeamKey + " is up by many flags.";
                                        }
                                    }
                                    else
                                    {
                                        flagMessage = " | " + _serverInfo.InfoObject.GameMode;
                                    }
                                }
                                if ((UtcDbTime() - _LastTicketRateDisplay).TotalSeconds > 55 || _currentFlagMessage != flagMessage)
                                {
                                    _LastTicketRateDisplay = UtcDbTime();
                                    _currentFlagMessage = flagMessage;
                                    ProconChatWrite(BoldMessage(team1.TeamKey + " Rate: " + Math.Round(team1.TeamTicketDifferenceRate, 2) + " (" + Math.Round(team1.TeamAdjustedTicketDifferenceRate, 2) + ") t/m | " + team2.TeamKey + " Rate: " + Math.Round(team2.TeamTicketDifferenceRate, 2) + " (" + Math.Round(team2.TeamAdjustedTicketDifferenceRate, 2) + ") t/m" + flagMessage));
                                }
                            }
                            if (team1.TeamTicketCount >= 0 && team2.TeamTicketCount >= 0) {
                                _lowestTicketCount = (team1.TeamTicketCount < team2.TeamTicketCount) ? (team1.TeamTicketCount) : (team2.TeamTicketCount);
                                _highestTicketCount = (team1.TeamTicketCount > team2.TeamTicketCount) ? (team1.TeamTicketCount) : (team2.TeamTicketCount);
                            }
                            if (_surrenderAutoEnable && 
                                _roundState == RoundState.Playing && 
                                !_endingRound && 
                                (UtcDbTime() - _lastAutoSurrenderTriggerTime).TotalSeconds > 9.5 && 
                                _serverInfo.GetRoundElapsedTime().TotalSeconds > 60 &&
                                _PlayerDictionary.Values.Count(player => player.player_type == PlayerType.Player) >= _surrenderAutoMinimumPlayers)
                            {
                                if (_surrenderAutoUseMetroValues &&
                                    Math.Abs(winningTeam.TeamTicketCount - losingTeam.TeamTicketCount) > 100 &&
                                    losingTeam.TeamTicketCount > 100 &&
                                    winningTeam.TeamTicketDifferenceRate < 0 &&
                                    losingTeam.TeamTicketDifferenceRate < 0) {
                                    Int32 requiredTriggers = 20 - ((losingTeam.TeamTicketCount <= 500)?((500 - losingTeam.TeamTicketCount) / 30):(0));
                                    if ((losingTeam.TeamAdjustedTicketDifferenceRate < -40 && winningTeam.TeamAdjustedTicketDifferenceRate > -5)) 
                                    {
                                        _lastAutoSurrenderTriggerTime = UtcDbTime();
                                        if (++_surrenderAutoTriggerCountCurrent >= requiredTriggers)
                                        {
                                            baserapingTeam = winningTeam;
                                            baserapedTeam = losingTeam;
                                        }
                                        else
                                        {
                                            if(_surrenderAutoTriggerCountCurrent % 5 == 0 || _surrenderAutoTriggerCountCurrent == 1)
                                                OnlineAdminSayMessage("Preparing to fire auto-" + ((_surrenderAutoNukeWinning) ? ("nuke") : ("surrender")) + ". Trigger " + _surrenderAutoTriggerCountCurrent + "/" + requiredTriggers + ".");
                                        }
                                    }
                                    else
                                    {
                                        if (_surrenderAutoTriggerCountCurrent > 0)
                                        {
                                            OnlineAdminSayMessage("Auto-" + ((_surrenderAutoNukeWinning) ? ("nuke") : ("surrender")) + " cancelled.");
                                        }
                                        _surrenderAutoTriggerCountCurrent = 0;
                                    }
                                }
                                else if (_surrenderAutoUseLockerValues &&
                                    Math.Abs(winningTeam.TeamTicketCount - losingTeam.TeamTicketCount) > 100 && 
                                    losingTeam.TeamTicketCount > 100 &&
                                    winningTeam.TeamTicketDifferenceRate < 0 &&
                                    losingTeam.TeamTicketDifferenceRate < 0)
                                {
                                    if ((losingTeam.TeamAdjustedTicketDifferenceRate < -50 && winningTeam.TeamAdjustedTicketDifferenceRate > -5))
                                    {
                                        _lastAutoSurrenderTriggerTime = UtcDbTime();
                                        if (++_surrenderAutoTriggerCountCurrent >= 10)
                                        {
                                            baserapingTeam = winningTeam;
                                            baserapedTeam = losingTeam;
                                        }
                                        else
                                        {
                                            if (_surrenderAutoTriggerCountCurrent % 5 == 0 || _surrenderAutoTriggerCountCurrent == 1)
                                                OnlineAdminSayMessage("Preparing to fire auto-" + ((_surrenderAutoNukeWinning) ? ("nuke") : ("surrender")) + ". Trigger " + _surrenderAutoTriggerCountCurrent + "/10.");
                                        }
                                    }
                                    else
                                    {
                                        if (_surrenderAutoTriggerCountCurrent > 0)
                                        {
                                            OnlineAdminSayMessage("Auto-" + ((_surrenderAutoNukeWinning) ? ("nuke") : ("surrender")) + " cancelled.");
                                        }
                                        _surrenderAutoTriggerCountCurrent = 0;
                                    }
                                }
                                else {
                                    if (Math.Abs(team1.TeamTicketCount - team2.TeamTicketCount) > _surrenderAutoMinimumTicketGap) {
                                        if (_surrenderAutoUseAdjustedTicketRates)
                                        {
                                            if (winningTeam.TeamAdjustedTicketDifferenceRate < _surrenderAutoWinningRateMax &&
                                                winningTeam.TeamAdjustedTicketDifferenceRate > _surrenderAutoWinningRateMin &&
                                                losingTeam.TeamAdjustedTicketDifferenceRate < _surrenderAutoLosingRateMax &&
                                                losingTeam.TeamAdjustedTicketDifferenceRate > _surrenderAutoLosingRateMin)
                                            {
                                                _lastAutoSurrenderTriggerTime = UtcDbTime();
                                                if (++_surrenderAutoTriggerCountCurrent >= _surrenderAutoTriggerCountToSurrender) 
                                                {
                                                    baserapingTeam = winningTeam;
                                                    baserapedTeam = losingTeam;
                                                }
                                                else 
                                                {
                                                    if (_surrenderAutoTriggerCountCurrent % 5 == 0 || _surrenderAutoTriggerCountCurrent == 1)
                                                        OnlineAdminSayMessage("Preparing to fire auto-" + ((_surrenderAutoNukeWinning) ? ("nuke") : ("surrender")) + ". Trigger " + _surrenderAutoTriggerCountCurrent + "/" + _surrenderAutoTriggerCountToSurrender + ".");
                                                }
                                            }
                                            else
                                            {
                                                if (_surrenderAutoTriggerCountCurrent > 0)
                                                {
                                                    OnlineAdminSayMessage("Auto-" + ((_surrenderAutoNukeWinning) ? ("nuke") : ("surrender")) + " cancelled.");
                                                }
                                                _surrenderAutoTriggerCountCurrent = 0;
                                            }
                                        }
                                        else
                                        {
                                            if (winningTeam.TeamTicketDifferenceRate < _surrenderAutoWinningRateMax &&
                                                winningTeam.TeamTicketDifferenceRate > _surrenderAutoWinningRateMin &&
                                                losingTeam.TeamTicketDifferenceRate < _surrenderAutoLosingRateMax &&
                                                losingTeam.TeamTicketDifferenceRate > _surrenderAutoLosingRateMin)
                                            {
                                                _lastAutoSurrenderTriggerTime = UtcDbTime();
                                                if (++_surrenderAutoTriggerCountCurrent >= _surrenderAutoTriggerCountToSurrender)
                                                {
                                                    baserapingTeam = winningTeam;
                                                    baserapedTeam = losingTeam;
                                                }
                                                else
                                                {
                                                    if (_surrenderAutoTriggerCountCurrent % 5 == 0 || _surrenderAutoTriggerCountCurrent == 1)
                                                        OnlineAdminSayMessage("Preparing to fire auto-" + ((_surrenderAutoNukeWinning) ? ("nuke") : ("surrender")) + ". Trigger " + _surrenderAutoTriggerCountCurrent + "/" + _surrenderAutoTriggerCountToSurrender + ".");
                                                }
                                            }
                                            else
                                            {
                                                if (_surrenderAutoTriggerCountCurrent > 0)
                                                {
                                                    OnlineAdminSayMessage("Auto-" + ((_surrenderAutoNukeWinning) ? ("nuke") : ("surrender")) + " cancelled.");
                                                }
                                                _surrenderAutoTriggerCountCurrent = 0;
                                            }
                                        }
                                    }
                                    else {
                                        _surrenderAutoTriggerCountCurrent = 0;
                                    }
                                }
                                if (baserapingTeam != null)
                                {
                                    if (_surrenderAutoNukeWinning) {
                                        var autoNukeMessage = _surrenderAutoNukeMessage.Replace("%WinnerName%", baserapingTeam.TeamName);
                                        QueueRecordForProcessing(new AdKatsRecord {
                                            record_source = AdKatsRecord.Sources.InternalAutomated,
                                            server_id = _serverInfo.ServerID,
                                            command_type = GetCommandByKey("server_nuke"),
                                            command_numeric = baserapingTeam.TeamID,
                                            target_name = baserapingTeam.TeamName,
                                            source_name = "RoundManager",
                                            record_message = autoNukeMessage
                                        });
                                    }
                                    else if (_surrenderAutoTriggerVote)
                                    {
                                        QueueRecordForProcessing(new AdKatsRecord
                                        {
                                            record_source = AdKatsRecord.Sources.InternalAutomated,
                                            server_id = _serverInfo.ServerID,
                                            command_type = GetCommandByKey("self_votenext"),
                                            command_numeric = 0,
                                            target_name = "RoundManager",
                                            source_name = "RoundManager",
                                            record_message = "Auto-Starting Surrender Vote"
                                        });
                                    }
                                    else if (!_endingRound)
                                    {
                                        _endingRound = true;
                                        _surrenderAutoSucceeded = true;
                                        var roundEndDelayThread = new Thread(new ThreadStart(delegate
                                        {
                                            DebugWrite("Starting a round end delay thread.", 5);
                                            try
                                            {
                                                Thread.CurrentThread.Name = "roundenddelay";
                                                var autoSurrenderMessage = _surrenderAutoMessage.Replace("%WinnerName%", baserapingTeam.TeamName);
                                                for (int i = 0; i < 6; i++)
                                                {
                                                    AdminTellMessage(autoSurrenderMessage);
                                                    Thread.Sleep(50);
                                                }
                                                _threadMasterWaitHandle.WaitOne(1000 * _YellDuration);
                                                var repRecord = new AdKatsRecord
                                                {
                                                    record_source = AdKatsRecord.Sources.InternalAutomated,
                                                    server_id = _serverInfo.ServerID,
                                                    command_type = GetCommandByKey("round_end"),
                                                    command_numeric = baserapingTeam.TeamID,
                                                    target_name = baserapingTeam.TeamName,
                                                    source_name = "RoundManager",
                                                    record_message = "Auto-Surrender (" + baserapingTeam.TeamKey + " Win)(" + baserapingTeam.TeamTicketCount + ":" + baserapedTeam.TeamTicketCount + ")(" + FormatTimeString(_serverInfo.GetRoundElapsedTime(), 2) + ")"
                                                };
                                                QueueRecordForProcessing(repRecord);
                                            }
                                            catch (Exception)
                                            {
                                                HandleException(new AdKatsException("Error while running round end delay."));
                                            }
                                            DebugWrite("Exiting a round end delay thread.", 5);
                                            LogThreadExit();
                                        }));
                                        StartAndLogThread(roundEndDelayThread);
                                    }
                                }
                            }

                            Boolean hadServerName = !String.IsNullOrEmpty(_serverInfo.ServerName);
                            _serverInfo.ServerName = serverInfo.ServerName;
                            Boolean haveServerName = !String.IsNullOrEmpty(_serverInfo.ServerName);
                            if (!_versionTrackingDisabled && haveServerName && !hadServerName) {
                                PostVersionTracking();
                            }

                            //Only activate the following on ADK servers.
                            Boolean wasADK = _isTestingAuthorized;
                            _isTestingAuthorized = serverInfo.ServerName.Contains("=ADK=");
                            if (!wasADK && _isTestingAuthorized) {
                                ConsoleInfo("Server is testing authorized.");
                                if (_gameVersion != GameVersion.BF3)
                                {
                                    _FeedStatLoggerSettings = true;
                                    _PostStatLoggerChatManually = true;
                                    _pingEnforcerSystemEnable = true;
                                    _pingEnforcerKickMissingPings = true;
                                    _CMDRManagerEnable = true;
                                    _surrenderVoteEnable = true;
                                    if (_serverInfo.ServerName.Contains("#7")) 
                                    {
                                        _surrenderAutoEnable = true;
                                        _surrenderAutoUseMetroValues = true;
                                    }
                                    else if (_serverInfo.ServerName.Contains("#6"))
                                    {
                                        _surrenderAutoEnable = true;
                                        _surrenderAutoUseLockerValues = true;
                                    }
                                    _surrenderAutoMinimumPlayers = 32;
                                    _spamBotExcludeAdminsAndWhitelist = true;
                                }
                                _DisplayTicketRatesInProconChat = true;
                                _PostMapBenefitStatistics = true;
                                UpdateSettingPage();
                            }
                            if (!_pluginUpdateServerInfoChecked) {
                                _pluginUpdateServerInfoChecked = true;
                                CheckForPluginUpdates(false);
                            }
                            FeedStatLoggerSettings();
                        }
                        else {
                            HandleException(new AdKatsException("Server info was null"));
                        }
                        _ServerInfoWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while processing server info.", e));
            }
            DebugWrite("Exiting OnServerInfo", 7);
        }

        public void PostAndResetMapBenefitStatistics()
        {
            DebugWrite("Entering PostAndResetMapBenefitStatistics", 7);
            try
            {
                if (_PostMapBenefitStatistics && _serverInfo != null && _serverInfo.InfoObject != null)
                {
                    Int32 roundID = _roundID;
                    String mapName = _serverInfo.InfoObject.Map;
                    if (roundID > 0 && !String.IsNullOrEmpty(mapName))
                    {
                        QueueStatisticForProcessing(new AdKatsStatistic()
                        {
                            stat_type = AdKatsStatistic.StatisticType.map_detriment,
                            server_id = _serverInfo.ServerID,
                            round_id = _roundID,
                            target_name = mapName,
                            stat_value = _mapDetrimentIndex,
                            stat_comment = _mapDetrimentIndex + " players left because of " + mapName,
                            stat_time = UtcDbTime()
                        });
                        QueueStatisticForProcessing(new AdKatsStatistic()
                        {
                            stat_type = AdKatsStatistic.StatisticType.map_benefit,
                            server_id = _serverInfo.ServerID,
                            round_id = _roundID,
                            target_name = mapName,
                            stat_value = _mapBenefitIndex,
                            stat_comment = _mapBenefitIndex + " players joined because of " + mapName,
                            stat_time = UtcDbTime()
                        });
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while preparing map stats for upload", e));
            }
            _mapDetrimentIndex = 0;
            _mapBenefitIndex = 0;
            DebugWrite("Exiting PostAndResetMapBenefitStatistics", 7);
        }

        public void PostPlayerWinLossStatistics()
        {
            DebugWrite("Entering PostPlayerWinLossStatistics", 7);
            try
            {
                if (_roundID < 1) {
                    return;
                }
                AdKatsTeam team1 = _teamDictionary[1];
                AdKatsTeam team2 = _teamDictionary[2];
                AdKatsTeam winningTeam, losingTeam;
                if (team1.TeamTicketCount > team2.TeamTicketCount)
                {
                    winningTeam = team1;
                    losingTeam = team2;
                }
                else
                {
                    winningTeam = team2;
                    losingTeam = team1;
                }
                List<AdKatsPlayer> WinningPlayers = _PlayerDictionary.Values
                    .Where(aPlayer =>
                        aPlayer.frostbitePlayerInfo.TeamID == winningTeam.TeamID &&
                        aPlayer.player_type == PlayerType.Player)
                    .OrderByDescending(aPlayer => aPlayer.frostbitePlayerInfo.Score)
                    .ToList();
                List<AdKatsPlayer> LosingPlayers = _PlayerDictionary.Values
                    .Where(aPlayer =>
                        aPlayer.frostbitePlayerInfo.TeamID == losingTeam.TeamID &&
                        aPlayer.player_type == PlayerType.Player)
                    .OrderByDescending(aPlayer => aPlayer.frostbitePlayerInfo.Score)
                    .ToList();
                foreach (AdKatsPlayer aPlayer in WinningPlayers)
                {
                    QueueStatisticForProcessing(new AdKatsStatistic()
                    {
                        stat_type = AdKatsStatistic.StatisticType.player_win,
                        server_id = _serverInfo.ServerID,
                        round_id = _roundID,
                        target_name = aPlayer.player_name,
                        target_player = aPlayer,
                        stat_value = aPlayer.frostbitePlayerInfo.SquadID,
                        stat_comment = aPlayer.player_name + " won",
                        stat_time = UtcDbTime()
                    });
                }
                foreach (AdKatsPlayer aPlayer in LosingPlayers)
                {
                    QueueStatisticForProcessing(new AdKatsStatistic()
                    {
                        stat_type = AdKatsStatistic.StatisticType.player_loss,
                        server_id = _serverInfo.ServerID,
                        round_id = _roundID,
                        target_name = aPlayer.player_name,
                        target_player = aPlayer,
                        stat_value = aPlayer.frostbitePlayerInfo.SquadID,
                        stat_comment = aPlayer.player_name + " lost",
                        stat_time = UtcDbTime()
                    });
                }
                if (_surrenderAutoSucceeded || _surrenderVoteSucceeded)
                {
                    foreach (AdKatsPlayer aPlayer in WinningPlayers.Take(10).ToList())
                    {
                        QueueStatisticForProcessing(new AdKatsStatistic()
                        {
                            stat_type = AdKatsStatistic.StatisticType.player_baserape,
                            server_id = _serverInfo.ServerID,
                            round_id = _roundID,
                            target_name = aPlayer.player_name,
                            target_player = aPlayer,
                            stat_value = aPlayer.frostbitePlayerInfo.SquadID,
                            stat_comment = aPlayer.player_name + " baseraped from " + GetPlayerTeamKey(aPlayer) + " in position " + (WinningPlayers.IndexOf(aPlayer) + 1),
                            stat_time = UtcDbTime()
                        });
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while preparing map stats for upload", e));
            }
            DebugWrite("Exiting PostPlayerWinLossStatistics", 7);
        }

        public override void OnLevelLoaded(String strMapFileName, String strMapMode, Int32 roundsPlayed, Int32 roundsTotal) {
            DebugWrite("Entering OnLevelLoaded", 7);
            try {
                if (_pluginEnabled)
                {
                    //Upload map benefit/detriment statistics
                    PostAndResetMapBenefitStatistics();
                    //Change round state
                    _roundState = RoundState.Loaded;
                    //Request new server info
                    ExecuteCommand("procon.protected.send", "serverInfo");
                    //Completely clear all round-specific data
                    _endingRound = false;
                    _surrenderVoteList.Clear();
                    _nosurrenderVoteList.Clear();
                    _surrenderVoteActive = false;
                    _surrenderVoteSucceeded = false;
                    _surrenderAutoSucceeded = false;
                    _RoundReports.Clear();
                    _RoundReportHistory.Clear();
                    _RoundMutedPlayers.Clear();
                    _ActionConfirmDic.Clear();
                    _ActOnSpawnDictionary.Clear();
                    _ActOnIsAliveDictionary.Clear();
                    _TeamswapOnDeathMoveDic.Clear();
                    _Team1MoveQueue.Clear();
                    _Team2MoveQueue.Clear();
                    _RoundCookers.Clear();
                    _unmatchedRoundDeathCounts.Clear();
                    _unmatchedRoundDeaths.Clear();
                    //Update the factions 
                    UpdateFactions();
                    StartRoundTicketLogger(0);
                    foreach (AdKatsPlayer aPlayer in _PlayerDictionary.Values.ToList()) {
                        aPlayer.RequiredTeam = null;
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling level load.", e));
            }
            DebugWrite("Exiting OnLevelLoaded", 7);
        }

        //Round ended stuff
        public override void OnRoundOverTeamScores(List<TeamScore> teamScores)
        {
            if (_isTestingAuthorized)
            {
                PostPlayerWinLossStatistics();
            }
            _roundState = RoundState.Ended;
            _pingKicksThisRound = 0;
        }

        public override void OnRunNextLevel() {
            _roundState = RoundState.Ended;
            _pingKicksThisRound = 0;
        }

        //Move delayed players when they are killed
        public override void OnPlayerKilled(Kill kKillerVictimDetails) {
            DebugWrite("Entering OnPlayerKilled", 7);
            try {
                //If the plugin is not enabled just return
                if (!_pluginEnabled || !_threadsReady || !_firstPlayerListComplete) {
                    return;
                }
                //Otherwise, queue the kill for processing
                QueueKillForProcessing(kKillerVictimDetails);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling onPlayerKilled.", e));
            }
            DebugWrite("Exiting OnPlayerKilled", 7);
        }

        public override void OnPlayerIsAlive(string soldierName, bool isAlive) {
            DebugWrite("Entering OnPlayerIsAlive", 7);
            try {
                if (!_pluginEnabled)
                    return;
                if (!_ActOnIsAliveDictionary.ContainsKey(soldierName)) {
                    return;
                }
                AdKatsRecord aRecord;
                lock (_ActOnIsAliveDictionary) {
                    if (_ActOnIsAliveDictionary.TryGetValue(soldierName, out aRecord)) {
                        _ActOnIsAliveDictionary.Remove(aRecord.target_player.player_name);
                        aRecord.isAliveChecked = true;
                        switch (aRecord.command_action.command_key) {
                            case "player_kill":
                            case "player_kill_lowpop":
                                if (isAlive) {
                                    QueueRecordForActionHandling(aRecord);
                                }
                                else {
                                    if (!_ActOnSpawnDictionary.ContainsKey(aRecord.target_player.player_name))
                                    {
                                        DebugWrite(aRecord.GetTargetNames() + " is dead. Queueing them for kill on-spawn.", 3);
                                        SendMessageToSource(aRecord, aRecord.GetTargetNames() + " is dead. Queueing them for kill on-spawn.");
                                        ExecuteCommand("procon.protected.send", "admin.killPlayer", aRecord.target_player.player_name);
                                        lock (_ActOnSpawnDictionary) {
                                            aRecord.command_action = GetCommandByKey("player_kill_repeat");
                                            _ActOnSpawnDictionary.Add(aRecord.target_player.player_name, aRecord);
                                        }
                                    }
                                }
                                break;
                            case "player_move":
                                //If player is not alive, change to force move
                                if (!isAlive) {
                                    aRecord.command_type = GetCommandByKey("player_fmove");
                                    aRecord.command_action = GetCommandByKey("player_fmove");
                                }
                                QueueRecordForActionHandling(aRecord);
                                break;
                            default:
                                ConsoleError("Command " + aRecord.command_action.command_key + " not useable in OnPlayerIsAlive");
                                break;
                        }
                    }
                    else {
                        ConsoleWarn(soldierName + " not fetchable from the isalive dictionary.");
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling OnPlayerIsAlive.", e));
            }
            DebugWrite("Exiting OnPlayerIsAlive", 7);
        }

        private void QueueKillForProcessing(Kill kKillerVictimDetails) {
            DebugWrite("Entering queueKillForProcessing", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue kill for processing", 6);
                    lock (_KillProcessingQueue) {
                        _KillProcessingQueue.Enqueue(kKillerVictimDetails);
                        DebugWrite("Kill queued for processing", 6);
                        _KillProcessingWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing kill for processing.", e));
            }
            DebugWrite("Exiting queueKillForProcessing", 7);
        }

        public void KillProcessingThreadLoop() {
            try {
                DebugWrite("KILLPROC: Starting Kill Processing Thread", 1);
                Thread.CurrentThread.Name = "killprocessing";
                DateTime loopStart = UtcDbTime();
                while (true)
                {
                    loopStart = UtcDbTime();
                    try {
                        DebugWrite("KILLPROC: Entering Kill Processing Thread Loop", 7);
                        if (!_pluginEnabled) {
                            DebugWrite("KILLPROC: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }

                        //Get all unprocessed inbound kills
                        Queue<Kill> inboundPlayerKills;
                        if (_KillProcessingQueue.Count > 0) {
                            DebugWrite("KILLPROC: Preparing to lock inbound kill queue to retrive new player kills", 7);
                            lock (_KillProcessingQueue) {
                                DebugWrite("KILLPROC: Inbound kills found. Grabbing.", 6);
                                //Grab all kills in the queue
                                inboundPlayerKills = new Queue<Kill>(_KillProcessingQueue.ToArray());
                                //Clear the queue for next run
                                _KillProcessingQueue.Clear();
                            }
                        }
                        else {
                            DebugWrite("KILLPROC: No inbound player kills. Waiting for Input.", 6);
                            //Wait for input
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _KillProcessingWaitHandle.Reset();
                            _KillProcessingWaitHandle.WaitOne(TimeSpan.FromSeconds(5));
                            loopStart = UtcDbTime();
                            continue;
                        }

                        //Loop through all kils in order that they came in
                        while (inboundPlayerKills.Count > 0) {
                            if (!_pluginEnabled) {
                                break;
                            }
                            DebugWrite("KILLPROC: begin reading player kills", 6);
                            //Dequeue the first/next kill
                            Kill playerKill = inboundPlayerKills.Dequeue();

                            //Call processing on the player kill
                            ProcessPlayerKill(playerKill);
                        }
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            HandleException(new AdKatsException("kill processing thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in kill processing thread.", e));
                    }
                }
                DebugWrite("KILLPROC: Ending Kill Processing Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in kill processing thread.", e));
            }
        }

        private void ProcessPlayerKill(Kill kKillerVictimDetails) {
            try {
                UploadWeaponCode(kKillerVictimDetails.DamageType);
                if (!_firstPlayerListComplete) {
                    return;
                }
                AdKatsPlayer victim = null;
                _PlayerDictionary.TryGetValue(kKillerVictimDetails.Victim.SoldierName, out victim);
                AdKatsPlayer killer = null;
                _PlayerDictionary.TryGetValue(kKillerVictimDetails.Killer.SoldierName, out killer);
                if (victim == null || killer == null) {
                    return;
                }

                victim.lastAction = UtcDbTime();
                killer.lastAction = UtcDbTime();

                if (killer.player_type == PlayerType.Spectator)
                {
                    //Unlock the player
                    killer.Unlock();
                    //Create the ban record
                    QueueRecordForProcessing(new AdKatsRecord
                    {
                        record_source = AdKatsRecord.Sources.InternalAutomated,
                        server_id = _serverInfo.ServerID,
                        command_type = GetCommandByKey("player_ban_perm"),
                        command_numeric = 0,
                        target_name = killer.player_name,
                        target_player = killer,
                        source_name = "AutoAdmin",
                        record_message = "Spectator Hack"
                    });
                    return;
                }

                //Used for delayed player moving
                if (_TeamswapOnDeathMoveDic.Count > 0) {
                    lock (_TeamswapOnDeathCheckingQueue) {
                        _TeamswapOnDeathCheckingQueue.Enqueue(kKillerVictimDetails.Victim);
                        _TeamswapWaitHandle.Set();
                    }
                }

                //Add the unmatched unique round death
                if (!_unmatchedRoundDeaths.Contains(victim.player_name)) {
                    _unmatchedRoundDeaths.Add(victim.player_name);
                }
                //Add the unmatched round death count
                if (_unmatchedRoundDeathCounts.ContainsKey(victim.player_name)) {
                    _unmatchedRoundDeathCounts[victim.player_name] = _unmatchedRoundDeathCounts[victim.player_name] + 1;
                }
                else {
                    _unmatchedRoundDeathCounts[victim.player_name] = 1;
                }

                Boolean gKillHandled = false;
                //Update player death information
                DebugWrite("Setting " + victim.GetVerboseName() + " time of death to " + kKillerVictimDetails.TimeOfDeath, 7);
                victim.lastDeath = UtcDbTime();
                //Only add the last death if it's not a death by admin
                if (!String.IsNullOrEmpty(kKillerVictimDetails.Killer.SoldierName))
                {
                    try
                    {
                        //ADK grenade cooking catcher
                        if (_useExperimentalTools && _UseGrenadeCookCatcher)
                        {
                            if (_RoundCookers == null)
                            {
                                _RoundCookers = new Dictionary<String, AdKatsPlayer>();
                            }
                            const double possibleRange = 750.00;
                            //Update killer information
                            //Initialize the recent kills queue
                            if (killer.RecentKills == null)
                            {
                                killer.RecentKills = new Queue<KeyValuePair<AdKatsPlayer, DateTime>>();
                            }
                            //Only keep the last 10 kills in memory
                            while (killer.RecentKills.Count > 10)
                            {
                                killer.RecentKills.Dequeue();
                            }
                            //Add the player
                            killer.RecentKills.Enqueue(new KeyValuePair<AdKatsPlayer, DateTime>(victim, kKillerVictimDetails.TimeOfDeath));
                            //Check for cooked grenade and non-suicide
                            if (kKillerVictimDetails.DamageType.Contains("M67") || kKillerVictimDetails.DamageType.Contains("V40"))
                            {
                                if (true)
                                {
                                    Double fuseTime = 0;
                                    if (kKillerVictimDetails.DamageType.Contains("M67"))
                                    {
                                        if (_gameVersion == GameVersion.BF3)
                                        {
                                            fuseTime = 3735.00;
                                        }
                                        else if (_gameVersion == GameVersion.BF4)
                                        {
                                            fuseTime = 3132.00;
                                        }
                                    }
                                    else if (kKillerVictimDetails.DamageType.Contains("V40"))
                                    {
                                        fuseTime = 2865.00;
                                    }
                                    Boolean told = false;
                                    var possible = new List<KeyValuePair<AdKatsPlayer, String>>();
                                    var sure = new List<KeyValuePair<AdKatsPlayer, String>>();
                                    foreach (var cooker in killer.RecentKills)
                                    {
                                        //Get the actual time since cooker value
                                        Double milli = kKillerVictimDetails.TimeOfDeath.Subtract(cooker.Value).TotalMilliseconds;

                                        //Calculate the percentage probability
                                        Double probability;
                                        if (Math.Abs(milli - fuseTime) < possibleRange)
                                        {
                                            probability = (1 - Math.Abs((milli - fuseTime) / possibleRange)) * 100;
                                            DebugWrite(cooker.Key.GetVerboseName() + " cooking probability: " + probability + "%", 2);
                                        }
                                        else
                                        {
                                            probability = 0.00;
                                        }

                                        //If probability > 60% report the player and add them to the round cookers list
                                        if (probability > 60.00)
                                        {
                                            DebugWrite(cooker.Key.GetVerboseName() + " in " + killer.GetVerboseName() + "'s recent kills has a " + probability + "% cooking probability.", 2);
                                            gKillHandled = true;
                                            //Code to avoid spam
                                            if (killer.lastKill.AddSeconds(2) < UtcDbTime())
                                            {
                                                killer.lastKill = UtcDbTime();
                                            }
                                            else
                                            {
                                                DebugWrite("Skipping additional auto-actions for multi-kill event.", 2);
                                                continue;
                                            }

                                            if (!told)
                                            {
                                                //Inform the victim player that they will not be punished
                                                PlayerTellMessage(killer.player_name, "You appear to be a victim of grenade cooking and will NOT be punished.");
                                                PlayerTellMessage(victim.player_name, killer.GetVerboseName() + " was a victim of grenade cooking, they did not use explosives.");
                                                told = true;
                                            }

                                            //Create the probability String
                                            String probString = ((int)probability) + "-" + ((int)milli);

                                            //If the player is already on the round cooker list, ban them
                                            if (_RoundCookers.ContainsKey(cooker.Key.player_name))
                                            {
                                                //Create the ban record
                                                var record = new AdKatsRecord
                                                {
                                                    record_source = AdKatsRecord.Sources.InternalAutomated,
                                                    server_id = _serverInfo.ServerID,
                                                    command_type = GetCommandByKey("player_punish"),
                                                    command_numeric = 0,
                                                    target_name = cooker.Key.player_name,
                                                    target_player = cooker.Key,
                                                    source_name = "AutoAdmin",
                                                    record_message = "Rules: Cooking Grenades [" + probString + "-X] [Victim " + killer.GetVerboseName() + " Protected]"
                                                };
                                                //Process the record
                                                QueueRecordForProcessing(record);
                                                //adminSay("Punishing " + killer.player_name + " for " + record.record_message);
                                                DebugWrite(record.GetTargetNames() + " punished for " + record.record_message, 2);
                                                return;
                                            }
                                            //else if probability > 92.5% add them to the SURE list, and round cooker list
                                            if (probability > 92.5)
                                            {
                                                _RoundCookers.Add(cooker.Key.player_name, cooker.Key);
                                                DebugWrite(cooker.Key.GetVerboseName() + " added to round cooker list.", 2);
                                                //Add to SURE
                                                sure.Add(new KeyValuePair<AdKatsPlayer, String>(cooker.Key, probString));
                                            }
                                            //Otherwise add them to the round cooker list, and add to POSSIBLE list
                                            else
                                            {
                                                _RoundCookers.Add(cooker.Key.player_name, cooker.Key);
                                                DebugWrite(cooker.Key.GetVerboseName() + " added to round cooker list.", 2);
                                                //Add to POSSIBLE
                                                possible.Add(new KeyValuePair<AdKatsPlayer, String>(cooker.Key, probString));
                                            }
                                        }
                                    }
                                    //This method used for dealing with multiple kills at the same instant i.e twin/triple headshots
                                    if (sure.Count == 1 && possible.Count == 0)
                                    {
                                        AdKatsPlayer player = sure[0].Key;
                                        String probString = sure[0].Value;
                                        //Create the ban record
                                        var record = new AdKatsRecord
                                        {
                                            record_source = AdKatsRecord.Sources.InternalAutomated,
                                            server_id = _serverInfo.ServerID,
                                            command_type = GetCommandByKey("player_punish"),
                                            command_numeric = 0,
                                            target_name = player.player_name,
                                            target_player = player,
                                            source_name = "AutoAdmin",
                                            record_message = "Rules: Cooking Grenades [" + probString + "] [Victim " + killer.GetVerboseName() + " Protected]"
                                        };
                                        //Process the record
                                        QueueRecordForProcessing(record);
                                        //adminSay("Punishing " + killer.player_name + " for " + record.record_message);
                                        DebugWrite(record.GetTargetNames() + " punished for " + record.record_message, 2);
                                    }
                                    else
                                    {
                                        AdKatsPlayer player;
                                        String probString;
                                        foreach (var playerPair in sure)
                                        {
                                            player = playerPair.Key;
                                            probString = playerPair.Value;
                                            //Create the report record
                                            var record = new AdKatsRecord
                                            {
                                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                                server_id = _serverInfo.ServerID,
                                                command_type = GetCommandByKey("player_report"),
                                                command_numeric = 0,
                                                target_name = player.player_name,
                                                target_player = player,
                                                source_name = "AutoAdmin",
                                                record_message = "Possible Grenade Cooker [" + probString + "] [Victim " + killer.GetVerboseName() + " Protected]"
                                            };
                                            //Process the record
                                            QueueRecordForProcessing(record);
                                            DebugWrite(record.GetTargetNames() + " reported for " + record.record_message, 2);
                                        }
                                        foreach (var playerPair in possible)
                                        {
                                            player = playerPair.Key;
                                            probString = playerPair.Value;
                                            //Create the report record
                                            var record = new AdKatsRecord
                                            {
                                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                                server_id = _serverInfo.ServerID,
                                                command_type = GetCommandByKey("player_report"),
                                                command_numeric = 0,
                                                target_name = player.player_name,
                                                target_player = player,
                                                source_name = "AutoAdmin",
                                                record_message = "Possible Grenade Cooker [" + probString + "] [Victim " + killer.GetVerboseName() + " Protected]"
                                            };
                                            //Process the record
                                            QueueRecordForProcessing(record);
                                            DebugWrite(record.GetTargetNames() + " reported for " + record.record_message, 2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        HandleException(new AdKatsException("Error in grenade cook catcher.", e));
                    }
                }

                try {
                    if(_isTestingAuthorized && 
                       _serverInfo.ServerName.Contains("#7") && 
                       kKillerVictimDetails.Killer.TeamID == kKillerVictimDetails.Victim.TeamID &&
                       !kKillerVictimDetails.IsSuicide)
                    {
                        if (kKillerVictimDetails.DamageType == "DamageArea")
                        {
                            //Slay the teamkiller
                            var aRecord = new AdKatsRecord
                            {
                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                server_id = _serverInfo.ServerID,
                                command_type = GetCommandByKey("player_kill_force"),
                                command_numeric = 0,
                                target_name = killer.player_name,
                                target_player = killer,
                                source_name = "AutoAdmin",
                                record_message = "Teamkilling " + victim.GetVerboseName() + " with a damage area"
                            };
                            QueueRecordForProcessing(aRecord);
                            //Inform the victim
                            PlayerTellMessage(victim.player_name, killer.GetVerboseName() + " was slain for teamkilling you");
                        }
                        else if (kKillerVictimDetails.DamageType == "Medkit" || kKillerVictimDetails.DamageType == "U_PortableMedicpack" || kKillerVictimDetails.DamageType == "U_Medkit") {
                            PlayerSayMessage(killer.player_name, victim.GetVerboseName() + " denied your revive!");
                            PlayerTellMessage(victim.player_name, "You denied " + killer.GetVerboseName() + "'s revive!");
                        }
                    }
                    else if (_UseWeaponLimiter && !gKillHandled) {
                        //Check for restricted weapon
                        if (Regex.Match(kKillerVictimDetails.DamageType, @"(?:" + _WeaponLimiterString + ")", RegexOptions.IgnoreCase).Success) {
                            //Check for exception type
                            if (!Regex.Match(kKillerVictimDetails.DamageType, @"(?:" + _WeaponLimiterExceptionString + ")", RegexOptions.IgnoreCase).Success) {
                                //Check if suicide
                                if (kKillerVictimDetails.Killer.SoldierName != kKillerVictimDetails.Victim.SoldierName) {
                                    //Get player from the dictionary
                                    if (killer != null) {
                                        //Code to avoid spam
                                        if (killer.lastKill.AddSeconds(2) < UtcDbTime()) {
                                            killer.lastKill = UtcDbTime();
                                            //Create the punish record
                                            var record = new AdKatsRecord {
                                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                                server_id = _serverInfo.ServerID,
                                                command_type = GetCommandByKey("player_punish"),
                                                command_numeric = 0,
                                                target_name = killer.player_name,
                                                target_player = killer,
                                                source_name = "AutoAdmin"
                                            };
                                            const string removeWeapon = "Weapons/";
                                            const string removeGadgets = "Gadgets/";
                                            const string removePrefix = "U_";
                                            String weapon = GetShortWeaponNameByCode(kKillerVictimDetails.DamageType);
                                            Int32 index = weapon.IndexOf(removeWeapon, StringComparison.Ordinal);
                                            weapon = (index < 0) ? (weapon) : (weapon.Remove(index, removeWeapon.Length));
                                            index = weapon.IndexOf(removeGadgets, StringComparison.Ordinal);
                                            weapon = (index < 0) ? (weapon) : (weapon.Remove(index, removeGadgets.Length));
                                            index = weapon.IndexOf(removePrefix, StringComparison.Ordinal);
                                            weapon = (index < 0) ? (weapon) : (weapon.Remove(index, removePrefix.Length));
                                            if (weapon == "RoadKill") {
                                                record.record_message = "Rules: Roadkilling with EOD or MAV";
                                            }
                                            else if (weapon == "Death") {
                                                if (_gameVersion == GameVersion.BF3) {
                                                    record.record_message = "Rules: Using Mortar";
                                                }
                                                else if (_gameVersion == GameVersion.BF4) {
                                                    record.record_message = "Rules: Using EOD Bot";
                                                }
                                            }
                                            else {
                                                record.record_message = "Rules: Using Explosives [" + weapon + "]";
                                            }
                                            PlayerYellMessage(victim.player_name, killer.GetVerboseName() + " was punished for killing you with " + weapon);
                                            
                                            //Custom record to boost rep for victim
                                            var repRecord = new AdKatsRecord {
                                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                                server_id = _serverInfo.ServerID,
                                                command_type = GetCommandByKey("player_repboost"),
                                                command_numeric = 0,
                                                target_name = victim.player_name,
                                                target_player = victim,
                                                source_name = "RepManager",
                                                record_message = "Player killed by restricted weapon " + weapon
                                            };
                                            QueueRecordForProcessing(repRecord);
                                            
                                            //Process the record
                                            QueueRecordForProcessing(record);
                                        }
                                        else {
                                            DebugWrite("Skipping additional auto-actions for multi-kill event.", 2);
                                        }
                                    }
                                    else {
                                        ConsoleError("Killer was null when processing kill");
                                    }
                                }
                            }
                        }
                    }
                }
                catch (Exception e) {
                    HandleException(new AdKatsException("Error in no explosives auto-admin.", e));
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while processing player kill.", e));
            }
            DebugWrite("Exiting OnPlayerKilled", 7);
        }

        private void UploadWeaponCode(String weaponCode) {
            DebugWrite("uploadWeaponCode starting!", 7);

            //Make sure database connection active
            if (HandlePossibleDisconnect() || !_isTestingAuthorized) {
                return;
            }
            try {
                Boolean confirmed = _WeaponCodesTableConfirmed;
                if (!_WeaponCodesTableTested) {
                    _WeaponCodesTableTested = true;
                    _WeaponCodesTableConfirmed = ConfirmTable("tbl_weaponcodes");
                }
                if (!_WeaponCodesTableConfirmed) {
                    return;
                }
                if (!confirmed) {
                    ConsoleSuccess("Weapon code table found.");
                }
                //Check for length too great
                if (weaponCode.Length > 100) {
                    ConsoleError("Weapon name '" + weaponCode + "' too long!!!");
                    return;
                }

                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        //Set the insert command structure
                        command.CommandText = @"
                        INSERT INTO `tbl_weaponcodes` 
                        (
                            `weapon_code`
                        ) 
                        VALUES 
                        (  
                            '" + weaponCode + @"'
                        ) 
                        ON DUPLICATE KEY 
                        UPDATE 
                            `weapon_usage_count` = `weapon_usage_count` + 1";
                        //Attempt to execute the query
                        if (SafeExecuteNonQuery(command) > 0) {
                            DebugWrite("Weapon pushed to database", 7);
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while uploading weapon to database.", e));
            }

            DebugWrite("uploadWeaponCode finished!", 7);
        }

        public override void OnPlayerSpawned(String soldierName, Inventory spawnedInventory) {
            DebugWrite("Entering OnPlayerSpawned", 7);
            try
            {
                AdKatsPlayer aPlayer = null;
                if (_pluginEnabled && _threadsReady && _firstPlayerListComplete) {
                    if (_roundState == RoundState.Loaded) {
                        _roundState = RoundState.Playing;
                        if (_useRoundTimer) {
                            StartRoundTimer();
                        }
                    }
                    if (_CommandNameDictionary.Count > 0) {
                        //Handle TeamSwap notifications
                        String command = GetCommandByKey("self_teamswap").command_text;
                        if (_PlayerDictionary.TryGetValue(soldierName, out aPlayer)) {
                            aPlayer.lastSpawn = UtcDbTime();
                            aPlayer.lastAction = UtcDbTime();

                            //Add matched spawn count
                            AdKatsTeam aTeam;
                            if (aPlayer.frostbitePlayerInfo != null &&
                                _teamDictionary.TryGetValue(aPlayer.frostbitePlayerInfo.TeamID, out aTeam) &&
                                _unmatchedRoundDeaths.Contains(aPlayer.player_name)) {
                                aTeam.IncrementTeamTicketAdjustment();
                            }
                            //Removed unmatched death if applicable
                            _unmatchedRoundDeaths.Remove(aPlayer.player_name);
                            //Decrement unmatched death count if applicable
                            if (_unmatchedRoundDeathCounts.ContainsKey(aPlayer.player_name)) {
                                _unmatchedRoundDeathCounts[aPlayer.player_name] = _unmatchedRoundDeathCounts[aPlayer.player_name] - 1;
                            }

                            if (aPlayer.player_aa && !aPlayer.player_aa_told) {
                                String adminAssistantMessage = "You are now considered an Admin Assistant. ";
                                if (!_UseAAReportAutoHandler && !_EnableAdminAssistantPerk) {
                                    adminAssistantMessage += "Thank you for your consistent reporting.";
                                }
                                else {
                                    adminAssistantMessage += "Perks: ";
                                    if (_UseAAReportAutoHandler) {
                                        adminAssistantMessage += "AutoAdmin can handle some of your reports. ";
                                    }
                                    if (_EnableAdminAssistantPerk) {
                                        adminAssistantMessage += "You can use the @" + command + " command.";
                                    }
                                }
                                PlayerSayMessage(soldierName, adminAssistantMessage);
                                aPlayer.player_aa_told = true;
                            }
                        }
                    }

                    //Handle Dev Notifications
                    if (soldierName == "ColColonCleaner" && (!_isTestingAuthorized || !_toldCol)) {
                        PlayerTellMessage("ColColonCleaner", "CONGRATS! This server is running AdKats " + PluginVersion + "!");
                        _toldCol = true;
                    }

                    if (aPlayer != null && !aPlayer.player_spawnedOnce) {
                        aPlayer.player_spawnedOnce = true;
                        if (_ShowNewPlayerAnnouncement && aPlayer.player_new)
                        {
                            OnlineAdminSayMessage(aPlayer.GetVerboseName() + " just joined this server group for the first time!");
                        }
                        if(_UseFirstSpawnMessage) {
                            var spawnPrinter = new Thread(new ThreadStart(delegate
                            {
                                DebugWrite("Starting a spawn printer thread.", 5);
                                try
                                {
                                    Thread.CurrentThread.Name = "spawnprinter";
                                    //Wait 2 seconds
                                    _threadMasterWaitHandle.WaitOne(2000);
                                    PlayerTellMessage(aPlayer.player_name, _FirstSpawnMessage);
                                    var points = FetchPoints(aPlayer, false);
                                    if ((_isTestingAuthorized && (_serverInfo.ServerName.Contains("#7") || _serverInfo.ServerName.Contains("#6"))) || _useFirstSpawnRepMessage)
                                    {
                                        Boolean isAdmin = PlayerIsAdmin(aPlayer);
                                        _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(_YellDuration));
                                        String repMessage = "Your server reputation is " + ((!isAdmin || !_isTestingAuthorized)?(Math.Round(aPlayer.player_reputation, 2) + ""):(aPlayer.player_role.role_name)) + ", with ";
                                        if (points > 0) {
                                            repMessage += points + " infraction point(s). ";
                                        }
                                        else {
                                            repMessage += "a clean infraction record. ";
                                        }
                                        if (!isAdmin && _isTestingAuthorized)
                                        {
                                            repMessage += System.Environment.NewLine;
                                            if (aPlayer.player_reputation < _reputationThresholdGood)
                                            {
                                                if (aPlayer.player_reputation > 15)
                                                {
                                                    repMessage += "Thank you for helping the admins! At " + Math.Round(_reputationThresholdGood, 2) + " reputation you receive report auto-contest.";
                                                }
                                                else if (aPlayer.player_reputation > 0) {
                                                    repMessage += "Thank you for helping the admins! At 15 reputation you receive punishment warning.";
                                                }
                                                else
                                                {
                                                    repMessage += "!" + GetCommandByKey("player_report").command_text + " rule breakers to increase reputation.";
                                                }
                                            }
                                            else
                                            {
                                                repMessage += "You have report auto-contest. Thank you.";
                                            }
                                        }
                                        PlayerTellMessage(aPlayer.player_name, repMessage);
                                    }
                                }
                                catch (Exception)
                                {
                                    HandleException(new AdKatsException("Error while printing spawn messages"));
                                }
                                DebugWrite("Exiting a spawn printer.", 5);
                                LogThreadExit();
                            }));

                            //Start the thread
                            StartAndLogThread(spawnPrinter);
                        }
                    }

                    if (_ActOnSpawnDictionary.Count > 0) {
                        lock (_ActOnSpawnDictionary) {
                            AdKatsRecord record;
                            if (_ActOnSpawnDictionary.TryGetValue(soldierName, out record)) {
                                //Remove it from the dic
                                _ActOnSpawnDictionary.Remove(soldierName);
                                //Wait 1.5 seconds to take action (no "killed by admin" message in BF3 without this wait)
                                _threadMasterWaitHandle.WaitOne(1500);
                                //Queue the action
                                QueueRecordForActionHandling(record);
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling player spawn.", e));
            }
            DebugWrite("Exiting OnPlayerSpawned", 7);
        }

        
        public override void OnPlayerLeft(CPlayerInfo playerInfo) {
            DebugWrite("Entering OnPlayerLeft", 7);
            try {
                QueuePlayerForRemoval(playerInfo);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling player left.", e));
            }
            DebugWrite("Exiting OnPlayerLeft", 7);
        }

        private void QueueSettingImport(Int32 serverID) {
            DebugWrite("Entering queueSettingImport", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue server ID for setting import", 6);
                    _settingImportID = serverID;
                    _DbCommunicationWaitHandle.Set();
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while preparing to import settings.", e));
            }
            DebugWrite("Exiting queueSettingImport", 7);
        }

        private void QueueSettingForUpload(CPluginVariable setting) {
            DebugWrite("Entering queueSettingForUpload", 7);
            if (!_settingsFetched) {
                return;
            }
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue setting " + setting.Name + " for upload", 6);
                    lock (_SettingUploadQueue) {
                        _SettingUploadQueue.Enqueue(setting);
                        _DbCommunicationWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing setting for upload.", e));
            }
            DebugWrite("Exiting queueSettingForUpload", 7);
        }

        private void QueueCommandForUpload(AdKatsCommand command) {
            DebugWrite("Entering queueCommandForUpload", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue command " + command.command_key + " for upload", 6);
                    lock (_CommandUploadQueue) {
                        _CommandUploadQueue.Enqueue(command);
                        _DbCommunicationWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing command for upload.", e));
            }
            DebugWrite("Exiting queueCommandForUpload", 7);
        }

        private void QueueRoleForUpload(AdKatsRole aRole) {
            DebugWrite("Entering queueRoleForUpload", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue role " + aRole.role_key + " for upload", 6);
                    lock (_RoleUploadQueue) {
                        _RoleUploadQueue.Enqueue(aRole);
                        _DbCommunicationWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing role for upload.", e));
            }
            DebugWrite("Exiting queueRoleForUpload", 7);
        }

        private void QueueRoleForRemoval(AdKatsRole aRole) {
            DebugWrite("Entering queueRoleForRemoval", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue role " + aRole.role_key + " for removal", 6);
                    lock (_RoleRemovalQueue) {
                        _RoleRemovalQueue.Enqueue(aRole);
                        _DbCommunicationWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing role for removal.", e));
            }
            DebugWrite("Exiting queueRoleForRemoval", 7);
        }

        private void QueuePlayerForBanCheck(AdKatsPlayer player) {
            DebugWrite("Entering queuePlayerForBanCheck", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue player for ban check", 6);
                    lock (_BanEnforcerCheckingQueue) {
                        _BanEnforcerCheckingQueue.Enqueue(player);
                        DebugWrite("Player queued for checking", 6);
                        _BanEnforcerWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing player for ban check.", e));
            }
            DebugWrite("Exiting queuePlayerForBanCheck", 7);
        }

        private void QueueBanForProcessing(AdKatsBan aBan) {
            DebugWrite("Entering queueBanForProcessing", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue ban for processing", 6);
                    lock (_BanEnforcerProcessingQueue) {
                        _BanEnforcerProcessingQueue.Enqueue(aBan);
                        DebugWrite("Ban queued for processing", 6);
                        _DbCommunicationWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing ban for processing.", e));
            }
            DebugWrite("Exiting queueBanForProcessing", 7);
        }

        private void BanEnforcerThreadLoop() {
            try {
                DebugWrite("BANENF: Starting Ban Enforcer Thread", 1);
                Thread.CurrentThread.Name = "BanEnforcer";
                DateTime loopStart = UtcDbTime();
                while (true) {
                    try {
                        DebugWrite("BANENF: Entering Ban Enforcer Thread Loop", 7);
                        if (!_pluginEnabled) {
                            DebugWrite("BANENF: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }
                        
                        SendNonQuery("Updating Active Bans", "UPDATE `adkats_bans` SET `ban_status` = 'Expired' WHERE `ban_endTime` <= UTC_TIMESTAMP() AND `ban_status` = 'Active'", false);
                            
                        //Get all unchecked players
                        Queue<AdKatsPlayer> playerCheckingQueue;
                        if (_BanEnforcerCheckingQueue.Count > 0 && _UseBanEnforcer) {
                            DebugWrite("BANENF: Preparing to lock banEnforcerMutex to retrive new players", 6);
                            lock (_BanEnforcerCheckingQueue) {
                                DebugWrite("BANENF: Inbound players found. Grabbing.", 5);
                                //Grab all players in the queue
                                playerCheckingQueue = new Queue<AdKatsPlayer>(_BanEnforcerCheckingQueue.ToArray());
                                //Clear the queue for next run
                                _BanEnforcerCheckingQueue.Clear();
                                if (_databaseConnectionCriticalState) {
                                    continue;
                                }
                            }
                        }
                        else {
                            DebugWrite("BANENF: No inbound ban checks. Waiting for Input.", 6);
                            //Wait for input
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _BanEnforcerWaitHandle.Reset();
                            _BanEnforcerWaitHandle.WaitOne(TimeSpan.FromSeconds(60));
                            loopStart = UtcDbTime();
                            continue;
                        }

                        //Get all checks in order that they came in
                        while (playerCheckingQueue.Count > 0)
                        {
                            if (!_pluginEnabled)
                            {
                                break;
                            }
                            //Grab first/next player
                            AdKatsPlayer aPlayer = playerCheckingQueue.Dequeue();
                            DebugWrite("BANENF: begin reading player", 5);
                            if (_PlayerDictionary.ContainsKey(aPlayer.player_name)) {
                                List<AdKatsBan> aBanList = FetchPlayerBans(aPlayer);
                                if (aBanList.Count > 0) {
                                    foreach (AdKatsBan aBan in aBanList) {
                                        if (aBan.ban_record.target_player.player_id == aPlayer.player_id || aBanList.Count <= 5)
                                        {
                                            DebugWrite("BANENF: BAN ENFORCED on " + aPlayer.GetVerboseName(), 3);
                                            //Create the new record
                                            var aRecord = new AdKatsRecord
                                            {
                                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                                source_name = "BanEnforcer",
                                                isIRO = false,
                                                server_id = _serverInfo.ServerID,
                                                target_name = aPlayer.player_name,
                                                target_player = aPlayer,
                                                command_type = GetCommandByKey("banenforcer_enforce"),
                                                command_numeric = (int)aBan.ban_id,
                                                record_message = aBan.ban_record.record_message + ((aBan.ban_record.target_player.player_id != aPlayer.player_id) ? (" [LINKED ACCOUNT " + aBan.ban_record.target_player.player_id + "]") : (""))
                                            };
                                            //Queue record for upload
                                            QueueRecordForProcessing(aRecord);
                                            //Ensure the ban record has correct player information
                                            aBan.ban_record.target_player = aPlayer;
                                            //Enforce the ban
                                            EnforceBan(aBan, true);
                                        }
                                    }
                                }
                                else {
                                    DebugWrite("BANENF: No ban found for player", 5);
                                    //Only call a hack check if the player does not already have a ban
                                    if (_UseHackerChecker) {
                                        QueuePlayerForHackerCheck(aPlayer);
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            HandleException(new AdKatsException("ban enforcer thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in ban enforcer thread. Skipping current loop.", e));
                    }
                }
                DebugWrite("BANENF: Ending Ban Enforcer Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in ban enforcer thread.", e));
            }
        }

        public override void OnBanAdded(CBanInfo ban) {
            if (!_pluginEnabled || !_UseBanEnforcer)
                return;
            //DebugWrite("OnBanAdded fired", 6);
            ExecuteCommand("procon.protected.send", "banList.list");
        }

        public override void OnBanList(List<CBanInfo> banList) {
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                //Return if small duration (0.5 seconds) since last ban list, or if there is already a ban list going on
                if ((UtcDbTime() - _lastSuccessfulBanList) < TimeSpan.FromSeconds(0.5)) {
                    DebugWrite("Banlist being called quickly.", 4);
                    return;
                }
                if (_BansQueuing) {
                    ConsoleError("Attempted banlist call rejected. Processing already in progress.");
                    return;
                }
                DateTime startTime = UtcDbTime();
                _lastSuccessfulBanList = startTime;
                if (!_pluginEnabled)
                    return;
                DebugWrite("OnBanList fired", 5);
                if (_UseBanEnforcer) {
                    if (banList.Count > 0) {
                        DebugWrite("Bans found", 3);
                        lock (_CBanProcessingQueue) {
                            //Only allow queueing of new bans if the processing queue is currently empty
                            if (_CBanProcessingQueue.Count == 0) {
                                foreach (CBanInfo cBan in banList) {
                                    DebugWrite("Queuing Ban.", 7);
                                    _CBanProcessingQueue.Enqueue(cBan);
                                    _BansQueuing = true;
                                    if (UtcDbTime() - startTime > TimeSpan.FromSeconds(50)) {
                                        HandleException(new AdKatsException("OnBanList took longer than 50 seconds, exiting so procon doesn't panic."));
                                        _BansQueuing = false;
                                        return;
                                    }
                                }
                                _BansQueuing = false;
                            }
                        }
                    }
                }
                _DbCommunicationWaitHandle.Set();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured while listing procon bans.", e));
                _BansQueuing = false;
            }
        }

        public override void OnBanListClear() {
            DebugWrite("Ban list cleared", 5);
        }

        public override void OnBanListSave() {
            DebugWrite("Ban list saved", 5);
        }

        public override void OnBanListLoad() {
            DebugWrite("Ban list loaded", 5);
        }

        private void QueuePlayerForHackerCheck(AdKatsPlayer player) {
            DebugWrite("Entering queuePlayerForHackerCheck", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue player for hacker check", 6);
                    lock (_HackerCheckerQueue) {
                        _HackerCheckerQueue.Enqueue(player);
                        DebugWrite("Player queued for checking", 6);
                        _HackerCheckerWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing player for hacker check.", e));
            }
            DebugWrite("Exiting queuePlayerForHackerCheck", 7);
        }

        public List<AdKatsSpecialPlayer> GetASPlayersOfGroup(String specialPlayerGroup) {
            Dictionary<Int64, AdKatsSpecialPlayer> tempASPlayers = new Dictionary<Int64, AdKatsSpecialPlayer>();
            AdKatsSpecialGroup asGroup = null;
            foreach (var asPlayer in _specialPlayerCache.Values.Where(asPlayer => asPlayer.player_group.group_key == specialPlayerGroup).ToList()) {
                if (asPlayer.player_object != null) {
                    tempASPlayers[asPlayer.player_object.player_id] = asPlayer;
                }
                else {
                    tempASPlayers[asPlayer.specialplayer_id] = asPlayer;
                }
                if (asGroup == null) {
                    asGroup = asPlayer.player_group;
                }
            }
            foreach (var aUser in _userCache.Values.Where(sUser => sUser.user_role.RoleSetGroups.ContainsKey(specialPlayerGroup)).ToList())
            {
                foreach (var aPlayer in aUser.soldierDictionary.Values.ToList())
                {
                    //Check for existing player
                    if (!tempASPlayers.ContainsKey(aPlayer.player_id))
                    {
                        tempASPlayers[aPlayer.player_id] = new AdKatsSpecialPlayer()
                        {
                            player_game = (int)_serverInfo.GameID,
                            player_server = (int)_serverInfo.ServerID,
                            player_group = asGroup,
                            player_identifier = aPlayer.player_name,
                            player_object = aPlayer,
                            player_effective = UtcDbTime(),
                            player_expiration = aUser.user_expiration
                        };
                    }
                }
            }
            return tempASPlayers.Values.ToList();
        }

        public List<AdKatsSpecialPlayer> GetMatchingASPlayersOfGroup(String specialPlayerGroup, AdKatsPlayer aPlayer)
        {
            DebugWrite("Entering FetchMatchingSpecialPlayers", 6);
            try
            {
                List<AdKatsSpecialPlayer> matchingSpecialPlayers = new List<AdKatsSpecialPlayer>();
                matchingSpecialPlayers.AddRange(GetASPlayersOfGroup(specialPlayerGroup).Where(asPlayer => asPlayer.player_object != null &&
                    (asPlayer.player_object.player_id == aPlayer.player_id ||
                     asPlayer.player_identifier == aPlayer.player_name ||
                     asPlayer.player_identifier == aPlayer.player_guid ||
                     asPlayer.player_identifier == aPlayer.player_ip)));
                return matchingSpecialPlayers;
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching matching special players.", e));
            }
            DebugWrite("Exiting FetchMatchingSpecialPlayers", 6);
            return null;
        }

        public Dictionary<String, AdKatsPlayer> GetOnlinePlayerDictionaryOfGroup(String specialPlayerGroup)
        {
            Dictionary<String, AdKatsPlayer> onlinePlayersOfGroup = new Dictionary<String, AdKatsPlayer>();
            DebugWrite("Entering GetOnlinePlayerDictionaryOfGroup", 6);
            try
            {
                List<AdKatsPlayer> onlinePlayerObjects = _PlayerDictionary.Values.ToList();
                List<AdKatsSpecialPlayer> asPlayerObjects = GetASPlayersOfGroup(specialPlayerGroup);
                foreach (AdKatsSpecialPlayer asPlayer in asPlayerObjects)
                {
                    foreach (AdKatsPlayer aPlayer in onlinePlayerObjects)
                    {
                        if (asPlayer.player_object != null && asPlayer.player_object.player_id == aPlayer.player_id)
                        {
                            onlinePlayersOfGroup[aPlayer.player_name] = aPlayer;
                        }
                        else if (asPlayer.player_identifier == aPlayer.player_name ||
                                asPlayer.player_identifier == aPlayer.player_guid ||
                                asPlayer.player_identifier == aPlayer.player_ip)
                        {
                            onlinePlayersOfGroup[aPlayer.player_name] = aPlayer;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching matching special players.", e));
            }
            DebugWrite("Exiting GetOnlinePlayerDictionaryOfGroup", 6);
            return onlinePlayersOfGroup;
        }

        public List<AdKatsPlayer> GetOnlinePlayersOfGroup(String specialPlayerGroup)
        {
            DebugWrite("Entering GetOnlinePlayersOfGroup", 6);
            try
            {
                return GetOnlinePlayerDictionaryOfGroup(specialPlayerGroup).Values.ToList();
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching matching special players.", e));
            }
            DebugWrite("Exiting GetOnlinePlayersOfGroup", 6);
            return null;
        }

        public Boolean PlayerProtected(AdKatsPlayer aPlayer) {
            //Pull players from special player cache
            lock (_specialPlayerCache) {
                List<AdKatsSpecialPlayer> protectedList = GetASPlayersOfGroup("whitelist_hackerchecker");
                if (protectedList.Any()) {
                    foreach (AdKatsSpecialPlayer asPlayer in protectedList) {
                        if (asPlayer.player_object != null && asPlayer.player_object.player_id == aPlayer.player_id) {
                            DebugWrite(aPlayer.GetVerboseName() + " protected from hacker checker by database ID.", 2);
                            return true;
                        }
                        if (!String.IsNullOrEmpty(asPlayer.player_identifier)) {
                            if (aPlayer.player_name == asPlayer.player_identifier) {
                                DebugWrite(aPlayer.GetVerboseName() + " protected from hacker checker by NAME.", 2);
                                return true;
                            }
                            if (aPlayer.player_guid == asPlayer.player_identifier) {
                                DebugWrite(aPlayer.GetVerboseName() + " protected from hacker checker by GUID.", 2);
                                return true;
                            }
                            if (aPlayer.player_ip == asPlayer.player_identifier) {
                                DebugWrite(aPlayer.GetVerboseName() + " protected from hacker checker by IP.", 2);
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        public void HackerCheckerThreadLoop() {
            Double checkedPlayers = 0;
            Double playersWithStats = 0;
            try {
                DebugWrite("HCKCHK: Starting Hacker Checker Thread", 1);
                Thread.CurrentThread.Name = "HackerChecker";

                var playerCheckingQueue = new Queue<AdKatsPlayer>();
                var repeatCheckingQueue = new Queue<AdKatsPlayer>();
                DateTime loopStart = UtcDbTime();
                while (true) {
                    try {
                        DebugWrite("HCKCHK: Entering Hacker Checker Thread Loop", 7);
                        if (!_pluginEnabled) {
                            playerCheckingQueue.Clear();
                            repeatCheckingQueue.Clear();
                            DebugWrite("HCKCHK: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }

                        try {
                            //Get all unchecked players
                            if (_HackerCheckerQueue.Count > 0) {
                                DebugWrite("HCKCHK: Preparing to lock hackerCheckerMutex to retrive new players", 6);
                                lock (_HackerCheckerQueue) {
                                    DebugWrite("HCKCHK: Inbound players found. Grabbing.", 5);
                                    //Grab all players in the queue
                                    playerCheckingQueue = new Queue<AdKatsPlayer>(_HackerCheckerQueue.ToArray());
                                    //Clear the queue for next run  
                                    _HackerCheckerQueue.Clear();
                                }
                            }
                            else {
                                DebugWrite("HCKCHK: No inbound hacker checks. Waiting 10 seconds or for input.", 4);
                                //Wait for input
                                if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                    DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                                _HackerCheckerWaitHandle.Reset();
                                //Either loop when handle is set, or after 3 minutes
                                _HackerCheckerWaitHandle.WaitOne(180000 / ((repeatCheckingQueue.Count > 0) ? (repeatCheckingQueue.Count) : (1)));
                                loopStart = UtcDbTime();
                            }
                        }
                        catch (Exception e) {
                            HandleException(new AdKatsException("Error while fetching new players to check.", e));
                        }

                        //Current player being checked
                        AdKatsPlayer aPlayer = null;
                        try {
                            if (!_UseHackerChecker) {
                                repeatCheckingQueue.Clear();
                            }
                            //Check one player from the repeat checking queue
                            if (repeatCheckingQueue.Count > 0) {
                                //Only keep players still in the server in the repeat checking list
                                Boolean stillInServer = true;
                                do {
                                    if (!_pluginEnabled) {
                                        break;
                                    }
                                    aPlayer = repeatCheckingQueue.Dequeue();
                                    if (!_PlayerDictionary.ContainsKey(aPlayer.player_name)) {
                                        stillInServer = false;
                                    }
                                } while (!stillInServer && repeatCheckingQueue.Count > 0);
                                if (aPlayer != null) {
                                    //Fetch their stats from appropriate source
                                    FetchPlayerStats(aPlayer);
                                    if (aPlayer.stats != null && aPlayer.stats.StatsException == null) {
                                        playersWithStats++;
                                        ConsoleSuccess(aPlayer.GetVerboseName() + " now has stats. Checking.");
                                        if (!PlayerProtected(aPlayer)) {
                                            RunStatSiteHackCheck(aPlayer, false);
                                        }
                                        DebugWrite("Players with " + _gameVersion + "Stats: " + String.Format("{0:0.00}", (playersWithStats / checkedPlayers) * 100) + "%", 3);
                                    }
                                    else {
                                        aPlayer.stats = null;
                                        //If they still dont have stats, add them back to the queue
                                        repeatCheckingQueue.Enqueue(aPlayer);
                                    }
                                }
                            }
                        }
                        catch (Exception e) {
                            HandleException(new AdKatsException("Error while in repeat checking queue handler", e));
                        }

                        //Get all checks in order that they came in
                        while (playerCheckingQueue.Count > 0) {
                            if (!_pluginEnabled) {
                                break;
                            }
                            //Grab first/next player
                            aPlayer = playerCheckingQueue.Dequeue();
                            if (aPlayer != null) {
                                DebugWrite("HCKCHK: begin reading player", 4);

                                if (!PlayerProtected(aPlayer)) {
                                    FetchPlayerStats(aPlayer);
                                    checkedPlayers++;
                                    if (aPlayer.stats != null && aPlayer.stats.StatsException == null) {
                                        playersWithStats++;
                                        if (_UseHackerChecker) {
                                            RunStatSiteHackCheck(aPlayer, false);
                                        }
                                        else {
                                            DebugWrite("Player skipped after disabling hacker checker.", 2);
                                        }
                                    }
                                    else {
                                        //ConsoleError(aPlayer.player_name + " doesn't have stats.");
                                        repeatCheckingQueue.Enqueue(aPlayer);
                                    }
                                    DebugWrite("Players with " + _gameVersion + "Stats: " + String.Format("{0:0.00}", (playersWithStats / checkedPlayers) * 100) + "%", 3);
                                }
                            }
                        }
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            HandleException(new AdKatsException("Hacker Checker thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in Hacker Checker thread. Skipping current loop.", e));
                    }
                }
                DebugWrite("HCKCHK: Ending Hacker Checker Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in Hacker Checker thread.", e));
            }
        }

        private void RunStatSiteHackCheck(AdKatsPlayer aPlayer, Boolean debug) {
            DebugWrite("HackerChecker running on " + aPlayer.GetVerboseName(), 5);
            Boolean acted = false;
            if (_UseDpsChecker) {
                DebugWrite("Preparing to DPS check " + aPlayer.GetVerboseName(), 5);
                acted = DamageHackCheck(aPlayer, debug);
            }
            if (_UseHskChecker && !acted) {
                DebugWrite("Preparing to HSK check " + aPlayer.GetVerboseName(), 5);
                acted = AimbotHackCheck(aPlayer, debug);
            }
            if (_UseKpmChecker && !acted) {
                DebugWrite("Preparing to KPM check " + aPlayer.GetVerboseName(), 5);
                acted = KPMHackCheck(aPlayer, debug);
            }
            if (!acted && debug) {
                ConsoleSuccess(aPlayer.GetVerboseName() + " is clean.");
            }
        }

        private Boolean DamageHackCheck(AdKatsPlayer aPlayer, Boolean debugMode) {
            Boolean acted = false;
            try {
                if (aPlayer == null || aPlayer.stats == null || aPlayer.stats.WeaponStats == null) {
                    return false;
                }
                List<String> allowedCategories;
                switch (_gameVersion) {
                    case GameVersion.BF3:
                        allowedCategories = new List<string> {
                            "Sub machine guns",
                            "Assault rifles",
                            "Carbines",
                            "Machine guns",
                            "Handheld weapons"
                        };
                        break;
                    case GameVersion.BF4:
                        allowedCategories = new List<string> {
                            "PDW",
                            "ASSAULT RIFLE",
                            "CARBINE",
                            "LMG",
                            "SIDEARM"
                        };
                        break;
                    default:
                        return false;
                }
                List<AdKatsWeaponStats> topWeapons = aPlayer.stats.WeaponStats.Values.ToList();
                topWeapons.Sort(delegate(AdKatsWeaponStats a1, AdKatsWeaponStats a2) {
                    if (Math.Abs(a1.Kills - a2.Kills) < 0.001) {
                        return 0;
                    }
                    return (a1.Kills < a2.Kills) ? (1) : (-1);
                });

                AdKatsWeaponStats actedWeapon = null;
                Double actedPerc = -1;
                Int32 index = 0;
                foreach (AdKatsWeaponStats weaponStat in topWeapons) {
                    //Break after 15th top weapon
                    if (index++ > 15) {
                        break;
                    }
                    //Only count certain weapon categories
                    if (allowedCategories.Contains(weaponStat.Category)) {
                        StatLibraryWeapon weapon;
                        if (_StatLibrary.Weapons.TryGetValue(weaponStat.ID, out weapon)) {
                            //Only handle weapons that do < 50 max dps
                            if (weapon.damage_max < 50) {
                                //Only take weapons with more than 50 kills
                                if (weaponStat.Kills > 50) {
                                    //Check for damage hack
                                    if (weaponStat.DPS > weapon.damage_max) {
                                        //Get the percentage over normal
                                        Double percDiff = (weaponStat.DPS - weapon.damage_max) / weaponStat.DPS;
                                        if (percDiff > (_DpsTriggerLevel / 100)) {
                                            if (percDiff > actedPerc) {
                                                actedPerc = percDiff;
                                                actedWeapon = weaponStat;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            //Could not find actual value for weapon max damage. Use bfxstats weapon damage, without restrictions.
                            if (weaponStat.Kills > 50) {
                                if (weaponStat.DPS > weaponStat.MaxDPS) {
                                    //Get the percentage over normal
                                    Double percDiff = (weaponStat.DPS - weaponStat.MaxDPS) / weaponStat.DPS;
                                    if (percDiff > (_DpsTriggerLevel / 100)) {
                                        if (percDiff > actedPerc) {
                                            actedPerc = percDiff;
                                            actedWeapon = weaponStat;
                                        }
                                    }
                                }
                            }
                            ConsoleWarn("Could not find damage stats for " + weaponStat.ID + " in " + _gameVersion + " library of " + _StatLibrary.Weapons.Count + " weapons. Using BFXStats API damage of " + weaponStat.MaxDPS + " DPS in the meantime.");
                        }
                    }
                }
                if (actedWeapon != null) {
                    acted = true;
                    String formattedName = actedWeapon.ID.Replace("-", "").Replace(" ", "").ToUpper();
                    if (_isTestingAuthorized)
                    {
                        if (!aPlayer.IsLocked())
                        {
                            var banPlayer = aPlayer;
                            banPlayer.Lock("AutoAdmin", TimeSpan.FromMinutes(10));
                            //Special case. Let server live with the hacker for 1 minute then watch them be banned
                            var banDelayThread = new Thread(new ThreadStart(delegate
                            {
                                DebugWrite("Starting a ban delay thread.", 5);
                                try
                                {
                                    Thread.CurrentThread.Name = "bandelay";
                                    var start = UtcDbTime();
                                    ConsoleInfo(banPlayer.GetVerboseName() + " will be banned. Waiting for starting case.");
                                    OnlineAdminTellMessage(banPlayer.GetVerboseName() + " will be banned. Waiting for starting case.");
                                    while (banPlayer.player_online &&
                                           !banPlayer.player_spawnedOnce &&
                                           (UtcDbTime() - start).TotalSeconds < 300)
                                    {
                                        if (!_pluginEnabled)
                                        {
                                            break;
                                        }
                                        //Wait for trigger case to start timer
                                        _threadMasterWaitHandle.WaitOne(1000);
                                    }
                                    //Onced triggered, ban after 90 seconds.
                                    OnlineAdminTellMessage(banPlayer.GetVerboseName() + " triggered timer. [" + formattedName + "-" + (int)actedWeapon.DPS + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "] They will be banned in 90 seconds.");
                                    _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(83));
                                    PlayerTellMessage(banPlayer.player_name, "Thank you for making our system look good. Goodbye.", true, 6);
                                    _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(7));

                                    ConsoleInfo(aPlayer.GetVerboseName() + " auto-banned for damage mod. [" + formattedName + "-" + (int)actedWeapon.DPS + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "]");
                                    if (!debugMode)
                                    {
                                        //Unlock the player
                                        banPlayer.Unlock();
                                        //Create the ban record
                                        var record = new AdKatsRecord
                                        {
                                            record_source = AdKatsRecord.Sources.InternalAutomated,
                                            server_id = _serverInfo.ServerID,
                                            command_type = GetCommandByKey("player_ban_perm"),
                                            command_numeric = 0,
                                            target_name = aPlayer.player_name,
                                            target_player = aPlayer,
                                            source_name = "AutoAdmin",
                                            record_message = _HackerCheckerDPSBanMessage + " [" + formattedName + "-" + (int)actedWeapon.DPS + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "]"
                                        };
                                        //Process the record
                                        QueueRecordForProcessing(record);
                                    }
                                }
                                catch (Exception)
                                {
                                    HandleException(new AdKatsException("Error while runnin ban delay."));
                                }
                                DebugWrite("Exiting a ban delay thread.", 5);
                                LogThreadExit();
                            }));

                            //Start the thread
                            StartAndLogThread(banDelayThread);
                        }
                    }
                    else
                    {
                        ConsoleInfo(aPlayer.GetVerboseName() + " auto-banned for damage mod. [" + formattedName + "-" + (int)actedWeapon.DPS + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "]");
                        if (!debugMode)
                        {
                            //Create the ban record
                            var record = new AdKatsRecord
                            {
                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                server_id = _serverInfo.ServerID,
                                command_type = GetCommandByKey("player_ban_perm"),
                                command_numeric = 0,
                                target_name = aPlayer.player_name,
                                target_player = aPlayer,
                                source_name = "AutoAdmin",
                                record_message = _HackerCheckerDPSBanMessage + " [" + formattedName + "-" + (int)actedWeapon.DPS + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "]"
                            };
                            //Process the record
                            QueueRecordForProcessing(record);
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error running DPS hack check", e));
            }
            return acted;
        }

        private Boolean AimbotHackCheck(AdKatsPlayer aPlayer, Boolean debugMode) {
            Boolean acted = false;
            try {
                if (aPlayer == null || aPlayer.stats == null || aPlayer.stats.WeaponStats == null) {
                    return false;
                }
                List<String> allowedCategories;
                switch (_gameVersion) {
                    case GameVersion.BF3:
                        allowedCategories = new List<string> {
                            "Sub machine guns",
                            "Assault rifles",
                            "Carbines",
                            "Machine guns"
                        };
                        break;
                    case GameVersion.BF4:
                        allowedCategories = new List<string> {
                            "PDW",
                            "ASSAULT RIFLE",
                            "CARBINE",
                            "LMG"
                        };
                        break;
                    default:
                        return false;
                }
                List<AdKatsWeaponStats> topWeapons = aPlayer.stats.WeaponStats.Values.ToList();
                topWeapons.Sort(delegate(AdKatsWeaponStats a1, AdKatsWeaponStats a2) {
                    if (Math.Abs(a1.Kills - a2.Kills) < 0.001) {
                        return 0;
                    }
                    return (a1.Kills < a2.Kills) ? (1) : (-1);
                });

                AdKatsWeaponStats actedWeapon = null;
                Double actedHskr = -1;
                Int32 index = 0;
                foreach (AdKatsWeaponStats weaponStat in topWeapons) {
                    //Break after 15th top weapon
                    if (index++ > 15) {
                        break;
                    }
                    //Only count certain weapon categories
                    if (allowedCategories.Contains(weaponStat.Category)) {
                        StatLibraryWeapon weapon;
                        if (_StatLibrary.Weapons.TryGetValue(weaponStat.ID, out weapon))
                        {
                            //Only take weapons with more than 100 kills, and less than 50% damage
                            if (weaponStat.Kills > 100 && weapon.damage_max < 50)
                            {
                                //Check for aimbot hack
                                DebugWrite("Checking " + weaponStat.ID + " HSKR (" + weaponStat.HSKR + " >? " + (_HskTriggerLevel / 100) + ")", 6);
                                if (weaponStat.HSKR > (_HskTriggerLevel / 100))
                                {
                                    if (weaponStat.HSKR > actedHskr)
                                    {
                                        actedHskr = weaponStat.HSKR;
                                        actedWeapon = weaponStat;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //Only take weapons with more than 100 kills, and less than 50% damage
                            if (weaponStat.Kills > 100 && weaponStat.MaxDPS < 50)
                            {
                                //Check for aimbot hack
                                DebugWrite("Checking " + weaponStat.ID + " HSKR (" + weaponStat.HSKR + " >? " + (_HskTriggerLevel / 100) + ")", 6);
                                if (weaponStat.HSKR > (_HskTriggerLevel / 100))
                                {
                                    if (weaponStat.HSKR > actedHskr)
                                    {
                                        actedHskr = weaponStat.HSKR;
                                        actedWeapon = weaponStat;
                                    }
                                }
                            }
                            ConsoleWarn("Could not find damage stats for " + weaponStat.ID + " in " + _gameVersion + " library of " + _StatLibrary.Weapons.Count + " weapons. Using BFXStats API damage of " + weaponStat.MaxDPS + " DPS in the meantime.");
                        }
                    }
                }
                if (actedWeapon != null) {
                    acted = true;
                    String formattedName = actedWeapon.ID.Replace("-", "").Replace(" ", "").ToUpper();
                    if (_isTestingAuthorized)
                    {
                        if (!aPlayer.IsLocked())
                        {
                            var banPlayer = aPlayer;
                            banPlayer.Lock("AutoAdmin", TimeSpan.FromMinutes(10));
                            //Special case. Let server live with the hacker for 1 minute then watch them be banned
                            var banDelayThread = new Thread(new ThreadStart(delegate
                            {
                                DebugWrite("Starting a ban delay thread.", 5);
                                try
                                {
                                    Thread.CurrentThread.Name = "bandelay";
                                    var start = UtcDbTime();
                                    ConsoleInfo(banPlayer.GetVerboseName() + " will be banned. Waiting for starting case.");
                                    OnlineAdminTellMessage(banPlayer.GetVerboseName() + " will be banned. Waiting for starting case.");
                                    while (banPlayer.player_online && !banPlayer.player_spawnedOnce && (UtcDbTime() - start).TotalSeconds < 300)
                                    {
                                        if (!_pluginEnabled)
                                        {
                                            break;
                                        }
                                        //Wait for trigger case to start timer
                                        _threadMasterWaitHandle.WaitOne(1000);
                                    }
                                    //Onced triggered, ban after 90 seconds.
                                    OnlineAdminTellMessage(banPlayer.GetVerboseName() + " triggered timer. [" + formattedName + "-" + (int)(actedWeapon.HSKR * 100) + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "] They will be banned in 90 seconds.");
                                    _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(83));
                                    if (actedWeapon.HSKR >= .7)
                                    {
                                        PlayerTellMessage(banPlayer.player_name, "Thank you for making our system look good. Goodbye.", true, 6);
                                    }
                                    _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(7));

                                    ConsoleInfo(banPlayer.GetVerboseName() + " auto-banned for aimbot. [" + formattedName + "-" + (int)(actedWeapon.HSKR * 100) + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "]");
                                    if (!debugMode)
                                    {
                                        //Unlock player
                                        banPlayer.Unlock();
                                        //Create the ban record
                                        var record = new AdKatsRecord
                                        {
                                            record_source = AdKatsRecord.Sources.InternalAutomated,
                                            server_id = _serverInfo.ServerID,
                                            command_type = GetCommandByKey("player_ban_perm"),
                                            command_numeric = 0,
                                            target_name = banPlayer.player_name,
                                            target_player = banPlayer,
                                            source_name = "AutoAdmin",
                                            record_message = _HackerCheckerHSKBanMessage + " [" + formattedName + "-" + (int)(actedWeapon.HSKR * 100) + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "]"
                                        };
                                        //Process the record
                                        QueueRecordForProcessing(record);
                                    }
                                }
                                catch (Exception)
                                {
                                    HandleException(new AdKatsException("Error while runnin ban delay."));
                                }
                                DebugWrite("Exiting a ban delay thread.", 5);
                                LogThreadExit();
                            }));

                            //Start the thread
                            StartAndLogThread(banDelayThread);
                        }
                    }
                    else
                    {
                        ConsoleInfo(aPlayer.GetVerboseName() + " auto-banned for aimbot. [" + formattedName + "-" + (int)(actedWeapon.HSKR * 100) + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "]");
                        if (!debugMode)
                        {
                            //Create the ban record
                            var record = new AdKatsRecord
                            {
                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                server_id = _serverInfo.ServerID,
                                command_type = GetCommandByKey("player_ban_perm"),
                                command_numeric = 0,
                                target_name = aPlayer.player_name,
                                target_player = aPlayer,
                                source_name = "AutoAdmin",
                                record_message = _HackerCheckerHSKBanMessage + " [" + formattedName + "-" + (int)(actedWeapon.HSKR * 100) + "-" + (int)actedWeapon.Kills + "-" + (int)actedWeapon.Headshots + "]"
                            };
                            //Process the record
                            QueueRecordForProcessing(record);
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error running HSK hack check.", e));
            }
            return acted;
        }

        private Boolean KPMHackCheck(AdKatsPlayer aPlayer, Boolean debugMode) {
            Boolean acted = false;
            try {
                if (aPlayer == null || aPlayer.stats == null || aPlayer.stats.WeaponStats == null) {
                    return false;
                }
                List<String> allowedCategories;
                switch (_gameVersion) {
                    case GameVersion.BF3:
                        allowedCategories = new List<string> {
                            "Sub machine guns",
                            "Assault rifles",
                            "Carbines",
                            "Machine guns",
                            "Sniper rifles",
                            "Shotguns"
                        };
                        break;
                    case GameVersion.BF4:
                        allowedCategories = new List<string> {
                            "PDW",
                            "ASSAULT RIFLE",
                            "CARBINE",
                            "LMG",
                            "SNIPER RIFLE",
                            "DMR",
                            "SHOTGUN"
                        };
                        break;
                    default:
                        return false;
                }
                List<AdKatsWeaponStats> topWeapons = aPlayer.stats.WeaponStats.Values.ToList();
                topWeapons.Sort(delegate(AdKatsWeaponStats a1, AdKatsWeaponStats a2) {
                    if (a1.Kills == a2.Kills) {
                        return 0;
                    }
                    return (a1.Kills < a2.Kills) ? (1) : (-1);
                });

                AdKatsWeaponStats actedWeapon = null;
                Double actedKpm = -1;
                Int32 index = 0;
                foreach (AdKatsWeaponStats weaponStat in topWeapons) {
                    //Break after 15th top weapon
                    if (index++ > 15) {
                        break;
                    }
                    //Only count certain weapon categories
                    if (allowedCategories.Contains(weaponStat.Category)) {
                        //Only take weapons with more than 100 kills
                        if (weaponStat.Kills > 100) {
                            //Check for KPM limit
                            DebugWrite("Checking " + weaponStat.ID + " KPM (" + String.Format("{0:0.00}", weaponStat.KPM) + " >? " + (_KpmTriggerLevel) + ")", 6);
                            if (weaponStat.KPM > (_KpmTriggerLevel)) {
                                if (weaponStat.KPM > actedKpm) {
                                    actedKpm = weaponStat.KPM;
                                    actedWeapon = weaponStat;
                                }
                            }
                        }
                    }
                }
                if (actedWeapon != null) {
                    acted = true;
                    String formattedName = actedWeapon.ID.Replace("-", "").Replace(" ", "").ToUpper();
                    ConsoleInfo(aPlayer.GetVerboseName() + ((debugMode) ? (" debug") : (" auto")) + "-banned for KPM. [" + formattedName + "-" + String.Format("{0:0.00}", actedWeapon.KPM) + "-" + (int) actedWeapon.Kills + "-" + (int) actedWeapon.Headshots + "]");
                    if (!debugMode) {
                        //Create the ban record
                        var record = new AdKatsRecord {
                            record_source = AdKatsRecord.Sources.InternalAutomated,
                            server_id = _serverInfo.ServerID,
                            command_type = GetCommandByKey("player_ban_perm"),
                            command_numeric = 0,
                            target_name = aPlayer.player_name,
                            target_player = aPlayer,
                            source_name = "AutoAdmin",
                            record_message = _HackerCheckerKPMBanMessage + " [" + formattedName + "-" + String.Format("{0:0.00}", actedWeapon.KPM) + "-" + (int) actedWeapon.Kills + "-" + (int) actedWeapon.Headshots + "]"
                        };
                        //Process the record
                        QueueRecordForProcessing(record);
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error running KPM hack check.", e));
            }
            return acted;
        }

        //all messaging is redirected to global chat for analysis
        public override void OnGlobalChat(String speaker, String message) {
            try
            {
                AdKatsChatMessage chatMessage = new AdKatsChatMessage()
                {
                    Speaker = speaker,
                    Message = message,
                    OriginalMessage = message,
                    Subset = AdKatsChatMessage.ChatSubset.Global,
                    SubsetTeamID = -1,
                    SubsetSquadID = -1
                };
                AdKatsPlayer aPlayer;
                if (_PlayerDictionary.TryGetValue(speaker, out aPlayer))
                {
                    if (aPlayer.frostbitePlayerInfo != null)
                    {
                        chatMessage.SubsetTeamID = aPlayer.frostbitePlayerInfo.TeamID;
                        chatMessage.SubsetSquadID = aPlayer.frostbitePlayerInfo.SquadID;
                    }
                }
                HandleChat(chatMessage);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error when handling OnGlobalChat", e));
            }
        }

        public override void OnTeamChat(String speaker, String message, Int32 teamId)
        {
            try
            {
                AdKatsChatMessage chatMessage = new AdKatsChatMessage()
                {
                    Speaker = speaker,
                    Message = message,
                    OriginalMessage = message,
                    Subset = AdKatsChatMessage.ChatSubset.Team,
                    SubsetTeamID = teamId,
                    SubsetSquadID = -1
                };
                AdKatsPlayer aPlayer;
                if (_PlayerDictionary.TryGetValue(speaker, out aPlayer))
                {
                    if (aPlayer.frostbitePlayerInfo != null)
                    {
                        chatMessage.SubsetSquadID = aPlayer.frostbitePlayerInfo.SquadID;
                    }
                }
                HandleChat(chatMessage);
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error when handling OnTeamChat", e));
            }
        }

        public override void OnSquadChat(String speaker, String message, Int32 teamId, Int32 squadId)
        {
            try
            {
                AdKatsChatMessage chatMessage = new AdKatsChatMessage()
                {
                    Speaker = speaker,
                    Message = message,
                    OriginalMessage = message,
                    Subset = AdKatsChatMessage.ChatSubset.Global,
                    SubsetTeamID = teamId,
                    SubsetSquadID = squadId
                };
                HandleChat(chatMessage);
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error when handling OnSquadChat", e));
            }
        }

        private void HandleChat(AdKatsChatMessage messageObject) {
            DebugWrite("Entering handleChat", 7);
            try {
                if (_pluginEnabled) {
                    //Performance testing area
                    if (messageObject.Speaker == _debugSoldierName) {
                        _commandStartTime = UtcDbTime();
                    }
                    //If message contains comorose just return and ignore
                    if (messageObject.Message.Contains("ComoRose:")) {
                        if(_isTestingAuthorized)
                            ConsoleWarn("Message is comarose, returning.");
                        return;
                    }
                    QueueMessageForParsing(messageObject);
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while processing inbound chat messages.", e));
            }
            DebugWrite("Exiting handleChat", 7);
        }

        public void SendMessageToSource(AdKatsRecord record, String message) {
            DebugWrite("Entering sendMessageToSource", 7);
            try {
                if (String.IsNullOrEmpty(message)) {
                    ConsoleError("message null or empty in sendMessageToSource");
                    return;
                }
                switch (record.record_source) {
                    case AdKatsRecord.Sources.InGame:
                        PlayerSayMessage(record.source_name, message);
                        break;
                    case AdKatsRecord.Sources.ServerCommand:
                        ProconChatWrite(BoldMessage(message));
                        break;
                    case AdKatsRecord.Sources.Settings:
                        ConsoleWrite(message);
                        break;
                    case AdKatsRecord.Sources.Database:
                        //Do nothing, no way to communicate to source when database
                        break;
                    case AdKatsRecord.Sources.InternalAutomated:
                        //Do nothing, no source to communicate with
                        break;
                    case AdKatsRecord.Sources.ExternalPlugin:
                        record.debugMessages.Add(message);
                        break;
                    case AdKatsRecord.Sources.HTTP:
                        record.debugMessages.Add(message);
                        break;
                    default:
                        ConsoleWarn("Command source not set, or not recognized.");
                        break;
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while sending message to record source.", e);
                HandleException(record.record_exception);
            }
            DebugWrite("Exiting sendMessageToSource", 7);
        }

        public Boolean OnlineNonWhitelistSayMessage(String message)
        {
            return OnlineNonWhitelistSayMessage(message, true);
        }

        public Boolean OnlineNonWhitelistSayMessage(String message, Boolean displayProconChat)
        {
            Boolean nonAdminsTold = false;
            Dictionary<String, AdKatsPlayer> whitelistedPlayers = GetOnlinePlayerDictionaryOfGroup("whitelist_spambot");
            if (_isTestingAuthorized) {
                foreach (AdKatsPlayer aPlayer in _PlayerDictionary.Values.ToList()) {
                    if (aPlayer.player_reputation >= _reputationThresholdGood && 
                        !PlayerIsAdmin(aPlayer) && 
                        !whitelistedPlayers.ContainsKey(aPlayer.player_name)) {
                        whitelistedPlayers[aPlayer.player_name] = aPlayer;
                    }
                }
            }
            if (FetchOnlineAdminSoldiers().Any() || whitelistedPlayers.Any())
            {
                var nonAdminSayThread = new Thread(new ThreadStart(delegate
                {
                    DebugWrite("Starting an online non-admin say thread.", 8);
                    try
                    {
                        Thread.CurrentThread.Name = "onlineNonAdminSay";
                        if (displayProconChat)
                        {
                            ProconChatWrite("Say -(Admins" + ((whitelistedPlayers.Any())?(whitelistedPlayers.Values.Aggregate("", (current, aPlayer) => current + ", " + aPlayer.GetVerboseName())):("")) + ") > " + message);
                        }
                        //Process will take ~2 seconds for a full server
                        foreach (AdKatsPlayer aPlayer in FetchOnlineNonAdminSoldiers())
                        {
                            if (whitelistedPlayers.ContainsKey(aPlayer.player_name)) {
                                continue;
                            }
                            nonAdminsTold = true;
                            PlayerSayMessage(aPlayer.player_name, message, false, 1);
                            Thread.Sleep(30);
                        }
                    }
                    catch (Exception)
                    {
                        HandleException(new AdKatsException("Error while running online non-admin say."));
                    }
                    DebugWrite("Exiting an online non-admin say thread.", 8);
                    LogThreadExit();
                }));
                StartAndLogThread(nonAdminSayThread);
            }
            else
            {
                AdminSayMessage(message, displayProconChat);
            }
            return nonAdminsTold;
        }

        public Boolean OnlineNonWhitelistYellMessage(String message)
        {
            return OnlineNonWhitelistYellMessage(message, true);
        }

        public Boolean OnlineNonWhitelistYellMessage(String message, Boolean displayProconChat)
        {
            Boolean nonAdminsTold = false;
            Dictionary<String, AdKatsPlayer> whitelistedPlayers = GetOnlinePlayerDictionaryOfGroup("whitelist_spambot");
            if (FetchOnlineAdminSoldiers().Any() || whitelistedPlayers.Any())
            {
                var nonAdminSayThread = new Thread(new ThreadStart(delegate
                {
                    DebugWrite("Starting an online non-admin yell thread.", 8);
                    try
                    {
                        Thread.CurrentThread.Name = "onlineNonAdminYell";
                        if (displayProconChat)
                        {
                            ProconChatWrite("Yell[" + _YellDuration + "s] (-Admins" + ((whitelistedPlayers.Any()) ? (whitelistedPlayers.Values.Aggregate("", (current, aPlayer) => current + ", " + aPlayer.GetVerboseName())) : ("")) + ") > " + message);
                        }
                        //Process will take ~2 seconds for a full server
                        foreach (AdKatsPlayer aPlayer in FetchOnlineNonAdminSoldiers())
                        {
                            if (whitelistedPlayers.ContainsKey(aPlayer.player_name))
                            {
                                continue;
                            }
                            nonAdminsTold = true;
                            PlayerYellMessage(aPlayer.player_name, message, false, 1);
                            Thread.Sleep(30);
                        }
                    }
                    catch (Exception)
                    {
                        HandleException(new AdKatsException("Error while running online non-admin yell."));
                    }
                    DebugWrite("Exiting an online non-admin yell thread.", 8);
                    LogThreadExit();
                }));
                StartAndLogThread(nonAdminSayThread);
            }
            else
            {
                AdminYellMessage(message, displayProconChat);
            }
            return nonAdminsTold;
        }

        public Boolean OnlineNonWhitelistTellMessage(String message)
        {
            return OnlineNonWhitelistTellMessage(message, true);
        }

        public Boolean OnlineNonWhitelistTellMessage(String message, Boolean displayProconChat)
        {
            Boolean nonAdminsTold = false;
            Dictionary<String, AdKatsPlayer> whitelistedPlayers = GetOnlinePlayerDictionaryOfGroup("whitelist_spambot");
            if (FetchOnlineAdminSoldiers().Any() || whitelistedPlayers.Any())
            {
                var nonAdminSayThread = new Thread(new ThreadStart(delegate
                {
                    DebugWrite("Starting an online non-admin tell thread.", 8);
                    try
                    {
                        Thread.CurrentThread.Name = "onlineNonAdminTell";
                        if (displayProconChat)
                        {
                            ProconChatWrite("Tell[" + _YellDuration + "s] (-Admins" + ((whitelistedPlayers.Any()) ? (whitelistedPlayers.Values.Aggregate("", (current, aPlayer) => current + ", " + aPlayer.GetVerboseName())) : ("")) + ") > " + message);
                        }
                        //Process will take ~2 seconds for a full server
                        foreach (AdKatsPlayer aPlayer in FetchOnlineNonAdminSoldiers())
                        {
                            if (whitelistedPlayers.ContainsKey(aPlayer.player_name))
                            {
                                continue;
                            }
                            nonAdminsTold = true;
                            PlayerTellMessage(aPlayer.player_name, message, false, 1);
                            Thread.Sleep(30);
                        }
                    }
                    catch (Exception)
                    {
                        HandleException(new AdKatsException("Error while running online non-admin tell."));
                    }
                    DebugWrite("Exiting an online non-admin tell thread.", 8);
                    LogThreadExit();
                }));
                StartAndLogThread(nonAdminSayThread);
            }
            else
            {
                AdminTellMessage(message, displayProconChat);
            }
            return nonAdminsTold;
        }

        public Boolean OnlineAdminSayMessage(String message)
        {
            ProconChatWrite(ColorMessageMaroon(BoldMessage(message)));
            Boolean adminsTold = false;
            foreach (AdKatsPlayer player in FetchOnlineAdminSoldiers())
            {
                adminsTold = true;
                PlayerSayMessage(player.player_name, message, true, 1);
            }
            return adminsTold;
        }

        public Boolean OnlineAdminYellMessage(String message)
        {
            ProconChatWrite(ColorMessageMaroon(BoldMessage(message)));
            Boolean adminsTold = false;
            foreach (AdKatsPlayer player in FetchOnlineAdminSoldiers())
            {
                adminsTold = true;
                PlayerYellMessage(player.player_name, message, true, 1);
            }
            return adminsTold;
        }

        public Boolean OnlineAdminTellMessage(String message)
        {
            ProconChatWrite(ColorMessageMaroon(BoldMessage(message)));
            Boolean adminsTold = false;
            foreach (AdKatsPlayer player in FetchOnlineAdminSoldiers())
            {
                adminsTold = true;
                PlayerTellMessage(player.player_name, message, true, 1);
            }
            return adminsTold;
        }

        public void AdminSayMessage(String message) {
            AdminSayMessage(message, true);
        }

        public void AdminSayMessage(String message, Boolean displayProconChat)
        {
            DebugWrite("Entering adminSay", 7);
            try
            {
                if (String.IsNullOrEmpty(message))
                {
                    ConsoleError("message null in adminSay");
                    return;
                }
                if (displayProconChat)
                {
                    ProconChatWrite("Say > " + message);
                }
                var lineSplit = message.Split(new string[] { System.Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
                foreach (String line in lineSplit) {
                    ExecuteCommand("procon.protected.send", "admin.say", line, "all");
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while sending admin say.", e));
            }
            DebugWrite("Exiting adminSay", 7);
        }

        public void PlayerSayMessage(String target, String message) {
            PlayerSayMessage(target, message, true, 1);
        }

        public void PlayerSayMessage(String target, String message, Boolean displayProconChat, Int32 spamCount) {
            DebugWrite("Entering playerSayMessage", 7);
            try {
                if (String.IsNullOrEmpty(target) || String.IsNullOrEmpty(message)) {
                    ConsoleError("target or message null in playerSayMessage");
                    return;
                }
                if (displayProconChat)
                {
                    ProconChatWrite("Say > " + target + " > " + message);
                }
                for (int count = 0; count < spamCount; count++) {
                    var lineSplit = message.Split(new string[] { System.Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
                    foreach (String line in lineSplit) {
                        ExecuteCommand("procon.protected.send", "admin.say", line, "player", target); 
                    }
                    _threadMasterWaitHandle.WaitOne(50);
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while sending message to player.", e));
            }
            DebugWrite("Exiting playerSayMessage", 7);
        }

        public void AdminYellMessage(String message) {
            AdminYellMessage(message, true);
        }

        public void AdminYellMessage(String message, Boolean displayProconChat)
        {
            DebugWrite("Entering adminYell", 7);
            try
            {
                if (String.IsNullOrEmpty(message))
                {
                    ConsoleError("message null in adminYell");
                    return;
                }
                if (displayProconChat)
                {
                    ProconChatWrite("Yell[" + _YellDuration + "s] > " + message);
                }
                ExecuteCommand("procon.protected.send", "admin.yell", ((_gameVersion == GameVersion.BF4) ? (System.Environment.NewLine) : ("")) + message.ToUpper(), _YellDuration + "", "all");
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while sending admin yell.", e));
            }
            DebugWrite("Exiting adminYell", 7);
        }

        public void PlayerYellMessage(String target, String message) {
            PlayerYellMessage(target, message, true, 1);
        }

        public void PlayerYellMessage(String target, String message, Boolean displayProconChat, Int32 spamCount)
        {
            DebugWrite("Entering adminYell", 7);
            try
            {
                if (String.IsNullOrEmpty(message))
                {
                    ConsoleError("message null in adminYell");
                    return;
                }
                if (displayProconChat)
                {
                    ProconChatWrite("Yell[" + _YellDuration + "s] > " + target + " > " + message);
                }
                for (int count = 0; count < spamCount; count++)
                {
                    ExecuteCommand("procon.protected.send", "admin.yell", ((_gameVersion == GameVersion.BF4) ? (System.Environment.NewLine) : ("")) + message.ToUpper(), _YellDuration + "", "player", target);
                    _threadMasterWaitHandle.WaitOne(50);
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while sending admin yell.", e));
            }
            DebugWrite("Exiting adminYell", 7);
        }

        public void AdminTellMessage(String message) {
            AdminTellMessage(message, true);
        }

        public void AdminTellMessage(String message, Boolean displayProconChat)
        {
            if (displayProconChat)
            {
                ProconChatWrite("Tell[" + _YellDuration + "s] > " + message);
            }
            AdminSayMessage(message, false);
            AdminYellMessage(message, false);
        }

        public void PlayerTellMessage(String target, String message) {
            PlayerTellMessage(target, message, true, 1);
        }

        public void PlayerTellMessage(String target, String message, Boolean displayProconChat, Int32 spamCount)
        {
            if (displayProconChat)
            {
                ProconChatWrite("Tell[" + _YellDuration + "s] > " + target + " > " + message);
            }
            PlayerSayMessage(target, message, false, spamCount);
            PlayerYellMessage(target, message, false, spamCount);
        }

        private void QueueMessageForParsing(AdKatsChatMessage messageObject) {
            DebugWrite("Entering queueMessageForParsing", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue message for parsing", 6);
                    lock (_UnparsedMessageQueue) {
                        _UnparsedMessageQueue.Enqueue(messageObject);
                        DebugWrite("Message queued for parsing.", 6);
                        _MessageParsingWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing chat message for parsing.", e));
            }
            DebugWrite("Exiting queueMessageForParsing", 7);
        }

        private void QueueCommandForParsing(AdKatsChatMessage chatMessage)
        {
            DebugWrite("Entering queueCommandForParsing", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue command for parsing", 6);
                    lock (_UnparsedCommandQueue) {
                        _UnparsedCommandQueue.Enqueue(chatMessage);
                        DebugWrite("Command sent to unparsed commands.", 6);
                        _CommandParsingWaitHandle.Set();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing command for parsing.", e));
            }
            DebugWrite("Exiting queueCommandForParsing", 7);
        }

        private void MessagingThreadLoop() {
            try {
                DebugWrite("MESSAGE: Starting Messaging Thread", 1);
                Thread.CurrentThread.Name = "messaging";
                DateTime loopStart = UtcDbTime();
                while (true) {
                    try {
                        DebugWrite("MESSAGE: Entering Messaging Thread Loop", 7);
                        if (!_pluginEnabled) {
                            DebugWrite("MESSAGE: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }

                        //Get all unparsed inbound messages
                        Queue<AdKatsChatMessage> inboundMessages;
                        if (_UnparsedMessageQueue.Count > 0) {
                            DebugWrite("MESSAGE: Preparing to lock messaging to retrive new messages", 7);
                            lock (_UnparsedMessageQueue) {
                                DebugWrite("MESSAGE: Inbound messages found. Grabbing.", 6);
                                //Grab all messages in the queue
                                inboundMessages = new Queue<AdKatsChatMessage>(_UnparsedMessageQueue.ToArray());
                                //Clear the queue for next run
                                _UnparsedMessageQueue.Clear();
                            }
                        }
                        else {
                            DebugWrite("MESSAGE: No inbound messages. Waiting for Input.", 6);
                            //Wait for input
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _MessageParsingWaitHandle.Reset();
                            _MessageParsingWaitHandle.WaitOne(TimeSpan.FromSeconds(5));
                            loopStart = UtcDbTime();
                            continue;
                        }

                        //Loop through all messages in order that they came in
                        while (inboundMessages.Count > 0)
                        {
                            if (!_pluginEnabled)
                            {
                                break;
                            }
                            DebugWrite("MESSAGE: begin reading message", 6);
                            //Dequeue the first/next message
                            AdKatsChatMessage messageObject = inboundMessages.Dequeue();

                            AdKatsPlayer aPlayer;
                            if (_PlayerDictionary.TryGetValue(messageObject.Speaker, out aPlayer))
                            {
                                if (aPlayer.player_guid == "EA_18141AAC8A0A9BB2A2C8093F6E00B936" && messageObject.Message.ToLower().Contains("obama")) {
                                    ExecuteCommand("procon.protected.send", "admin.killPlayer", aPlayer.player_name);
                                }
                                if (!_AFKIgnoreChat)
                                {
                                    //Update player last action
                                    aPlayer.lastAction = UtcDbTime();
                                }
                            }

                            Boolean isCommand = false;
                            //Check if the message is a command
                            if (messageObject.Message.StartsWith("@") || messageObject.Message.StartsWith("!") || messageObject.Message.StartsWith(".")) {
                                messageObject.Message = messageObject.Message.Substring(1);
                                isCommand = true;
                            }
                            else if (messageObject.Message.StartsWith("/@") || messageObject.Message.StartsWith("/!") || messageObject.Message.StartsWith("/."))
                            {
                                messageObject.Message = messageObject.Message.Substring(2);
                                isCommand = true;
                            }
                            else if (messageObject.Message.StartsWith("/"))
                            {
                                messageObject.Message = messageObject.Message.Substring(1);
                                isCommand = true;
                            }

                            if (isCommand && _threadsReady && _firstPlayerListComplete) {
                                String[] splitMessage = messageObject.Message.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                                if (splitMessage.Length == 3 && 
                                    splitMessage[0] == "AdKatsInstanceCheck") {
                                    //Message is an instance check, confirm it is from this instance
                                    if (splitMessage[1] == _instanceKey) {
                                        DebugWrite("Instance confirmed. " + splitMessage[2], 7);
                                    }
                                    else {
                                        //There is another instance of AdKats running on this server, check which is superior
                                        String onlineDurationString = splitMessage[2];
                                        Int32 onlineDurationInt;
                                        if (Int32.TryParse(onlineDurationString, out onlineDurationInt)) {
                                            if (onlineDurationInt > Math.Round((UtcDbTime() - _AdKatsRunningTime).TotalSeconds)) {
                                                //Other instance has been online longer, disable this instance
                                                OnlineAdminSayMessage("Shutting down this AdKats instance, another instance is already online.");
                                                ConsoleWarn("Shutting down this AdKats instance, another instance is already online.");
                                                _useKeepAlive = false;
                                                Disable();
                                            }
                                            else {
                                                OnlineAdminSayMessage("Warning, another running instance of AdKats was detected on this server. That instance will terminate shortly.");
                                            }
                                        }
                                        else {
                                            ConsoleError("Unable to parse plugin instance duration.");
                                        }
                                    }
                                }
                            }

                            if (_PostStatLoggerChatManually)
                            {
                                //Upload the chat message
                                UploadChatLog(messageObject);
                            }
                            
                            //check for player mute case
                            //ignore if it's a server call
                            if (messageObject.Speaker != "Server")
                            {
                                lock (_RoundMutedPlayers) {
                                    //Check if the player is muted
                                    DebugWrite("MESSAGE: Checking for mute case.", 7);
                                    if (_RoundMutedPlayers.ContainsKey(messageObject.Speaker))
                                    {
                                        if (_MutedPlayerIgnoreCommands && isCommand) {
                                            DebugWrite("Player muted, but ignoring since message is command.", 3);
                                        }
                                        else
                                        {
                                            DebugWrite("MESSAGE: Player is muted and valid. Acting.", 7);
                                            //Increment the muted chat count
                                            _RoundMutedPlayers[messageObject.Speaker] = _RoundMutedPlayers[messageObject.Speaker] + 1;
                                            //Create record
                                            var record = new AdKatsRecord();
                                            record.record_source = AdKatsRecord.Sources.InternalAutomated;
                                            record.server_id = _serverInfo.ServerID;
                                            record.source_name = "PlayerMuteSystem";
                                            _PlayerDictionary.TryGetValue(messageObject.Speaker, out record.target_player);
                                            record.target_name = messageObject.Speaker;
                                            if (_RoundMutedPlayers[messageObject.Speaker] > _MutedPlayerChances)
                                            {
                                                record.record_message = _MutedPlayerKickMessage;
                                                record.command_type = GetCommandByKey("player_kick");
                                                record.command_action = GetCommandByKey("player_kick");
                                            }
                                            else
                                            {
                                                record.record_message = _MutedPlayerKillMessage;
                                                record.command_type = GetCommandByKey("player_kill");
                                                record.command_action = GetCommandByKey("player_kill");
                                                AdminSayMessage(record.GetTargetNames() + " killed for talking while muted. They can speak again next round.");
                                            }
                                            QueueRecordForProcessing(record);
                                            continue;
                                        }
                                    }
                                }
                                if (_isTestingAuthorized && _gameVersion == GameVersion.BF4)
                                {
                                    var lowerM = " " + messageObject.Message.ToLower() + " ";
                                    if (lowerM.Contains(" ping") || lowerM.Contains(" pings ") || lowerM.Contains(" ping.") || lowerM.Contains(" ping,"))
                                    {
                                        if (!PlayerIsAdmin(aPlayer))
                                        {
                                            PlayerTellMessage(messageObject.Speaker, "Ping limit is 300 when over 50 players. Missing pings are kicked.");
                                            continue;
                                        }
                                    }
                                }
                            }
                            if (isCommand)
                            {
                                QueueCommandForParsing(messageObject);
                            }
                            else
                            {
                                DebugWrite("MESSAGE: Message is regular chat. Ignoring.", 7);
                            }
                        }
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            HandleException(new AdKatsException("Messaging thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in Messaging thread. Skipping current loop.", e));
                    }
                }
                DebugWrite("MESSAGE: Ending Messaging Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in messaging thread.", e));
            }
        }

        private void QueuePlayerForForceMove(CPlayerInfo player) {
            DebugWrite("Entering queuePlayerForForceMove", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to queue player for TeamSwap ", 6);
                    lock (_TeamswapForceMoveQueue) {
                        _TeamswapForceMoveQueue.Enqueue(player);
                        _TeamswapWaitHandle.Set();
                        DebugWrite("Player queued for TeamSwap", 6);
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing player for force-move.", e));
            }
            DebugWrite("Exiting queuePlayerForForceMove", 7);
        }

        private void QueuePlayerForMove(CPlayerInfo player) {
            DebugWrite("Entering queuePlayerForMove", 7);
            try {
                if (_pluginEnabled) {
                    DebugWrite("Preparing to add player to 'on-death' move dictionary.", 6);
                    lock (_TeamswapOnDeathCheckingQueue) {
                        if (!_TeamswapOnDeathMoveDic.ContainsKey(player.SoldierName)) {
                            _TeamswapOnDeathMoveDic.Add(player.SoldierName, player);
                            _TeamswapWaitHandle.Set();
                            DebugWrite("Player added to 'on-death' move dictionary.", 6);
                        }
                        else {
                            DebugWrite("Player already in 'on-death' move dictionary.", 6);
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing player for move.", e));
            }
            DebugWrite("Exiting queuePlayerForMove", 7);
        }

        //runs through both team swap queues and performs the swapping
        public void TeamswapThreadLoop() {
            //assume the max player count per team is 32 if no server info has been provided
            Int32 maxTeamPlayerCount = 32;
            try {
                DebugWrite("TSWAP: Starting TeamSwap Thread", 1);
                Thread.CurrentThread.Name = "TeamSwap";
                DateTime loopStart = UtcDbTime();
                while (true) {
                    try {
                        DebugWrite("TSWAP: Entering TeamSwap Thread Loop", 7);
                        if (!_pluginEnabled) {
                            DebugWrite("TSWAP: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }
                        AdKatsTeam team1;
                        AdKatsTeam team2;
                        lock (_teamDictionary) {
                            if (!_teamDictionary.TryGetValue(1, out team1)) {
                                DebugWrite("Team 1 description was not found. Unable to continue.", 1);
                                _threadMasterWaitHandle.WaitOne(5000);
                                continue;
                            }
                            if (!_teamDictionary.TryGetValue(2, out team2)) {
                                DebugWrite("Team 2 description was not found. Unable to continue.", 1);
                                _threadMasterWaitHandle.WaitOne(5000);
                                continue;
                            }
                        }

                        //Refresh Max Player Count, needed for responsive server size
                        if (_serverInfo.InfoObject != null && _serverInfo.InfoObject.MaxPlayerCount != maxTeamPlayerCount)
                        {
                            maxTeamPlayerCount = _serverInfo.InfoObject.MaxPlayerCount / 2;
                        }

                        //Get players who died that need moving
                        if ((_TeamswapOnDeathMoveDic.Count > 0 && _TeamswapOnDeathCheckingQueue.Count > 0) || _TeamswapForceMoveQueue.Count > 0) {
                            DebugWrite("TSWAP: Preparing to lock TeamSwap queues", 4);

                            _PlayerListUpdateWaitHandle.Reset();
                            //Wait for listPlayers to finish, max 10 seconds
                            if (!_PlayerListUpdateWaitHandle.WaitOne(TimeSpan.FromSeconds(10))) {
                                DebugWrite("ListPlayers ran out of time for TeamSwap. 10 sec.", 4);
                            }

                            Queue<CPlayerInfo> movingQueue;
                            Queue<CPlayerInfo> checkingQueue;
                            lock (_TeamswapForceMoveQueue) {
                                movingQueue = new Queue<CPlayerInfo>(_TeamswapForceMoveQueue.ToArray());
                                _TeamswapForceMoveQueue.Clear();
                            }
                            lock (_TeamswapOnDeathCheckingQueue) {
                                checkingQueue = new Queue<CPlayerInfo>(_TeamswapOnDeathCheckingQueue.ToArray());
                                _TeamswapOnDeathCheckingQueue.Clear();
                            }

                            //Check for "on-death" move players
                            while (_TeamswapOnDeathMoveDic.Count > 0 && checkingQueue.Count > 0) {
                                if (!_pluginEnabled) {
                                    break;
                                }
                                //Dequeue the first/next player
                                String playerName = checkingQueue.Dequeue().SoldierName;
                                CPlayerInfo player;
                                //If they are 
                                if (_TeamswapOnDeathMoveDic.TryGetValue(playerName, out player)) {
                                    //Player has died, remove from the dictionary
                                    _TeamswapOnDeathMoveDic.Remove(playerName);
                                    //Add to move queue
                                    movingQueue.Enqueue(player);
                                }
                            }

                            while (movingQueue.Count > 0) {
                                if (!_pluginEnabled) {
                                    break;
                                }
                                CPlayerInfo player = movingQueue.Dequeue();
                                switch (player.TeamID) {
                                    case 1:
                                        if (!ContainsCPlayerInfo(_Team1MoveQueue, player.SoldierName)) {
                                            _Team1MoveQueue.Enqueue(player);
                                            PlayerSayMessage(player.SoldierName, "You have been added to the (" + team1.TeamName + " -> " + team2.TeamName + ") TeamSwap queue in position " + (IndexOfCPlayerInfo(_Team1MoveQueue, player.SoldierName) + 1) + ".");
                                        }
                                        else {
                                            PlayerSayMessage(player.SoldierName, team2.TeamName + " Team Full (" + team2.TeamPlayerCount + "/" + maxTeamPlayerCount + "). You are in queue position " + (IndexOfCPlayerInfo(_Team1MoveQueue, player.SoldierName) + 1));
                                        }
                                        break;
                                    case 2:
                                        if (!ContainsCPlayerInfo(_Team2MoveQueue, player.SoldierName)) {
                                            _Team2MoveQueue.Enqueue(player);
                                            PlayerSayMessage(player.SoldierName, "You have been added to the (" + team2.TeamName + " -> " + team1.TeamName + ") TeamSwap queue in position " + (IndexOfCPlayerInfo(_Team2MoveQueue, player.SoldierName) + 1) + ".");
                                        }
                                        else {
                                            PlayerSayMessage(player.SoldierName, team1.TeamName + " Team Full (" + team1.TeamPlayerCount + "/" + maxTeamPlayerCount + "). You are in queue position " + (IndexOfCPlayerInfo(_Team2MoveQueue, player.SoldierName) + 1));
                                        }
                                        break;
                                }
                            }
                        }
                        DebugWrite("Team Info: " + team1.TeamName + ": " + team1.TeamPlayerCount + "/" + maxTeamPlayerCount + " " + team2.TeamName + ": " + team2.TeamPlayerCount + "/" + maxTeamPlayerCount, 5);
                        if (_Team2MoveQueue.Count > 0 || _Team1MoveQueue.Count > 0) {
                            //Perform player moving
                            Boolean movedPlayer;
                            do {
                                if (!_pluginEnabled) {
                                    break;
                                }
                                movedPlayer = false;
                                if (_Team2MoveQueue.Count > 0) {
                                    if (team1.TeamPlayerCount < maxTeamPlayerCount) {
                                        CPlayerInfo player = _Team2MoveQueue.Dequeue();
                                        AdKatsPlayer dicPlayer;
                                        if (_PlayerDictionary.TryGetValue(player.SoldierName, out dicPlayer)) {
                                            if (dicPlayer.frostbitePlayerInfo.TeamID == 1) {
                                                //Skip the kill/swap if they are already on the goal team by some other means
                                                continue;
                                            }
                                        }
                                        if (String.IsNullOrEmpty(player.SoldierName)) {
                                            ConsoleError("soldiername null in team 2 -> 1 teamswap");
                                        }
                                        else
                                        {
                                            DebugWrite("MULTIBalancer Unswitcher Disabled", 3);
                                            ExecuteCommand("procon.protected.plugins.call", "MULTIbalancer", "UpdatePluginData", "AdKats", "bool", "DisableUnswitcher", "True");
                                            _MULTIBalancerUnswitcherDisabled = true;
                                            ExecuteCommand("procon.protected.send", "admin.movePlayer", player.SoldierName, "1", "1", "true");
                                            dicPlayer.RequiredTeam = _teamDictionary[1];
                                            _LastPlayerMoveIssued = UtcDbTime();
                                            team1.TeamPlayerCount++;
                                            team2.TeamPlayerCount--;
                                        }
                                        PlayerSayMessage(player.SoldierName, "Swapping you from team " + team2.TeamName + " to team " + team1.TeamName);
                                        movedPlayer = true;
                                        _threadMasterWaitHandle.WaitOne(100);
                                    }
                                }
                                if (_Team1MoveQueue.Count > 0) {
                                    if (team2.TeamPlayerCount < maxTeamPlayerCount) {
                                        CPlayerInfo player = _Team1MoveQueue.Dequeue();
                                        AdKatsPlayer dicPlayer;
                                        if (_PlayerDictionary.TryGetValue(player.SoldierName, out dicPlayer)) {
                                            if (dicPlayer.frostbitePlayerInfo.TeamID == 2) {
                                                //Skip the kill/swap if they are already on the goal team by some other means
                                                continue;
                                            }
                                        }
                                        if (String.IsNullOrEmpty(player.SoldierName)) {
                                            ConsoleError("soldiername null in team 1 -> 2 teamswap");
                                        }
                                        else
                                        {
                                            DebugWrite("MULTIBalancer Unswitcher Disabled", 3);
                                            ExecuteCommand("procon.protected.plugins.call", "MULTIbalancer", "UpdatePluginData", "AdKats", "bool", "DisableUnswitcher", "True");
                                            _MULTIBalancerUnswitcherDisabled = true;
                                            ExecuteCommand("procon.protected.send", "admin.movePlayer", player.SoldierName, "2", "1", "true");
                                            dicPlayer.RequiredTeam = _teamDictionary[2];
                                            _LastPlayerMoveIssued = UtcDbTime();
                                            team2.TeamPlayerCount++;
                                            team1.TeamPlayerCount--;
                                        }
                                        PlayerSayMessage(player.SoldierName, "Swapping you from team " + team1.TeamName + " to team " + team2.TeamName);
                                        movedPlayer = true;
                                    }
                                }
                            } while (false);
                        }
                        else {
                            DebugWrite("TSWAP: No players to swap. Waiting for Input.", 6);
                            //There are no players to swap, wait.
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _TeamswapWaitHandle.Reset();
                            _TeamswapWaitHandle.WaitOne(TimeSpan.FromSeconds(5));
                            loopStart = UtcDbTime();
                            continue;
                        }
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            HandleException(new AdKatsException("TeamSwap thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in TeamSwap thread. Skipping current loop.", e));
                    }
                    _TeamswapWaitHandle.Reset();
                    _TeamswapWaitHandle.WaitOne(TimeSpan.FromSeconds(10));
                }
                DebugWrite("TSWAP: Ending TeamSwap Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in teamswap thread.", e));
            }
        }

        //Whether a move queue contains a given player
        private bool ContainsCPlayerInfo(Queue<CPlayerInfo> queueList, String player) {
            DebugWrite("Entering containsCPlayerInfo", 7);
            try {
                CPlayerInfo[] playerArray = queueList.ToArray();
                for (Int32 index = 0; index < queueList.Count; index++) {
                    if (playerArray[index].SoldierName == player) {
                        return true;
                    }
                }
                return false;
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while checking for player in teamswap queue.", e));
            }
            DebugWrite("Exiting containsCPlayerInfo", 7);
            return false;
        }

        //The index of a player in the move queue
        private Int32 IndexOfCPlayerInfo(Queue<CPlayerInfo> queueList, String player) {
            DebugWrite("Entering getCPlayerInfo", 7);
            try {
                CPlayerInfo[] playerArray = queueList.ToArray();
                for (Int32 i = 0; i < queueList.Count; i++) {
                    if (playerArray[i].SoldierName == player) {
                        return i;
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while getting index of player in teamswap queue.", e));
            }
            DebugWrite("Exiting getCPlayerInfo", 7);
            return -1;
        }

        private void QueueRecordForProcessing(AdKatsRecord record) {
            DebugWrite("Entering queueRecordForProcessing", 7);
            try {
                if (record.command_action == null) {
                    if (record.command_type == null) {
                        record.record_exception = HandleException(new AdKatsException("Attempted to create a record with no command. " + ((String.IsNullOrEmpty(record.source_name)) ? ("NOSOURCE") : (record.source_name)) + "|" + ((String.IsNullOrEmpty(record.record_message)) ? ("NOMESSAGE") : (record.record_message))));
                        FinalizeRecord(record);
                        return;
                    }
                    record.command_action = record.command_type;
                }
                if (!record.record_action_executed) {
                    //Check for command lock
                    if (record.target_player != null && record.target_player.IsLocked())
                    {
                        SendMessageToSource(record, record.GetTargetNames() + " is command locked by " + record.target_player.GetLockSource() + ". Please wait for unlock [" + FormatTimeString(record.target_player.GetLockRemaining(), 3) + "].");
                        FinalizeRecord(record);
                        return;
                    }
                    //Power level exclusion
                    if (record.source_player != null && record.target_player != null &&
                        record.source_player.player_role.role_powerLevel < record.target_player.player_role.role_powerLevel &&
                        (record.command_type.command_key == "player_kill" ||
                         record.command_type.command_key == "player_kick" ||
                         record.command_type.command_key == "player_ban_temp" ||
                         record.command_type.command_key == "player_ban_perm" ||
                         record.command_type.command_key == "player_ban_perm_future" ||
                         record.command_type.command_key == "player_punish" ||
                         record.command_type.command_key == "player_forgive" ||
                         record.command_type.command_key == "player_mute" ||
                         record.command_type.command_key == "player_move" ||
                         record.command_type.command_key == "player_fmove" ||
                         record.command_type.command_key == "self_lead" ||
                         record.command_type.command_key == "player_pull" ||
                         record.command_type.command_key == "player_lock"))
                    {
                        SendMessageToSource(record, "You cannot issue " + record.command_type.command_name + " on " + record.target_player.GetVerboseName()  + " their power level ("  + record.target_player.player_role.role_powerLevel + ") is higher than yours (" + record.source_player.player_role.role_powerLevel + ")");
                        FinalizeRecord(record);
                        return;
                    }
                    //Command timeouts
                    if (record.command_action != null && _commandTimeoutDictionary.ContainsKey(record.command_action.command_key) && !record.record_action_executed)
                    {
                        if (record.target_player != null && !record.TargetPlayersLocal.Any())
                        {
                            //Cancel call if record is on timeout for single player
                            if (record.target_player.TargetedRecords.Any(aRecord => aRecord.command_action.command_key == record.command_action.command_key && aRecord.record_time.AddSeconds(Math.Abs(_commandTimeoutDictionary[record.command_action.command_key](this))) > UtcDbTime()))
                            {
                                SendMessageToSource(record, record.command_type.command_name + " on timeout for " + record.GetTargetNames());
                                FinalizeRecord(record);
                                return;
                            }
                        }
                        else if (record.TargetPlayersLocal.Any())
                        {
                            //Cancel call if record is on timeout for any targeted players
                            foreach (AdKatsPlayer aPlayer in record.TargetPlayersLocal)
                            {
                                if (aPlayer.TargetedRecords.Any(aRecord => aRecord.command_action.command_key == record.command_action.command_key && aRecord.record_time.AddSeconds(Math.Abs(_commandTimeoutDictionary[record.command_action.command_key](this))) > UtcDbTime()))
                                {
                                    SendMessageToSource(record, record.command_type.command_name + " on timeout for " + aPlayer.GetVerboseName());
                                    FinalizeRecord(record);
                                    return;
                                }
                            }
                        }
                    }
                    if ( record.target_player != null && 
                        (record.command_type.command_key == "player_report" || record.command_type.command_key == "player_calladmin") && 
                         record.target_player.TargetedRecords.Any(
                            targetedRecord =>
                                (targetedRecord.command_action.command_key == "player_kill" ||
                                 targetedRecord.command_action.command_key == "player_kill_lowpop" ||
                                 targetedRecord.command_action.command_key == "player_kill_repeat" ||
                                 targetedRecord.command_action.command_key == "player_kill_force" ||
                                 targetedRecord.command_action.command_key == "player_kick" ||
                                 targetedRecord.command_action.command_key == "player_ban_temp" ||
                                 targetedRecord.command_action.command_key == "player_ban_perm" ||
                                 targetedRecord.command_action.command_key == "player_ban_perm_future" ||
                                 targetedRecord.command_action.command_key == "player_punish" ||
                                 targetedRecord.command_action.command_key == "player_mute" ||
                                 targetedRecord.command_action.command_key == "player_say" ||
                                 targetedRecord.command_action.command_key == "player_yell" ||
                                 targetedRecord.command_action.command_key == "player_tell") && 
                                (UtcDbTime() - targetedRecord.record_time).TotalSeconds < 60))
                    {
                        OnlineAdminSayMessage("Report on " + record.GetTargetNames() + " blocked. Player already acted on.");
                        SendMessageToSource(record, "Report on " + record.GetTargetNames() + " blocked. Player already acted on.");
                        FinalizeRecord(record);
                        return;
                    }
                    //Special command case
                    DebugWrite("Preparing to check " + record.command_type.command_key + " record for pre-upload processing.", 5);
                    switch (record.command_type.command_key)
                    {
                        case "player_blacklistdisperse":
                            {
                                List<AdKatsSpecialPlayer> matchingPlayers = GetMatchingASPlayersOfGroup("blacklist_dispersion", record.target_player);
                                if (matchingPlayers.Any())
                                {
                                    SendMessageToSource(record, matchingPlayers.Count + " matching player(s) already under dispersion for this server.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                DebugWrite(record.command_type.command_key + " record allowed to continue processing.", 5);
                                if (record.source_name == "DispersionManager")
                                {
                                    OnlineAdminSayMessage(record.target_name + " automatically added to dispersion for this server.");
                                }
                            }
                            break;
                        case "self_rules": {
                                if (record.source_name != record.target_name &&
                                    record.target_player != null)
                                {
                                    if (PlayerIsAdmin(record.target_player))
                                    {
                                        SendMessageToSource(record, ((record.source_name.ToLower().Contains("pepsi")) ? ("Bad Pepsi. ") : ("")) + record.GetTargetNames() + " is an admin, they already know the server rules.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    if (record.target_player.player_reputation > _reputationThresholdGood) {
                                        SendMessageToSource(record, record.GetTargetNames() + " is reputable, they know the server rules.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                }
                                    
                            }
                            break;
                        case "player_forgive":
                            {
                                if (_isTestingAuthorized && record.target_player != null && FetchPoints(record.target_player, _CombineServerPunishments) <= 0)
                                {
                                    SendMessageToSource(record, record.GetTargetNames() + " does not have any infractions to forgive.");
                                    FinalizeRecord(record);
                                    return;
                                }
                            }
                            break;
                        case "player_report":
                        case "player_calladmin":
                            {
                                if (record.target_player != null && 
                                    !record.target_player.player_online &&
                                    record.target_player.TargetedRecords.Any(
                                        aRecord => 
                                            (aRecord.command_action.command_key == "player_kick" ||
                                            aRecord.command_action.command_key == "player_ban_temp" ||
                                            aRecord.command_action.command_key == "player_ban_perm") &&
                                            (UtcDbTime() - aRecord.record_time).TotalSeconds < 300)) {
                                    SendMessageToSource(record, record.GetTargetNames() + " has already been removed from the server by admin.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (_isTestingAuthorized)
                                {
                                    var lowerM = " " + record.record_message.ToLower() + " ";
                                    if (lowerM.Contains("bipod"))
                                    {
                                        SendMessageToSource(record, "Bipod related actions are not bannable.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    if (lowerM.Contains(" ping") || lowerM.Contains(" pings ") || lowerM.Contains(" ping.") || lowerM.Contains(" ping,"))
                                    {
                                        SendMessageToSource(record, "Automatic system handles ping, do not report for it.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                }
                            }
                            break;
                        case "player_pm_send":
                            {
                                if (record.target_player != null && record.source_player != null) {
                                    if (record.target_player.player_guid == record.source_player.player_guid) {
                                        SendMessageToSource(record, "foreveralone.jpg (You cannot start a conversation with yourself.)");
                                    }
                                }
                                else {
                                    SendMessageToSource(record, "Invalid players when trying to start conversation.");
                                }
                            }
                            break;
                        case "player_lock":
                            {
                                //Check if already locked
                                if (record.target_player != null && record.target_player.IsLocked())
                                {
                                    SendMessageToSource(record, record.GetTargetNames() + " is already locked by " + record.target_player.GetLockSource() + " for " + FormatTimeString(record.target_player.GetLockRemaining(), 3) + ".");
                                    FinalizeRecord(record);
                                    return;
                                }
                            }
                            break;
                        case "player_unlock":
                            {
                                //Check if already locked
                                if (record.target_player != null &&
                                    record.target_player.IsLocked() &&
                                    record.target_player.GetLockSource() != record.source_name)
                                {
                                    SendMessageToSource(record, record.GetTargetNames() + " is locked by " + record.target_player.GetLockSource() + ", either they can unlock them, or after " + FormatTimeString(record.target_player.GetLockRemaining(), 3) + " the player will be automatically unlocked.");
                                    FinalizeRecord(record);
                                    return;
                                }
                            }
                            break;
                        case "self_surrender":
                        case "self_votenext":
                            {
                                if (!_surrenderVoteEnable)
                                {
                                    SendMessageToSource(record, "Surrender Vote must be enabled in AdKats settings to use this command.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (_roundState != RoundState.Playing)
                                {
                                    SendMessageToSource(record, "Round state must be playing to use surrender. Current: " + _roundState);
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (record.source_player != null && record.source_player.player_type == PlayerType.Spectator && !PlayerIsAdmin(record.source_player))
                                {
                                    SendMessageToSource(record, "You cannot use !" + GetCommandByKey("self_surrender").command_text + " or !" + GetCommandByKey("self_votenext").command_text + " as a spectator.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (_surrenderVoteSucceeded) {
                                    SendMessageToSource(record, "Surrender already succeeded.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (_surrenderVoteList.Contains(record.source_name))
                                {
                                    SendMessageToSource(record, "You already voted! You can cancel your vote with @" + GetCommandByKey("command_cancel").command_text);
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (!_surrenderVoteActive)
                                {
                                    Int32 playerCount = _PlayerDictionary.Values.Count(player => player.player_type == PlayerType.Player);
                                    if (playerCount < _surrenderVoteMinimumPlayerCount)
                                    {
                                        SendMessageToSource(record, _surrenderVoteMinimumPlayerCount + " players needed to start Surrender Vote. Current: " + playerCount);
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    AdKatsTeam team1 = _teamDictionary[1];
                                    AdKatsTeam team2 = _teamDictionary[2];
                                    Int32 ticketGap = Math.Abs(team1.TeamTicketCount - team2.TeamTicketCount);
                                    if (ticketGap < _surrenderVoteMinimumTicketGap)
                                    {
                                        SendMessageToSource(record, _surrenderVoteMinimumTicketGap + " ticket gap needed to start Surrender Vote. Current: " + ticketGap);
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    Double ticketRateGap = Math.Abs(team1.TeamTicketDifferenceRate - team2.TeamTicketDifferenceRate);
                                    if (_surrenderVoteTicketRateGapEnable && ticketRateGap < _surrenderVoteMinimumTicketRateGap)
                                    {
                                        SendMessageToSource(record, _surrenderVoteMinimumTicketRateGap + " ticket rate gap needed to start Surrender Vote. Current: " + Math.Round(ticketRateGap, 2));
                                        FinalizeRecord(record);
                                        return;
                                    }
                                }
                                //Replace type if needed
                                var surrenderCommand = GetCommandByKey("self_surrender");
                                var votenextCommand = GetCommandByKey("self_votenext");
                                if (record.source_player == null) {
                                    //Record is external, votenext must me used
                                    if (record.command_type.command_key == surrenderCommand.command_key) {
                                        record.command_type = votenextCommand;
                                        record.command_action = votenextCommand;
                                        record.record_message = "Player Voted for Next Round";
                                    }
                                }
                                else if (PlayerIsWinning(record.source_player)) {
                                    //Player is winning, votenext must me used
                                    if (record.command_type.command_key == surrenderCommand.command_key)
                                    {
                                        record.command_type = votenextCommand;
                                        record.command_action = votenextCommand;
                                        record.record_message = "Player Voted for Next Round";
                                    }
                                }
                                else
                                {
                                    //Player is losing, surrender must me used
                                    if (record.command_type.command_key == votenextCommand.command_key)
                                    {
                                        record.command_type = surrenderCommand;
                                        record.command_action = surrenderCommand;
                                        record.record_message = "Player Voted for Surrender";
                                    }
                                }
                            }
                            break;
                        case "self_nosurrender":
                            {
                                if (!_surrenderVoteEnable)
                                {
                                    SendMessageToSource(record, "Surrender Vote must be enabled in AdKats settings to use this command.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (_roundState != RoundState.Playing)
                                {
                                    SendMessageToSource(record, "Round state must be playing to vote against surrender. Current: " + _roundState);
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (_surrenderVoteSucceeded)
                                {
                                    SendMessageToSource(record, "Surrender already succeeded.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (_nosurrenderVoteList.Contains(record.source_name))
                                {
                                    SendMessageToSource(record, "You already voted against surrender!");
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (!_surrenderVoteActive)
                                {
                                    SendMessageToSource(record, "A surrender vote must be active to vote against it.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (record.source_player != null && PlayerIsWinning(record.source_player))
                                {
                                    SendMessageToSource(record, "You cannot use !" + GetCommandByKey("self_nosurrender").command_text + " from the winning team.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                if (record.source_player != null && record.source_player.player_type == PlayerType.Spectator && !PlayerIsAdmin(record.source_player))
                                {
                                    SendMessageToSource(record, "You cannot use !" + GetCommandByKey("self_nosurrender").command_text + " as a spectator.");
                                    FinalizeRecord(record);
                                    return;
                                }
                            }
                            break;
                    }
                    //Conditional command replacement (single target only)
                    if (_isTestingAuthorized &&
                        _populationStatus == PopulationState.Low &&
                        record.target_player != null &&
                        record.command_type.command_key == "player_punish")
                    {
                        int punishCount = record.target_player.TargetedRecords.Count(aRecord => aRecord.command_type.command_key == "player_punish");
                        int killCount = record.target_player.TargetedRecords.Count(aRecord => aRecord.command_type.command_key == "player_kill");
                        if (killCount < 2 ||
                           (killCount < 4 && punishCount == 1))
                        {
                            if (record.source_name == "AutoAdmin" || record.source_name == "ProconAdmin")
                            {
                                AdminSayMessage("Punishing " + record.GetTargetNames() + " for " + record.record_message);
                            }
                            else
                            {
                                AdminSayMessage(record.GetTargetNames() + " PUNISHED by " + record.GetSourceName() + " for " + record.record_message);
                            }
                            record.command_type = GetCommandByKey("player_kill");
                            record.command_action = GetCommandByKey("player_kill");
                        }
                        else if (killCount >= 4 && punishCount >= 2)
                        {
                            record.command_type = GetCommandByKey("player_kick");
                            record.command_action = GetCommandByKey("player_kick");
                        }
                    }
                }
                if (_pluginVersionStatus == VersionStatus.OutdatedBuild && 
                    !record.record_action_executed &&
                    (record.source_player == null || PlayerIsAdmin(record.source_player)))
                {
                    if (_pluginUpdatePatched)
                    {
                        SendMessageToSource(record, "AdKats has been updated to version " + _latestPluginVersion + "! Reboot PRoCon to activate this patch.");
                    }
                    else
                    {
                        SendMessageToSource(record, "You are running an outdated version of AdKats. Update " + _latestPluginVersion + " is released.");
                    }
                }
                DebugWrite("Preparing to queue " + record.command_type.command_key + " record for processing", 6);
                lock (_UnprocessedRecordQueue) {
                    //Queue the record for processing
                    _UnprocessedRecordQueue.Enqueue(record);
                    DebugWrite("Record queued for processing", 6);
                    _DbCommunicationWaitHandle.Set();
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while queueing record for processing.", e);
                HandleException(record.record_exception);
            }
            DebugWrite("Exiting queueRecordForProcessing", 7);
        }

        private void QueueStatisticForProcessing(AdKatsStatistic aStat)
        {
            DebugWrite("Entering QueueStatisticForProcessing", 6);
            try
            {
                DebugWrite("Preparing to queue statistic for processing", 6);
                lock (_UnprocessedStatisticQueue)
                {
                    //Queue the statistic for processing
                    _UnprocessedStatisticQueue.Enqueue(aStat);
                    DebugWrite("Statistic queued for processing", 6);
                    _DbCommunicationWaitHandle.Set();
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while queuing statistic for processing.", e));
            }
            DebugWrite("Exiting QueueStatisticForProcessing", 6);
        }

        private void CommandParsingThreadLoop() {
            try {
                DebugWrite("COMMAND: Starting Command Parsing Thread", 1);
                Thread.CurrentThread.Name = "Command";
                DateTime loopStart = UtcDbTime();
                while (true) {
                    try {
                        DebugWrite("COMMAND: Entering Command Parsing Thread Loop", 7);
                        if (!_pluginEnabled) {
                            DebugWrite("COMMAND: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }

                        //Sleep for 10ms
                        _threadMasterWaitHandle.WaitOne(10);

                        //Get all unparsed inbound messages
                        if (_UnparsedCommandQueue.Count > 0) {
                            DebugWrite("COMMAND: Preparing to lock command queue to retrive new commands", 7);
                            Queue<AdKatsChatMessage> unparsedCommands;
                            lock (_UnparsedCommandQueue) {
                                DebugWrite("COMMAND: Inbound commands found. Grabbing.", 6);
                                //Grab all messages in the queue
                                unparsedCommands = new Queue<AdKatsChatMessage>(_UnparsedCommandQueue.ToArray());
                                //Clear the queue for next run
                                _UnparsedCommandQueue.Clear();
                            }

                            //Loop through all commands in order that they came in
                            while (unparsedCommands.Count > 0)
                            {
                                if (!_pluginEnabled)
                                {
                                    break;
                                }
                                DebugWrite("COMMAND: begin reading command", 6);
                                //Dequeue the first/next command
                                AdKatsChatMessage commandMessage = unparsedCommands.Dequeue();

                                AdKatsRecord record;
                                if (commandMessage.Speaker == "Server")
                                {
                                    record = new AdKatsRecord {
                                        record_source = AdKatsRecord.Sources.ServerCommand,
                                        source_name = "ProconAdmin"
                                    };
                                }
                                else {
                                    record = new AdKatsRecord {
                                        record_source = AdKatsRecord.Sources.InGame,
                                        source_name = commandMessage.Speaker
                                    };
                                }

                                //Complete the record creation
                                CompleteRecordInformation(record, commandMessage.Message);
                            }
                        }
                        else {
                            DebugWrite("COMMAND: No inbound commands, ready.", 7);
                            //No commands to parse, ready.
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _CommandParsingWaitHandle.Reset();
                            _CommandParsingWaitHandle.WaitOne(TimeSpan.FromSeconds(5));
                            loopStart = UtcDbTime();
                            continue;
                        }
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            HandleException(new AdKatsException("Command thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in Command thread. Skipping current loop.", e));
                    }
                }
                DebugWrite("COMMAND: Ending Command Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in command parsing thread.", e));
            }
        }

        //Before calling this, the record is initialized, and command_source/source_name are filled
        public void CompleteRecordInformation(AdKatsRecord record, String message) {
            try {
                //Initial split of command by whitespace
                String[] splitMessage = message.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);
                if (splitMessage.Length < 1) {
                    DebugWrite("Completely blank command entered", 5);
                    SendMessageToSource(record, "You entered a completely blank command.");
                    FinalizeRecord(record);
                    return;
                }
                String commandString = splitMessage[0].ToLower();
                DebugWrite("Raw Command: " + commandString, 6);
                String remainingMessage = message.TrimStart(splitMessage[0].ToCharArray()).Trim();

                record.server_id = _serverInfo.ServerID;
                record.record_time = UtcDbTime();

                //GATE 1: Add Command
                AdKatsCommand commandType = null;
                if (_CommandTextDictionary.TryGetValue(commandString, out commandType) && commandType.command_active == AdKatsCommand.CommandActive.Active) {
                    record.command_type = commandType;
                    record.command_action = commandType;
                    DebugWrite("Command parsed. Command is " + commandType.command_key + ".", 5);
                }
                else {
                    //If command not parsable, return without creating
                    DebugWrite("Command not parsable", 6);
                    if (record.record_source == AdKatsRecord.Sources.ExternalPlugin) {
                        SendMessageToSource(record, "Command not parsable.");
                        FinalizeRecord(record);
                    }
                    return;
                }

                //GATE 2: Check Access Rights
                if (record.record_source == AdKatsRecord.Sources.ServerCommand && !_AllowAdminSayCommands) {
                    SendMessageToSource(record, "Access to commands using that method has been disabled in AdKats settings.");
                    FinalizeRecord(record);
                    return;
                }
                if (!_firstPlayerListComplete) {
                    if (!_PlayersRequestingCommands.Contains(record.source_name)) {
                        _PlayersRequestingCommands.Add(record.source_name);
                    }
                    if (!_firstUserListComplete)
                    {
                        SendMessageToSource(record, "Command startup in progress, 1/3 complete, " + FormatTimeString(UtcDbTime() - _AdKatsStartTime, 3) + " elapsed.");
                    }
                    else
                    {
                        SendMessageToSource(record, "Command startup in progress, 2/3 complete, " + FormatTimeString(UtcDbTime() - _AdKatsStartTime, 3) + " elapsed.");
                    }
                    FinalizeRecord(record);
                    return;
                }
                else {
                    _PlayersRequestingCommands.Clear();
                }
                //Check if player has the right to perform what he's asking, only perform for InGame actions
                if (record.record_source == AdKatsRecord.Sources.InGame) {
                    //Attempt to fetch the source player
                    if (!_PlayerDictionary.TryGetValue(record.source_name, out record.source_player)) {
                        ConsoleError("Source player not found in server for in-game command, unable to complete command.");
                        FinalizeRecord(record);
                        return;
                    }
                    if (!HasAccess(record.source_player, record.command_type)) {
                        DebugWrite("No rights to call command", 6);
                        //Only tell the user they dont have access if the command is active
                        if (record.command_type.command_active == AdKatsCommand.CommandActive.Active) {
                            SendMessageToSource(record, "Your role " + record.source_player.player_role.role_name + " (Power Level " + record.source_player.player_role.role_powerLevel + ") cannot use " + record.command_type.command_name + ".");
                        }
                        FinalizeRecord(record);
                        return;
                    }
                }

                //GATE 3: Specific data based on command type.
                switch (record.command_type.command_key) {
                    case "player_move": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    break;
                                }
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 1:
                                record.record_message = "MovePlayer";
                                record.target_name = parameters[0];
                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    CompleteTargetInformation(record, false, false, false);
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                return;
                        }
                    }
                        break;
                    case "player_fmove": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 1:
                                record.record_message = "ForceMovePlayer";
                                record.target_name = parameters[0];
                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    CompleteTargetInformation(record, false, false, false);
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                return;
                        }
                    }
                        break;
                    case "self_teamswap": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //May only call this command from in-game
                        if (record.record_source != AdKatsRecord.Sources.InGame) {
                            SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                            FinalizeRecord(record);
                            return;
                        }
                        record.record_message = "TeamSwap";
                        record.target_name = record.source_name;
                        CompleteTargetInformation(record, false, false, false);
                    }
                        break;
                    case "self_assist": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //May only call this command from in-game
                        if (record.record_source != AdKatsRecord.Sources.InGame)
                        {
                            SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Cannot call this command when game not active
                        if (_roundState != RoundState.Playing)
                        {
                            SendMessageToSource(record, "You can't use assist unless a round is active.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Cannot call this command during surrender
                        if (_surrenderVoteActive || _endingRound)
                        {
                            SendMessageToSource(record, "You can't use assist while a surrender action is active.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Player Info Check
                        record.record_message = "Assist Losing Team";
                        record.target_name = record.source_name;
                        if (!_PlayerDictionary.TryGetValue(record.target_name, out record.target_player)) {
                            SendMessageToSource(record, "Player information not found. Unable to process command.");
                            FinalizeRecord(record);
                            return;
                        }

                        //May only call this command from in-game
                        if (record.source_player.player_type != PlayerType.Player)
                        {
                            SendMessageToSource(record, "You must be a player to use assist.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Team Info Check
                        AdKatsTeam team1 = _teamDictionary[1];
                        AdKatsTeam team2 = _teamDictionary[2];
                        AdKatsTeam winningTeam, losingTeam;
                        if (team1.TeamTicketCount > team2.TeamTicketCount) {
                            winningTeam = team1;
                            losingTeam = team2;
                        }
                        else {
                            winningTeam = team2;
                            losingTeam = team1;
                        }
                        AdKatsTeam friendlyTeam, enemyTeam;
                        if (record.target_player.frostbitePlayerInfo.TeamID == team1.TeamID) {
                            friendlyTeam = team1;
                            enemyTeam = team2;
                        }
                        else if (record.target_player.frostbitePlayerInfo.TeamID == team2.TeamID) {
                            friendlyTeam = team2;
                            enemyTeam = team1;
                        }
                        else
                        {
                            SendMessageToSource(record, "Invalid teams when attempting to assist.");
                            FinalizeRecord(record);
                            return;
                        }
                        String debug = (PlayerIsAdmin(record.source_player)) ? ("[" + friendlyTeam.TeamKey + ":" + friendlyTeam.TeamTicketCount + ":" + (int)friendlyTeam.TeamTicketDifferenceRate + "][" + enemyTeam.TeamKey + ":" + enemyTeam.TeamTicketCount + ":" + (int)enemyTeam.TeamTicketDifferenceRate + "]") : ("");

                        record.record_message = "Assist Weak Team [" + winningTeam.TeamTicketCount + ":" + losingTeam.TeamTicketCount + "][" + FormatTimeString(_serverInfo.GetRoundElapsedTime(), 3) + "]";
                        Boolean enemyWinning = (record.target_player.frostbitePlayerInfo.TeamID == losingTeam.TeamID);
                        Boolean enemyStrong = true;
                        if (record.target_player.frostbitePlayerInfo.TeamID == team1.TeamID)
                        {
                            enemyStrong = Math.Abs(team2.TeamTicketDifferenceRate) < Math.Abs(team1.TeamTicketDifferenceRate);
                        }
                        else
                        {
                            enemyStrong = Math.Abs(team1.TeamTicketDifferenceRate) < Math.Abs(team2.TeamTicketDifferenceRate);
                        }
                        if (_isTestingAuthorized && _serverInfo.GetRoundElapsedTime().TotalSeconds < 120) {
                            SendMessageToSource(record, "Please wait at least 2 minutes into the round to use assist. [" + FormatTimeString(_serverInfo.GetRoundElapsedTime(), 2) + "]");
                            FinalizeRecord(record);
                            return;
                        }
                        if ((!enemyWinning && !enemyStrong) ||
                            (!enemyWinning && Math.Abs(winningTeam.TeamTicketCount - losingTeam.TeamTicketCount) > 200)) {
                            //15 second timeout
                            Double timeout = (60 - (UtcDbTime() - _commandUsageTimes["self_assist"]).TotalSeconds);
                            if (timeout > 0) {
                                SendMessageToSource(record, "Assist recently used. Please wait " + (int) timeout + " seconds before using it. Thank you. " + debug);
                                FinalizeRecord(record);
                                return;
                            }
                            SendMessageToSource(record, "Queuing you to assist the weak team. Thank you. " + debug);
                        }
                        else {
                            String responseMessage = "You may only assist a weak team. Enemy team is ";
                            if (enemyWinning && enemyStrong) {
                                responseMessage += "winning and strong.";
                            }
                            else if (enemyWinning && !enemyStrong) {
                                responseMessage += "losing ground, but still winning the match.";
                            }
                            else if (!enemyWinning && enemyStrong) {
                                responseMessage += "losing, but is making a comeback.";
                            }
                            SendMessageToSource(record, responseMessage);
                            FinalizeRecord(record);
                            return;
                        }

                        QueueRecordForProcessing(record);
                    }
                        break;
                    case "self_kill": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //May only call this command from in-game
                        if (record.record_source != AdKatsRecord.Sources.InGame) {
                            SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                            FinalizeRecord(record);
                            return;
                        }

                        record.record_message = "Self-Inflicted";
                        record.target_name = record.source_name;
                        CompleteTargetInformation(record, false, false, false);
                    }
                        break;
                    case "player_kill": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, false, false, false);
                                break;
                            case 1:
                                record.target_name = parameters[0];
                                //Handle based on report ID as only option
                                if (!HandleRoundReport(record)) {
                                    SendMessageToSource(record, "No reason given, unable to submit.");
                                }
                                FinalizeRecord(record);
                                return;
                            case 2:
                                record.target_name = parameters[0];

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                if (record.record_message == null) {
                                    SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                    FinalizeRecord(record);
                                    return;
                                }

                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    if (record.record_message.Length >= _RequiredReasonLength) {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else {
                                        SendMessageToSource(record, "Reason too short, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_kill_force":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (_serverInfo.ServerType == "OFFICIAL")
                            {
                                SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 0:
                                    if (record.record_source != AdKatsRecord.Sources.InGame)
                                    {
                                        SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.record_message = "Self-Inflicted";
                                    record.target_name = record.source_name;
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    //Handle based on report ID as only option
                                    if (!HandleRoundReport(record))
                                    {
                                        SendMessageToSource(record, "No reason given, unable to submit.");
                                    }
                                    FinalizeRecord(record);
                                    return;
                                case 2:
                                    record.target_name = parameters[0];

                                    //attempt to handle via pre-message ID
                                    record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                    if (record.record_message == null)
                                    {
                                        SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                        FinalizeRecord(record);
                                        return;
                                    }

                                    //Handle based on report ID if possible
                                    if (!HandleRoundReport(record))
                                    {
                                        if (record.record_message.Length >= _RequiredReasonLength)
                                        {
                                            CompleteTargetInformation(record, false, false, false);
                                        }
                                        else
                                        {
                                            SendMessageToSource(record, "Reason too short, unable to submit.");
                                            FinalizeRecord(record);
                                        }
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_warn":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (_serverInfo.ServerType == "OFFICIAL")
                            {
                                SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 0:
                                    if (record.record_source != AdKatsRecord.Sources.InGame)
                                    {
                                        SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.record_message = "Warning Yourself";
                                    record.target_name = record.source_name;
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    //Handle based on report ID as only option
                                    if (!HandleRoundReport(record))
                                    {
                                        SendMessageToSource(record, "No reason given, unable to submit.");
                                    }
                                    FinalizeRecord(record);
                                    return;
                                case 2:
                                    record.target_name = parameters[0];

                                    //attempt to handle via pre-message ID
                                    record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                    if (record.record_message == null)
                                    {
                                        SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                        FinalizeRecord(record);
                                        return;
                                    }

                                    //Handle based on report ID if possible
                                    if (!HandleRoundReport(record))
                                    {
                                        if (record.record_message.Length >= _RequiredReasonLength)
                                        {
                                            CompleteTargetInformation(record, false, false, false);
                                        }
                                        else
                                        {
                                            SendMessageToSource(record, "Reason too short, unable to submit.");
                                            FinalizeRecord(record);
                                        }
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_kick": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 1:
                                record.target_name = parameters[0];
                                //Handle based on report ID as only option
                                if (!HandleRoundReport(record)) {
                                    SendMessageToSource(record, "No reason given, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            case 2:
                                record.target_name = parameters[0];

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                if (record.record_message == null) {
                                    SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                    FinalizeRecord(record);
                                    return;
                                }

                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    if (record.record_message.Length >= _RequiredReasonLength) {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else {
                                        SendMessageToSource(record, "Reason too short, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_ban_temp": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 3);

                        //Default is minutes
                        Double recordDuration = 0.0;
                        Double durationMultiplier = 1.0;
                        if (parameters.Length > 0) {
                            String stringDuration = parameters[0].ToLower();
                            DebugWrite("Raw Duration: " + stringDuration, 6);
                            if (stringDuration.EndsWith("s")) {
                                stringDuration = stringDuration.TrimEnd('s');
                                durationMultiplier = (1.0 / 60.0);
                            }
                            else if (stringDuration.EndsWith("m")) {
                                stringDuration = stringDuration.TrimEnd('m');
                                durationMultiplier = 1.0;
                            }
                            else if (stringDuration.EndsWith("h")) {
                                stringDuration = stringDuration.TrimEnd('h');
                                durationMultiplier = 60.0;
                            }
                            else if (stringDuration.EndsWith("d")) {
                                stringDuration = stringDuration.TrimEnd('d');
                                durationMultiplier = 1440.0;
                            }
                            else if (stringDuration.EndsWith("w")) {
                                stringDuration = stringDuration.TrimEnd('w');
                                durationMultiplier = 10080.0;
                            }
                            else if (stringDuration.EndsWith("y")) {
                                stringDuration = stringDuration.TrimEnd('y');
                                durationMultiplier = 525949.0;
                            }
                            if (!Double.TryParse(stringDuration, out recordDuration)) {
                                SendMessageToSource(record, "Invalid time given, unable to submit.");
                                return;
                            }
                            record.command_numeric = (int) (recordDuration * durationMultiplier);
                            if (record.command_numeric > 5259490.0) {
                                SendMessageToSource(record, "You cannot temp ban for longer than 10 years. Issue a permanent ban instead.");
                                return;
                            }
                            if (record.command_numeric > _MaxTempBanDuration.TotalMinutes) {
                                SendMessageToSource(record, "You cannot temp ban for longer than " + FormatTimeString(_MaxTempBanDuration, 2) + ". Defaulting to max temp ban time.");
                                record.command_numeric = (int)_MaxTempBanDuration.TotalMinutes;
                            }
                        }

                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.command_numeric = (int) (recordDuration * durationMultiplier);
                                //Target is source
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 2:
                                record.command_numeric = (int) (recordDuration * durationMultiplier);

                                record.target_name = parameters[1];
                                DebugWrite("target: " + record.target_name, 6);

                                //Handle based on report ID as only option
                                if (!HandleRoundReport(record)) {
                                    SendMessageToSource(record, "No reason given, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            case 3:
                                record.command_numeric = (int) (recordDuration * durationMultiplier);

                                record.target_name = parameters[1];
                                DebugWrite("target: " + record.target_name, 6);

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[2], _RequirePreMessageUse);
                                if (record.record_message == null) {
                                    SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                    FinalizeRecord(record);
                                    return;
                                }

                                DebugWrite("reason: " + record.record_message, 6);

                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    if (record.record_message.Length >= _RequiredReasonLength) {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else {
                                        SendMessageToSource(record, "Reason too short, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_ban_perm": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 1:
                                record.target_name = parameters[0];
                                //Handle based on report ID as only option
                                if (!HandleRoundReport(record)) {
                                    SendMessageToSource(record, "No reason given, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            case 2:
                                record.target_name = parameters[0];

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                if (record.record_message == null) {
                                    SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                    FinalizeRecord(record);
                                    return;
                                }

                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    if (record.record_message.Length >= _RequiredReasonLength) {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else {
                                        SendMessageToSource(record, "Reason too short, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_ban_perm_future": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }
                        if (!_UseBanEnforcer || !_UseBanEnforcerPreviousState) {
                            SendMessageToSource(record, " can only be used when ban enforcer is enabled.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 3);

                        //Default is minutes
                        Double recordDuration = 0.0;
                        Double durationMultiplier = 1.0;
                        if (parameters.Length > 0) {
                            String stringDuration = parameters[0].ToLower();
                            DebugWrite("Raw Duration: " + stringDuration, 6);
                            if (stringDuration.EndsWith("s")) {
                                stringDuration = stringDuration.TrimEnd('s');
                                durationMultiplier = (1.0 / 60.0);
                            }
                            else if (stringDuration.EndsWith("m")) {
                                stringDuration = stringDuration.TrimEnd('m');
                                durationMultiplier = 1.0;
                            }
                            else if (stringDuration.EndsWith("h")) {
                                stringDuration = stringDuration.TrimEnd('h');
                                durationMultiplier = 60.0;
                            }
                            else if (stringDuration.EndsWith("d")) {
                                stringDuration = stringDuration.TrimEnd('d');
                                durationMultiplier = 1440.0;
                            }
                            else if (stringDuration.EndsWith("w")) {
                                stringDuration = stringDuration.TrimEnd('w');
                                durationMultiplier = 10080.0;
                            }
                            else if (stringDuration.EndsWith("y")) {
                                stringDuration = stringDuration.TrimEnd('y');
                                durationMultiplier = 525949.0;
                            }
                            if (!Double.TryParse(stringDuration, out recordDuration)) {
                                SendMessageToSource(record, "Invalid time given, unable to submit.");
                                return;
                            }
                            record.command_numeric = (int) (recordDuration * durationMultiplier);
                        }
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.command_numeric = (int) (recordDuration * durationMultiplier);
                                //Target is source
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 2:
                                record.command_numeric = (int) (recordDuration * durationMultiplier);

                                record.target_name = parameters[1];
                                DebugWrite("target: " + record.target_name, 6);

                                //Handle based on report ID as only option
                                if (!HandleRoundReport(record)) {
                                    SendMessageToSource(record, "No reason given, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            case 3:
                                record.command_numeric = (int) (recordDuration * durationMultiplier);

                                record.target_name = parameters[1];
                                DebugWrite("target: " + record.target_name, 6);

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[2], _RequirePreMessageUse);
                                if (record.record_message == null) {
                                    SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                    FinalizeRecord(record);
                                    return;
                                }

                                DebugWrite("reason: " + record.record_message, 6);

                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    if (record.record_message.Length >= _RequiredReasonLength) {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else {
                                        SendMessageToSource(record, "Reason too short, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_unban": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }
                        if (!_UseBanEnforcer || !_UseBanEnforcerPreviousState) {
                            SendMessageToSource(record, "The unban command can only be used when ban enforcer is enabled.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        String partialName;
                        List<AdKatsBan> matchingBans;
                        switch (parameters.Length) {
                            case 0:
                                //Unban the last player you've banned
                                SendMessageToSource(record, "Unbanning the last person you banned is not implemented yet.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                //Unban the target player
                                partialName = parameters[0];
                                record.record_message = "Admin Unban";
                                break;
                            case 2:
                                //Unban the target player
                                partialName = parameters[0];

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                if (record.record_message == null)
                                {
                                    SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                    FinalizeRecord(record);
                                    return;
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }

                        if (String.IsNullOrEmpty(partialName) || partialName.Length < 3)
                        {
                            SendMessageToSource(record, "Name search must be at least 3 characters.");
                            FinalizeRecord(record);
                            return;
                        }
                        SendMessageToSource(record, "Fetching matching bans. Please wait.");
                        matchingBans = FetchMatchingBans(partialName, 4);
                        if (matchingBans.Count == 0)
                        {
                            SendMessageToSource(record, "No players matching '" + partialName + "' have active bans.");
                            FinalizeRecord(record);
                            return;
                        }
                        if (matchingBans.Count <= 3)
                        {
                            foreach (AdKatsBan innerBan in matchingBans)
                            {
                                SendMessageToSource(record, innerBan.ban_record.GetTargetNames() + " | " + innerBan.ban_record.record_time.ToShortDateString() + " | " + innerBan.ban_record.record_message);
                            }
                            AdKatsBan aBan = matchingBans[0];
                            record.target_name = aBan.ban_record.target_player.player_name;
                            record.target_player = aBan.ban_record.target_player;
                            ConfirmActionWithSource(record);
                        }
                        else
                        {
                            SendMessageToSource(record, "Too many banned players match your search, try again.");
                            FinalizeRecord(record);
                        }
                    }
                        break;
                    case "player_whitelisthackerchecker":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Hacker-Checker Whitelist Player";
                                    break;
                                case 2:
                                    record.target_name = parameters[0];

                                    //attempt to handle via pre-message ID
                                    record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                    if (record.record_message == null)
                                    {
                                        SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }

                            if (String.IsNullOrEmpty(record.target_name) || record.target_name.Length < 3)
                            {
                                SendMessageToSource(record, "Name search must be at least 3 characters.");
                                FinalizeRecord(record);
                                return;
                            }
                            CompleteTargetInformation(record, false, true, false);
                        }
                        break;
                    case "player_whitelistping":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Ping Whitelist Player";
                                    break;
                                case 2:
                                    record.target_name = parameters[0];

                                    //attempt to handle via pre-message ID
                                    record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                    if (record.record_message == null)
                                    {
                                        SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }

                            if (String.IsNullOrEmpty(record.target_name) || record.target_name.Length < 3)
                            {
                                SendMessageToSource(record, "Name search must be at least 3 characters.");
                                FinalizeRecord(record);
                                return;
                            }
                            CompleteTargetInformation(record, false, true, false);
                        }
                        break;
                    case "player_whitelistaa":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Admin Assistant Whitelist Player";
                                    break;
                                case 2:
                                    record.target_name = parameters[0];

                                    //attempt to handle via pre-message ID
                                    record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                    if (record.record_message == null)
                                    {
                                        SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }

                            if (String.IsNullOrEmpty(record.target_name) || record.target_name.Length < 3)
                            {
                                SendMessageToSource(record, "Name search must be at least 3 characters.");
                                FinalizeRecord(record);
                                return;
                            }
                            CompleteTargetInformation(record, false, true, false);
                        }
                        break;
                    case "player_whitelistspambot":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (!_spamBotExcludeAdminsAndWhitelist)
                            {
                                SendMessageToSource(record, "'Exclude Admins and Whitelist from Spam' must be enabled to use this command.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "SpamBot Whitelist Player";
                                    break;
                                case 2:
                                    record.target_name = parameters[0];

                                    //attempt to handle via pre-message ID
                                    record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                    if (record.record_message == null)
                                    {
                                        SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }

                            if (String.IsNullOrEmpty(record.target_name) || record.target_name.Length < 3)
                            {
                                SendMessageToSource(record, "Name search must be at least 3 characters.");
                                FinalizeRecord(record);
                                return;
                            }
                            CompleteTargetInformation(record, false, true, false);
                        }
                        break;
                    case "player_punish": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        if (!_dbTimingValid)
                        {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed when database timing is mismatched.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 1:
                                record.target_name = parameters[0];
                                //Handle based on report ID as only option
                                if (!HandleRoundReport(record)) {
                                    SendMessageToSource(record, "No reason given, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            case 2:
                                record.target_name = parameters[0];

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                if (record.record_message == null) {
                                    SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                    FinalizeRecord(record);
                                    return;
                                }

                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    if (record.record_message.Length >= _RequiredReasonLength) {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else {
                                        SendMessageToSource(record, "Reason too short, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_forgive": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 1:
                                record.target_name = parameters[0];
                                //Handle based on report ID as only option
                                if (!HandleRoundReport(record)) {
                                    SendMessageToSource(record, "No reason given, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            case 2:
                                record.target_name = parameters[0];

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                if (record.record_message == null) {
                                    SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                    FinalizeRecord(record);
                                    return;
                                }

                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    if (record.record_message.Length >= _RequiredReasonLength) {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else {
                                        SendMessageToSource(record, "Reason too short, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_mute": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 1:
                                record.target_name = parameters[0];
                                //Handle based on report ID as only option
                                if (!HandleRoundReport(record)) {
                                    SendMessageToSource(record, "No reason given, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            case 2:
                                record.target_name = parameters[0];

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                if (record.record_message == null) {
                                    SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                    FinalizeRecord(record);
                                    return;
                                }

                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    if (record.record_message.Length >= _RequiredReasonLength) {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else {
                                        SendMessageToSource(record, "Reason too short, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_join":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (_serverInfo.ServerType == "OFFICIAL")
                            {
                                SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "foreveralone.jpg (You cannot join on yourself.)");
                                    FinalizeRecord(record);
                                    return;
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Joining Player";
                                    if (!HandleRoundReport(record))
                                    {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_pull":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (_serverInfo.ServerType == "OFFICIAL")
                            {
                                SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "foreveralone.jpg (You cannot pull yourself.)");
                                    FinalizeRecord(record);
                                    return;
                                case 1:
                                    if (record.record_source != AdKatsRecord.Sources.InGame)
                                    {
                                        SendMessageToSource(record, "You can't use this command from outside the game.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.target_name = parameters[0];
                                    record.record_message = "Pulling Player";
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_roundwhitelist": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        SendMessageToSource(record, "This command has been permanently disabled. - ColColonCleaner");
                        return;

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.record_message = "Self-Inflicted";
                                record.target_name = record.source_name;
                                CompleteTargetInformation(record, true, false, false);
                                break;
                            case 1:
                                record.target_name = parameters[0];
                                //Handle based on report ID as only option
                                if (!HandleRoundReport(record)) {
                                    SendMessageToSource(record, "No reason given, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            case 2:
                                record.target_name = parameters[0];

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], false);

                                //Handle based on report ID if possible
                                if (!HandleRoundReport(record)) {
                                    if (record.record_message.Length >= _RequiredReasonLength) {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else {
                                        SendMessageToSource(record, "Reason too short, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_report": {
                        //Get the command text for report
                        String command = GetCommandByKey("player_report").command_text;

                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "Format must be: @" + command + " playername reason");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                SendMessageToSource(record, "Format must be: @" + command + " playername reason");
                                FinalizeRecord(record);
                                return;
                            case 2:
                                record.target_name = parameters[0];
                                DebugWrite("target: " + record.target_name, 6);

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], false);

                                DebugWrite("reason: " + record.record_message, 6);

                                //Only 1 character reasons are required for reports and admin calls
                                if (record.record_message.Length >= 1) {
                                    CompleteTargetInformation(record, true, false, false);
                                }
                                else {
                                    DebugWrite("reason too short", 6);
                                    SendMessageToSource(record, "Reason too short, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_calladmin": {
                        //Get the command text for call admin
                        String command = GetCommandByKey("player_calladmin").command_text;

                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "Format must be: @" + command + " playername reason");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                SendMessageToSource(record, "Format must be: @" + command + " playername reason");
                                FinalizeRecord(record);
                                return;
                            case 2:
                                record.target_name = parameters[0];
                                DebugWrite("target: " + record.target_name, 6);

                                //attempt to handle via pre-message ID
                                record.record_message = GetPreMessage(parameters[1], false);

                                DebugWrite("reason: " + record.record_message, 6);
                                //Only 1 character reasons are required for reports and admin calls
                                if (record.record_message.Length >= 1)
                                {
                                    CompleteTargetInformation(record, false, false, false);
                                }
                                else {
                                    DebugWrite("reason too short", 6);
                                    SendMessageToSource(record, "Reason too short, unable to submit.");
                                    FinalizeRecord(record);
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_info":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 0:
                                    if (record.record_source != AdKatsRecord.Sources.InGame)
                                    {
                                        SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.record_message = "Fetching Own Info";
                                    record.target_name = record.source_name;
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Fetching Player Info";
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_chat":
                        {
                            /*
                             * This command will get chat history for a player. Comes in 4 variations. 
                             * Variable number of seconds between printed lines, based on the number of characters in the message. 
                             * Oldest to newest. Default last 5 lines, max 30. Spam protection enabled.
                             *  
                             * /pchat - returns your chat history, default length.
                             * /pchat (#) - returns your chat history, custom length.
                             * /pchat (playername) - returns player chat history, default length.
                             * /pchat (#) (playername) - returns player chat history, custom length.
                             * /pchat self (playername) - returns last conversation between you and player, default length.
                             * /pchat (#) self (playername) - returns last conversation between you and player, custom length.
                             * /pchat (playernameA) (playernameB) - returns last conversation between playerA and playerB, default length.
                             * /pchat (#) (playernameA) (playernameB) - returns last conversation between playerA and playerB, custom length.
                             */

                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            Int32 numeric;

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 3);
                            switch (parameters.Length)
                            {
                                case 0:
                                    //One case, assign to self
                                    if (record.record_source != AdKatsRecord.Sources.InGame)
                                    {
                                        SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.record_message = "Fetching own chat history";
                                    record.target_name = record.source_name;
                                    record.command_numeric = 5;
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                case 1:
                                    //Two cases
                                    if (Int32.TryParse(parameters[0], out numeric) && numeric <= 30) {
                                        //Case numeric, assign to duration
                                        record.record_message = "Fetching own chat history";
                                        record.target_name = record.source_name;
                                        record.command_numeric = numeric;
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else
                                    {
                                        //Case player, assign to target name
                                        record.record_message = "Fetching player chat history";
                                        record.target_name = parameters[0];
                                        record.command_numeric = 5;
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    return;
                                case 2:
                                    //Three cases
                                    if (Int32.TryParse(parameters[0], out numeric) && numeric <= 30)
                                    {
                                        //Case numeric, assign to duration
                                        record.record_message = "Fetching player chat history";
                                        record.target_name = parameters[1];
                                        record.command_numeric = numeric;
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    else
                                    {
                                        SendMessageToSource(record, "");
                                        //Two target case, assign both players
                                        if (parameters[0].ToLower() == "self")
                                        {
                                            //Players are self and target
                                            record.record_message = "Fetching own conversation history.";
                                            record.TargetNamesLocal.Add(record.source_name);
                                            record.TargetNamesLocal.Add(parameters[0]);
                                            record.command_numeric = 5;
                                            CompleteTargetInformation(record, false, false, false);
                                        }
                                        else
                                        {
                                            //Players are target 1 and target 2
                                            record.record_message = "Fetching player conversation history.";
                                            record.TargetNamesLocal.Add(parameters[0]);
                                            record.TargetNamesLocal.Add(parameters[1]);
                                            record.command_numeric = 5;
                                            CompleteTargetInformation(record, false, false, false);
                                        }
                                    }
                                    break;
                                case 3:
                                    //Two cases
                                    if (Int32.TryParse(parameters[0], out numeric) && numeric <= 30)
                                    {
                                        //Two target case, assign both players
                                        if (parameters[1].ToLower() == "self")
                                        {
                                            //Players are self and target
                                            record.record_message = "Fetching own conversation history.";
                                            record.TargetNamesLocal.Add(record.source_name);
                                            record.TargetNamesLocal.Add(parameters[2]);
                                            record.command_numeric = numeric;
                                            CompleteTargetInformation(record, false, false, false);
                                        }
                                        else
                                        {
                                            //Players are target 1 and target 2
                                            record.record_message = "Fetching player conversation history.";
                                            record.TargetNamesLocal.Add(parameters[1]);
                                            record.TargetNamesLocal.Add(parameters[2]);
                                            record.command_numeric = numeric;
                                            CompleteTargetInformation(record, false, false, false);
                                        }
                                    }
                                    else
                                    {
                                        SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                        FinalizeRecord(record);
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_find":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    if (record.record_source != AdKatsRecord.Sources.InGame)
                                    {
                                        SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.record_message = "Finding Self";
                                    record.target_name = record.source_name;
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Finding Player";
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_lock":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "You can't lock yourself...");
                                    FinalizeRecord(record);
                                    return;
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Locking Player";
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_unlock":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "You can't unlock yourself...");
                                    FinalizeRecord(record);
                                    return;
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Unlocking Player";
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_mark":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 0:
                                    if (record.record_source != AdKatsRecord.Sources.InGame)
                                    {
                                        SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.record_message = "Marking Self";
                                    record.target_name = record.source_name;
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Marking Player";
                                    if (!HandleRoundReport(record))
                                    {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_log":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 1:
                                    record.target_name = parameters[0];
                                    //Handle based on report ID as only option
                                    if (!HandleRoundReport(record))
                                    {
                                        SendMessageToSource(record, "No log message given, unable to submit.");
                                    }
                                    FinalizeRecord(record);
                                    return;
                                case 2:
                                    record.target_name = parameters[0];

                                    //attempt to handle via pre-message ID
                                    record.record_message = GetPreMessage(parameters[1], _RequirePreMessageUse);
                                    if (record.record_message == null)
                                    {
                                        SendMessageToSource(record, "Invalid PreMessage ID, valid PreMessage IDs are 1-" + _PreMessageList.Count);
                                        FinalizeRecord(record);
                                        return;
                                    }

                                    //Handle based on report ID if possible
                                    if (!HandleRoundReport(record))
                                    {
                                        if (record.record_message.Length >= _RequiredReasonLength)
                                        {
                                            CompleteTargetInformation(record, false, false, false);
                                        }
                                        else
                                        {
                                            SendMessageToSource(record, "Log message too short, unable to submit.");
                                            FinalizeRecord(record);
                                        }
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "server_afk":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    if (_AFKAutoKickEnable) {
                                        SendMessageToSource(record, "AFK players are being managed automatically; Disable to use this command.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.record_message = "Manage AFK Players";
                                    record.target_name = "Server";
                                    QueueRecordForProcessing(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "server_nuke":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (_serverInfo.ServerType == "OFFICIAL")
                            {
                                SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "No parameters given, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                                case 1:
                                    String targetTeam = parameters[0];
                                    record.record_message = "Nuke Server";
                                    DebugWrite("target: " + targetTeam, 6);
                                    if (targetTeam.ToLower().Contains("us"))
                                    {
                                        AdKatsTeam aTeam = GetTeamByKey("US");
                                        if (aTeam != null)
                                        {
                                            record.target_name = aTeam.TeamName;
                                            record.command_numeric = aTeam.TeamID;
                                            record.record_message += " (" + aTeam.TeamName + ")";
                                        }
                                        else
                                        {
                                            SendMessageToSource(record, "Team US does not exist on this map.");
                                            FinalizeRecord(record);
                                            return;
                                        }
                                    }
                                    else if (targetTeam.ToLower().Contains("ru"))
                                    {
                                        AdKatsTeam aTeam = GetTeamByKey("RU");
                                        if (aTeam != null)
                                        {
                                            record.target_name = aTeam.TeamName;
                                            record.command_numeric = aTeam.TeamID;
                                            record.record_message += " (" + aTeam.TeamName + ")";
                                        }
                                        else
                                        {
                                            SendMessageToSource(record, "Team RU does not exist on this map.");
                                            FinalizeRecord(record);
                                            return;
                                        }
                                    }
                                    else if (targetTeam.ToLower().Contains("cn"))
                                    {
                                        AdKatsTeam aTeam = GetTeamByKey("CN");
                                        if (aTeam != null)
                                        {
                                            record.target_name = aTeam.TeamName;
                                            record.command_numeric = aTeam.TeamID;
                                            record.record_message += " (" + aTeam.TeamName + ")";
                                        }
                                        else
                                        {
                                            SendMessageToSource(record, "Team CN does not exist on this map.");
                                            FinalizeRecord(record);
                                            return;
                                        }
                                    }
                                    else if (targetTeam.ToLower().Contains("all"))
                                    {
                                        record.target_name = "Everyone";
                                        record.record_message += " (Everyone)";
                                    }
                                    else
                                    {
                                        SendMessageToSource(record, "Use 'US', 'RU', 'CN', or 'ALL' as targets.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    //Have the admin confirm the action
                                    ConfirmActionWithSource(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "server_countdown":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 3);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "No parameters given, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                                case 3:
                                    String targetSubset = parameters[0].ToLower().Trim();
                                    if (String.IsNullOrEmpty(targetSubset))
                                    {
                                        SendMessageToSource(record, "Invalid target, must be squad, team, or all. Unable to submit.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    switch (targetSubset) {
                                        case "squad":
                                            if (record.source_player == null || 
                                                !record.source_player.player_online || 
                                                !_PlayerDictionary.ContainsKey(record.source_player.player_name) ||
                                                record.source_player.player_type == PlayerType.Spectator)
                                            {
                                                SendMessageToSource(record, "Must be a player to use squad option. Unable to submit.");
                                                FinalizeRecord(record);
                                                return;
                                            }
                                            record.target_name = "Squad";
                                            break;
                                        case "team":
                                            if (record.source_player == null ||
                                                !record.source_player.player_online ||
                                                !_PlayerDictionary.ContainsKey(record.source_player.player_name) ||
                                                record.source_player.player_type == PlayerType.Spectator)
                                            {
                                                SendMessageToSource(record, "Must be a player to use team option. Unable to submit.");
                                                FinalizeRecord(record);
                                                return;
                                            }
                                            record.target_name = "Team";
                                            break;
                                        case "all":
                                            record.target_name = "All";
                                            break;
                                        default:
                                            SendMessageToSource(record, "Invalid target, must be squad, team, or all. Unable to submit.");
                                            FinalizeRecord(record);
                                            return;
                                            break;
                                    }
                                    //Max 30 seconds
                                    Int32 countdownSeconds;
                                    if (!Int32.TryParse(parameters[1], out countdownSeconds) || countdownSeconds < 1 || countdownSeconds > 30)
                                    {
                                        SendMessageToSource(record, "Invalid duration, must be 1-30. Unable to submit.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.command_numeric = countdownSeconds;
                                    String countdownMessage = parameters[2];
                                    if (String.IsNullOrEmpty(countdownMessage)) {
                                        SendMessageToSource(record, "Invalid countdown message, unable to submit.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.record_message = countdownMessage;

                                    //Have the admin confirm the action
                                    QueueRecordForProcessing(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "server_kickall":
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        record.target_name = "Non-Admins";
                        record.record_message = "Kick All Players";
                        ConfirmActionWithSource(record);
                        break;
                    case "server_swapnuke":
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        /*if ((_playerDictionary.Count + 1) >= _serverInfo.MaxPlayerCount)
                        {
                            SendMessageToSource(record, record.command_type.command_key + " be performed without an open slot in the server to move players.");
                            FinalizeRecord(record);
                            return;
                        }*/

                        record.target_name = "Everyone";
                        record.record_message = "TeamSwap All Players";
                        ConfirmActionWithSource(record);
                        break;
                    case "round_end": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                String targetTeam = parameters[0];
                                DebugWrite("target team: " + targetTeam, 6);
                                record.record_message = "End Round";
                                if (targetTeam.ToLower().Contains("us")) {
                                    AdKatsTeam aTeam = GetTeamByKey("US");
                                    if (aTeam != null) {
                                        record.target_name = aTeam.TeamName;
                                        record.command_numeric = aTeam.TeamID;
                                        record.record_message += " (" + aTeam.TeamKey + " Win)";
                                    }
                                    else {
                                        SendMessageToSource(record, "Team US does not exist on this map.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                }
                                else if (targetTeam.ToLower().Contains("ru")) {
                                    AdKatsTeam aTeam = GetTeamByKey("RU");
                                    if (aTeam != null) {
                                        record.target_name = aTeam.TeamName;
                                        record.command_numeric = aTeam.TeamID;
                                        record.record_message += " (" + aTeam.TeamKey + " Win)";
                                    }
                                    else {
                                        SendMessageToSource(record, "Team RU does not exist on this map.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                }
                                else if (targetTeam.ToLower().Contains("cn")) {
                                    AdKatsTeam aTeam = GetTeamByKey("CN");
                                    if (aTeam != null) {
                                        record.target_name = aTeam.TeamName;
                                        record.command_numeric = aTeam.TeamID;
                                        record.record_message += " (" + aTeam.TeamKey + " Win)";
                                    }
                                    else {
                                        SendMessageToSource(record, "Team CN does not exist on this map.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                }
                                else {
                                    SendMessageToSource(record, "Use 'US', 'RU', or 'CN' as team codes to end round");
                                    FinalizeRecord(record);
                                    return;
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                        //Have the admin confirm the action
                        ConfirmActionWithSource(record);
                    }
                        break;
                    case "round_restart":
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        record.target_name = "Server";
                        record.record_message = "Restart Round";
                        ConfirmActionWithSource(record);
                        break;
                    case "round_next":
                        CancelSourcePendingAction(record);

                        if (_serverInfo.ServerType == "OFFICIAL") {
                            SendMessageToSource(record, record.command_type.command_key + " cannot be performed on official servers.");
                            FinalizeRecord(record);
                            return;
                        }

                        record.target_name = "Server";
                        record.record_message = "Run Next Map";
                        ConfirmActionWithSource(record);
                        break;
                    case "self_whatis": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                record.record_message = GetPreMessage(parameters[0], true);
                                if (record.record_message == null) {
                                    AdKatsCommand aCommand;
                                    if (_CommandTextDictionary.TryGetValue(parameters[0], out aCommand)) {
                                        if (record.source_player == null || HasAccess(record.source_player, aCommand)) {
                                            record.record_message = _CommandDescriptionDictionary[aCommand.command_key];
                                        }
                                        else {
                                            record.record_message = "Your user role " + record.source_player.player_role.role_name + " does not have access to " + aCommand.command_name + ".";
                                        }
                                    }
                                    else
                                    {
                                        record.record_message = "Invalid PreMessage ID or command name. !" + GetCommandByKey("self_help").command_text + " for command list. Valid PreMessage IDs are 1-" + _PreMessageList.Count;
                                    }
                                }
                                SendMessageToSource(record, record.record_message);
                                FinalizeRecord(record);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                        //This type is not processed
                    }
                        break;
                    case "self_voip": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Send them voip information
                        SendMessageToSource(record, _ServerVoipAddress);
                        FinalizeRecord(record);
                    }
                        break;
                    case "self_rules":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    record.target_name = record.source_name;
                                    record.record_message = "Player Requested Rules";
                                    if (record.record_source == AdKatsRecord.Sources.InGame)
                                    {
                                        if (!_PlayerDictionary.TryGetValue(record.target_name, out record.target_player))
                                        {
                                            SendMessageToSource(record, "Source player not found, unable to submit.");
                                            FinalizeRecord(record);
                                            return;
                                        }
                                    }
                                    else
                                    {
                                        record.target_name = "ExternalSource";
                                    }
                                    QueueRecordForProcessing(record);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Telling Player Rules";
                                    if (!HandleRoundReport(record))
                                    {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "self_surrender":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (!_surrenderVoteEnable)
                            {
                                SendMessageToSource(record, "Surrender Vote must be enabled in AdKats settings to use this command.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 0);
                            switch (parameters.Length)
                            {
                                case 0:
                                    record.target_name = record.source_name;
                                    record.record_message = "Player Voted for Surrender";
                                    if (record.record_source == AdKatsRecord.Sources.InGame)
                                    {
                                        if (!_PlayerDictionary.TryGetValue(record.target_name, out record.target_player))
                                        {
                                            SendMessageToSource(record, "Source player not found, unable to submit.");
                                            FinalizeRecord(record);
                                            return;
                                        }
                                    }
                                    else
                                    {
                                        record.target_name = "ExternalSource";
                                    }
                                    QueueRecordForProcessing(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "self_votenext":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (!_surrenderVoteEnable)
                            {
                                SendMessageToSource(record, "Surrender Vote must be enabled in AdKats settings to use this command.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 0);
                            switch (parameters.Length)
                            {
                                case 0:
                                    record.target_name = record.source_name;
                                    record.record_message = "Player Voted for Next Round";
                                    if (record.record_source == AdKatsRecord.Sources.InGame)
                                    {
                                        if (!_PlayerDictionary.TryGetValue(record.target_name, out record.target_player))
                                        {
                                            SendMessageToSource(record, "Source player not found, unable to submit.");
                                            FinalizeRecord(record);
                                            return;
                                        }
                                    }
                                    else
                                    {
                                        record.target_name = "ExternalSource";
                                    }
                                    QueueRecordForProcessing(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "self_nosurrender":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (!_surrenderVoteEnable)
                            {
                                SendMessageToSource(record, "Surrender Vote must be enabled in AdKats settings to use this command.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 0);
                            switch (parameters.Length)
                            {
                                case 0:
                                    record.target_name = record.source_name;
                                    record.record_message = "Player Voted for Against Surrender";
                                    if (record.record_source == AdKatsRecord.Sources.InGame)
                                    {
                                        if (!_PlayerDictionary.TryGetValue(record.target_name, out record.target_player))
                                        {
                                            SendMessageToSource(record, "Source player not found, unable to submit.");
                                            FinalizeRecord(record);
                                            return;
                                        }
                                    }
                                    else
                                    {
                                        record.target_name = "ExternalSource";
                                    }
                                    QueueRecordForProcessing(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "self_help":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    record.target_name = record.source_name;
                                    record.record_message = "Player Requested Commands";
                                    if (record.record_source == AdKatsRecord.Sources.InGame)
                                    {
                                        if (!_PlayerDictionary.TryGetValue(record.target_name, out record.target_player))
                                        {
                                            SendMessageToSource(record, "Source player not found, unable to submit.");
                                            FinalizeRecord(record);
                                            return;
                                        }
                                    }
                                    else
                                    {
                                        record.target_name = "ExternalSource";
                                    }
                                    QueueRecordForProcessing(record);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Telling Player Commands";
                                    if (!HandleRoundReport(record))
                                    {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "self_rep":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    record.target_name = record.source_name;
                                    record.record_message = "Player Requested Reputation";
                                    if (record.record_source == AdKatsRecord.Sources.InGame)
                                    {
                                        if (!_PlayerDictionary.TryGetValue(record.target_name, out record.target_player))
                                        {
                                            SendMessageToSource(record, "Source player not found, unable to submit.");
                                            FinalizeRecord(record);
                                            return;
                                        }
                                    }
                                    else
                                    {
                                        SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    QueueRecordForProcessing(record);
                                    break;
                                case 1:
                                    if (record.source_player != null && !PlayerIsAdmin(record.source_player))
                                    {
                                        SendMessageToSource(record, "You cannot see another player's reputation. Admin only.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.target_name = parameters[0];
                                    record.record_message = "Requesting Player Reputation";
                                    if (!HandleRoundReport(record))
                                    {
                                        CompleteTargetInformation(record, false, false, false);
                                    }
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "self_uptime": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        record.record_message = "Player Requested Uptime";
                        if (record.record_source == AdKatsRecord.Sources.InGame) {
                            record.target_name = record.source_name;
                            if (_PlayerDictionary.TryGetValue(record.target_name, out record.target_player)) {
                                record.target_name = record.target_player.player_name;
                            }
                            else {
                                ConsoleError("48204928 this error should never happen.");
                                FinalizeRecord(record);
                                return;
                            }
                        }
                        else {
                            record.target_name = "ExternalSource";
                        }
                        QueueRecordForProcessing(record);
                    }
                        break;
                    case "self_contest": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //May only call this command from in-game
                        if (record.record_source != AdKatsRecord.Sources.InGame) {
                            SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Player Info Check
                        record.record_message = "Player Contested Report";
                        record.target_name = record.source_name;
                        if (!_PlayerDictionary.TryGetValue(record.target_name, out record.target_player)) {
                            SendMessageToSource(record, "Player information not found. Unable to process command.");
                            FinalizeRecord(record);
                            return;
                        }

                        AdKatsRecord aRecord = null;
                        foreach (AdKatsRecord reportRecord in _RoundReports.Values) {
                            if (reportRecord.target_player.player_id == record.target_player.player_id) {
                                if (aRecord == null || reportRecord.record_time > aRecord.record_time) {
                                    aRecord = reportRecord;
                                }
                            }
                        }

                        if (aRecord == null) {
                            SendMessageToSource(record, "You have no reports to contest.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Assign the report ID housed in command numeric
                        record.command_numeric = aRecord.command_numeric;
                        //Set Contested
                        aRecord.isContested = true;
                        //Inform All Parties
                        SendMessageToSource(aRecord, aRecord.GetTargetNames() + " has contested your report against them.");
                        SendMessageToSource(record, "You have contested " + aRecord.GetSourceName() + "'s report against you.");
                        OnlineAdminSayMessage(record.GetSourceName() + " has contested report [" + aRecord.command_numeric + "] for " + aRecord.record_message);

                        QueueRecordForProcessing(record);
                    }
                        break;
                    case "self_admins": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        record.record_message = "Player Requested Online Admins";
                        if (record.record_source == AdKatsRecord.Sources.InGame) {
                            record.target_name = record.source_name;
                            CompleteTargetInformation(record, false, false, false);
                        }
                        else {
                            record.target_name = "ExternalSource";
                            QueueRecordForProcessing(record);
                        }
                    }
                        break;
                    case "self_lead": {
                        //Remove previous commands awaiting confirmationf
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                if (record.record_source != AdKatsRecord.Sources.InGame) {
                                    SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                    FinalizeRecord(record);
                                    return;
                                }
                                record.target_name = record.source_name;
                                record.record_message = "Player Taking Squad Lead";
                                CompleteTargetInformation(record, false, false, false);
                                break;
                            case 1:
                                record.target_name = parameters[0];
                                record.record_message = "Giving Player Squad Lead";
                                if (!HandleRoundReport(record)) {
                                    CompleteTargetInformation(record, false, false, false);
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "self_reportlist":
                        {
                        //Remove previous commands awaiting confirmationf
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                record.record_message = "Listing Round Reports";
                                if (record.record_source == AdKatsRecord.Sources.InGame) {
                                    record.target_name = record.source_name;
                                    CompleteTargetInformation(record, false, false, false);
                                }
                                else {
                                    record.target_name = "ExternalSource";
                                    QueueRecordForProcessing(record);
                                }
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "admin_accept": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "Report ID must be given. Unable to submit.");
                                FinalizeRecord(record);
                                break;
                            case 1:
                                record.target_name = parameters[0];
                                //Handle based on report ID as only option
                                if (!AcceptRoundReport(record)) {
                                    SendMessageToSource(record, "Invalid report ID given, unable to submit.");
                                }
                                FinalizeRecord(record);
                                return;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                        record.record_action_executed = true;
                    }
                        break;
                    case "admin_deny":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "Report ID must be given. Unable to submit.");
                                    FinalizeRecord(record);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    //Handle based on report ID as only option
                                    if (!DenyRoundReport(record))
                                    {
                                        SendMessageToSource(record, "Invalid report ID given, unable to submit.");
                                    }
                                    FinalizeRecord(record);
                                    return;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                            record.record_action_executed = true;
                        }
                        break;
                    case "admin_ignore":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "Report ID must be given. Unable to submit.");
                                    FinalizeRecord(record);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    //Handle based on report ID as only option
                                    if (!IgnoreRoundReport(record))
                                    {
                                        SendMessageToSource(record, "Invalid report ID given, unable to submit.");
                                    }
                                    FinalizeRecord(record);
                                    return;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                            record.record_action_executed = true;
                        }
                        break;
                    case "admin_say": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                record.record_message = GetPreMessage(parameters[0], false);
                                DebugWrite("message: " + record.record_message, 6);
                                record.target_name = "Server";
                                QueueRecordForProcessing(record);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_say": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                SendMessageToSource(record, "No message given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 2:
                                record.target_name = parameters[0];
                                DebugWrite("target: " + record.target_name, 6);

                                record.record_message = GetPreMessage(parameters[1], false);
                                DebugWrite("message: " + record.record_message, 6);

                                CompleteTargetInformation(record, false, false, false);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "admin_yell": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                record.record_message = GetPreMessage(parameters[0], false);
                                DebugWrite("message: " + record.record_message, 6);
                                record.target_name = "Server";
                                QueueRecordForProcessing(record);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_yell": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                SendMessageToSource(record, "No message given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 2:
                                record.target_name = parameters[0];
                                DebugWrite("target: " + record.target_name, 6);

                                record.record_message = GetPreMessage(parameters[1], false);
                                DebugWrite("message: " + record.record_message, 6);

                                CompleteTargetInformation(record, false, false, false);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "admin_tell": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                record.record_message = GetPreMessage(parameters[0], false);
                                DebugWrite("message: " + record.record_message, 6);
                                record.target_name = "Server";
                                QueueRecordForProcessing(record);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_tell":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "No parameters given, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                                case 1:
                                    SendMessageToSource(record, "No message given, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                                case 2:
                                    record.target_name = parameters[0];
                                    DebugWrite("target: " + record.target_name, 6);

                                    record.record_message = GetPreMessage(parameters[1], false);
                                    DebugWrite("message: " + record.record_message, 6);

                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_pm_send":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (record.record_source != AdKatsRecord.Sources.InGame)
                            {
                                SendMessageToSource(record, "You can't start private conversations from outside the game. Use player say.");
                                break;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "No parameters given, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                                case 1:
                                    SendMessageToSource(record, "No message given, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                                case 2:
                                    record.target_name = parameters[0];
                                    DebugWrite("target: " + record.target_name, 6);

                                    record.record_message = GetPreMessage(parameters[1], false);
                                    DebugWrite("message: " + record.record_message, 6);

                                    CompleteTargetInformation(record, false, false, false, true);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_pm_reply":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            if (record.record_source != AdKatsRecord.Sources.InGame)
                            {
                                SendMessageToSource(record, "You can't reply to private conversations from outside the game. Use player say.");
                                break;
                            }

                            if (record.source_player == null || 
                                record.source_player.conversationPartner == null) {
                                SendMessageToSource(record, "You are not in a private conversation. Use /" + GetCommandByKey("player_pm_send").command_text + " player message, to start one.");
                                FinalizeRecord(record);
                                return;
                            }

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "No parameters given, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                                case 1:
                                    record.record_message = GetPreMessage(parameters[0], false);
                                    record.target_name = record.source_player.conversationPartner.player_name;
                                    record.target_player = record.source_player.conversationPartner;
                                    QueueRecordForProcessing(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "admin_pm_send":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    SendMessageToSource(record, "No parameters given, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                                case 1:
                                    record.record_message = GetPreMessage(parameters[0], false);
                                    QueueRecordForProcessing(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_dequeue":
                        {
                            //Remove previous commands awaiting confirmation
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 2);
                            switch (parameters.Length)
                            {
                                case 0:
                                    if (record.record_source != AdKatsRecord.Sources.InGame) {
                                        SendMessageToSource(record, "You can't use a self-targeted command from outside the game.");
                                        FinalizeRecord(record);
                                        return;
                                    }
                                    record.record_message = "Dequeueing Self";
                                    record.target_name = record.source_name;
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                case 1:
                                    record.target_name = parameters[0];
                                    record.record_message = "Dequeueing Player";
                                    DebugWrite("target: " + record.target_name, 6);
                                    CompleteTargetInformation(record, false, false, false);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "player_blacklistdisperse": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (!_FeedMultiBalancerDisperseList) {
                            SendMessageToSource(record, "Enable 'Feed MULTIBalancer Even Dispersion List' to use this command.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                record.target_name = parameters[0];
                                record.record_message = "Server Balance";
                                CompleteTargetInformation(record, false, false, false);
                                break;
                            case 2:
                                record.target_name = parameters[0];
                                DebugWrite("target: " + record.target_name, 6);
                                record.record_message = GetPreMessage(parameters[1], false);
                                DebugWrite("message: " + record.record_message, 6);
                                CompleteTargetInformation(record, false, false, false);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_whitelistbalance": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (!_FeedMultiBalancerWhitelist) {
                            SendMessageToSource(record, "Enable 'Feed MULTIBalancer Whitelist' to use this command.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                SendMessageToSource(record, "No message given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 2:
                                record.target_name = parameters[0];
                                DebugWrite("target: " + record.target_name, 6);

                                record.record_message = GetPreMessage(parameters[1], false);
                                DebugWrite("message: " + record.record_message, 6);

                                CompleteTargetInformation(record, false, false, false);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_slotreserved": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (!_FeedServerReservedSlots) {
                            SendMessageToSource(record, "Enable 'Feed Server Reserved Slots' to use this command.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                SendMessageToSource(record, "No message given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 2:
                                record.target_name = parameters[0];
                                DebugWrite("target: " + record.target_name, 6);

                                record.record_message = GetPreMessage(parameters[1], false);
                                DebugWrite("message: " + record.record_message, 6);

                                CompleteTargetInformation(record, false, false, false);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "player_slotspectator": {
                        //Remove previous commands awaiting confirmation
                        CancelSourcePendingAction(record);

                        if (!_FeedServerSpectatorList) {
                            SendMessageToSource(record, "Enable 'Feed Server Spectator Slots' to use this command.");
                            FinalizeRecord(record);
                            return;
                        }

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 2);
                        switch (parameters.Length) {
                            case 0:
                                SendMessageToSource(record, "No parameters given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 1:
                                SendMessageToSource(record, "No message given, unable to submit.");
                                FinalizeRecord(record);
                                return;
                            case 2:
                                record.target_name = parameters[0];
                                DebugWrite("target: " + record.target_name, 6);

                                record.record_message = GetPreMessage(parameters[1], false);
                                DebugWrite("message: " + record.record_message, 6);

                                CompleteTargetInformation(record, false, false, false);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "plugin_restart":
                        {
                            //Remove previous commands awaiting confirmationf
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    record.target_name = "AdKats";
                                    record.record_message = "Restart AdKats";
                                    ConfirmActionWithSource(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "plugin_update":
                        {
                            //Remove previous commands awaiting confirmationf
                            CancelSourcePendingAction(record);

                            //Parse parameters using max param count
                            String[] parameters = ParseParameters(remainingMessage, 1);
                            switch (parameters.Length)
                            {
                                case 0:
                                    record.target_name = "AdKats";
                                    record.record_message = "Update AdKats";
                                    ConfirmActionWithSource(record);
                                    break;
                                default:
                                    SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                    FinalizeRecord(record);
                                    return;
                            }
                        }
                        break;
                    case "server_shutdown":
                        {
                        //Remove previous commands awaiting confirmationf
                        CancelSourcePendingAction(record);

                        //Parse parameters using max param count
                        String[] parameters = ParseParameters(remainingMessage, 1);
                        switch (parameters.Length) {
                            case 0:
                                record.target_name = "Server";
                                record.record_message = "Shutdown Server";
                                ConfirmActionWithSource(record);
                                break;
                            default:
                                SendMessageToSource(record, "Invalid parameters, unable to submit.");
                                FinalizeRecord(record);
                                return;
                        }
                    }
                        break;
                    case "command_confirm":
                        DebugWrite("attempting to confirm command", 6);
                        AdKatsRecord recordAttempt = null;
                        _ActionConfirmDic.TryGetValue(record.source_name, out recordAttempt);
                        if (recordAttempt != null) {
                            DebugWrite("command found, calling processing", 6);
                            _ActionConfirmDic.Remove(record.source_name);
                            QueueRecordForProcessing(recordAttempt);
                            FinalizeRecord(record);
                        }
                        DebugWrite("no command to confirm", 6);
                        FinalizeRecord(record);
                        //This type is not processed
                        break;
                    case "command_cancel":
                        DebugWrite("attempting to cancel command", 6);
                        if (_ActionConfirmDic.Remove(record.source_name)) {
                            SendMessageToSource(record, "Previous command cancelled.");
                        }
                        else if (!_surrenderVoteSucceeded && _surrenderVoteList.Contains(record.source_name)) {
                            if (_surrenderVoteList.Remove(record.source_name))
                            {
                                SendMessageToSource(record, "Your surrender vote has been removed!");
                                Int32 requiredVotes = (Int32)((_PlayerDictionary.Count / 2.0) * (_surrenderVoteMinimumPlayerPercentage / 100.0));
                                Int32 voteCount = _surrenderVoteList.Count - _nosurrenderVoteList.Count;
                                OnlineAdminSayMessage(record.GetSourceName() + " removed their surrender vote.");
                                AdminSayMessage((requiredVotes - voteCount) + " votes needed for surrender/scramble. Use @" + GetCommandByKey("self_surrender").command_text + ", @" + GetCommandByKey("self_votenext").command_text + ", or @" + GetCommandByKey("self_nosurrender").command_text + " to vote.");
                                AdminYellMessage((requiredVotes - voteCount) + " votes needed for surrender/scramble");
                            }
                        }
                        else {
                            DebugWrite("no command to cancel", 6);
                        }
                        //This type is not processed
                        FinalizeRecord(record);
                        break;
                    default:
                        ConsoleError("Unable to complete record for " + record.command_type.command_key + ", handler not found.");
                        FinalizeRecord(record);
                        return;
                }
            }
            catch (Exception e) {
                record.record_exception = HandleException(new AdKatsException("Error occured while completing record information.", e));
                FinalizeRecord(record);
            }
        }

        private AdKatsTeam GetTeamByKey(String teamKey) {
            lock (_teamDictionary) {
                foreach (AdKatsTeam curTeam in _teamDictionary.Values) {
                    if (String.Equals(curTeam.TeamKey, teamKey, StringComparison.CurrentCultureIgnoreCase)) {
                        //Team found
                        return curTeam;
                    }
                }
            }
            return null;
        }

        public void FinalizeRecord(AdKatsRecord record)
        {
            DebugWrite("Entering FinalizeRecord", 7);
            try
            {
                //Make sure commands are assigned properly
                if (record.command_action == null)
                {
                    if (record.command_type != null)
                    {
                        record.command_action = record.command_type;
                    }
                    else
                    {
                        //Record has no command. Ignore it.
                        return;
                    }
                }
                if (record.external_responseRequested)
                {
                    var responseHashtable = new Hashtable {
                    {"caller_identity", "AdKats"},
                    {"response_requested", false},
                    {"response_type", "IssueCommand"},
                    {"response_value", CPluginVariable.EncodeStringArray(record.debugMessages.ToArray())}
                };
                    ExecuteCommand("procon.protected.plugins.call", record.external_responseClass, record.external_responseMethod, "AdKats", JSON.JsonEncode(responseHashtable));
                }
                //Performance testing area
                if (record.source_name == _debugSoldierName)
                {
                    SendMessageToSource(record, "Duration: " + ((int)UtcDbTime().Subtract(_commandStartTime).TotalMilliseconds) + "ms");
                }
                if (record.record_source == AdKatsRecord.Sources.InGame || record.record_source == AdKatsRecord.Sources.InternalAutomated)
                {
                    DebugWrite("In-Game/Automated " + record.command_action.command_key + " record took " + Math.Round((DateTime.UtcNow - record.record_creationTime).TotalMilliseconds) + "ms to complete actions.", 3);
                }
                //Add event log
                if (String.IsNullOrEmpty(record.target_name))
                {
                    if (record.target_player != null)
                    {
                        record.target_name = record.target_player.player_name;
                    }
                    else
                    {
                        record.target_name = "UnknownTarget";
                    }
                }
                if (String.IsNullOrEmpty(record.source_name))
                {
                    if (record.source_player != null)
                    {
                        record.source_name = record.source_player.player_name;
                    }
                    else
                    {
                        record.source_name = "UnknownSource";
                    }
                }
                String message;
                if (record.record_action_executed)
                {
                    message = record.GetSourceName() + " issued " + record.command_action.command_name + " on " + record.GetTargetNames() + " for " + record.record_message;
                }
                else
                {
                    message = record.GetSourceName() + " FAILED to issue " + record.command_action.command_name + " on " + record.GetTargetNames() + " for " + record.record_message;
                }
                this.ExecuteCommand("procon.protected.events.write", "Plugins", "PluginAction", message, record.GetSourceName());
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while finalizing record.", e));
            }
            DebugWrite("Exiting FinalizeRecord", 7);
        }

        public void CompleteTargetInformation(AdKatsRecord record, Boolean requireConfirm, Boolean externalFetchOverFuzzy, Boolean externalOnlineFetchOverFuzzy)
        {
            CompleteTargetInformation(record, true, requireConfirm, externalFetchOverFuzzy, externalOnlineFetchOverFuzzy);
        }

        public void CompleteTargetInformation(AdKatsRecord record, Boolean includeLeftPlayers, Boolean requireConfirm, Boolean externalFetchOverFuzzy, Boolean externalOnlineFetchOverFuzzy)
        {
            try
            {
                Boolean confirmNeeded = false;
                //Multiple target case
                if (record.TargetNamesLocal.Any()) {
                    foreach (string targetName in record.TargetNamesLocal)
                    {
                        //Attempt to get the player object
                        AdKatsPlayer aPlayer;
                        String resultMessage;
                        Boolean curConfirm;
                        if (FetchPlayerFromName(targetName, includeLeftPlayers, externalFetchOverFuzzy, externalOnlineFetchOverFuzzy, out aPlayer, out curConfirm, out resultMessage))
                        {
                            record.TargetPlayersLocal.Add(aPlayer);
                            if (curConfirm)
                            {
                                SendMessageToSource(record, resultMessage);
                                confirmNeeded = true;
                            }
                        }
                        else {
                            SendMessageToSource(record, resultMessage);
                        }
                    }
                    //Ensure main target player is null
                    record.target_player = null;
                }
                //Single target case
                else {
                    //Attempt to get the player object
                    AdKatsPlayer aPlayer;
                    String resultMessage;
                    Boolean curConfirm;
                    if (FetchPlayerFromName(record.target_name, includeLeftPlayers, externalFetchOverFuzzy, externalOnlineFetchOverFuzzy, out aPlayer, out curConfirm, out resultMessage))
                    {
                        record.target_name = aPlayer.player_name;
                        record.target_player = aPlayer;
                        if (curConfirm)
                        {
                            SendMessageToSource(record, resultMessage);
                            confirmNeeded = true;
                        }
                    }
                    else {
                        SendMessageToSource(record, resultMessage);
                        FinalizeRecord(record);
                        return;
                    }
                }
                if (confirmNeeded) {
                    ConfirmActionWithSource(record);
                }
                else {
                    QueueRecordForProcessing(record);
                }
            }
            catch (Exception e) {
                record.record_exception = HandleException(new AdKatsException("Error while completing target information.", e));
                FinalizeRecord(record);
            }
        }

        public Boolean FetchPlayerFromName(String playerNameInput, Boolean includeLeftPlayers, Boolean externalFetchOverFuzzy, Boolean externalOnlineFetchOverFuzzy, out AdKatsPlayer aPlayer, out Boolean confirmNeeded, out String resultMessage)
        {
            //Set default return values
            resultMessage = "No valid player found for '" + playerNameInput + "'";
            confirmNeeded = false;
            aPlayer = null;
            try
            {
                if (!SoldierNameValid(playerNameInput))
                {
                    resultMessage = "'" + playerNameInput + "' was an invalid player name.";
                    return false;
                }
                if (externalFetchOverFuzzy && externalOnlineFetchOverFuzzy) {
                    ConsoleError("Cannot use both external fetches at the same time.");
                }
                //Check for an exact match
                if (_PlayerDictionary.TryGetValue(playerNameInput, out aPlayer)) {
                    return true;
                }
                if (includeLeftPlayers && _PlayerLeftDictionary.TryGetValue(playerNameInput, out aPlayer)) {
                    return true;
                }
                //Check online players for substring match
                List<String> currentPlayerNames = _PlayerDictionary.Keys.ToList();
                List<String> leftPlayerNames = _PlayerLeftDictionary.Keys.ToList();
                //Get all subString matches
                var subStringMatches = new List<string>();
                subStringMatches.AddRange(currentPlayerNames.Where(playerName => Regex.Match(playerName, playerNameInput, RegexOptions.IgnoreCase).Success));
                if (subStringMatches.Count == 1)
                {
                    //Only one subString match, call processing without confirmation if able
                    if (_PlayerDictionary.TryGetValue(subStringMatches[0], out aPlayer)) {
                        resultMessage = "Player match found for '" + playerNameInput + "'";
                        return true;
                    }
                    ConsoleError("Error fetching player for substring match.");
                    return false;
                }
                if (subStringMatches.Count > 1)
                {
                    //Multiple players matched the query, choose correct one
                    String msg = "'" + playerNameInput + "' matches multiple players: ";
                    bool first = true;
                    String suggestion = null;
                    foreach (String playerName in subStringMatches)
                    {
                        if (first)
                        {
                            msg = msg + playerName;
                            first = false;
                        }
                        else
                        {
                            msg = msg + ", " + playerName;
                        }
                        //Suggest player names that start with the text admins entered over others
                        if (playerName.ToLower().StartsWith(playerNameInput.ToLower()))
                        {
                            suggestion = playerName;
                        }
                    }
                    if (suggestion == null)
                    {
                        //If no player id starts with what admins typed, suggest subString id with lowest Levenshtein distance
                        Int32 bestDistance = Int32.MaxValue;
                        foreach (String playerName in subStringMatches)
                        {
                            Int32 distance = LevenshteinDistance(playerNameInput, playerName);
                            if (distance < bestDistance)
                            {
                                bestDistance = distance;
                                suggestion = playerName;
                            }
                        }
                    }
                    //If the suggestion is still null, something has failed
                    if (suggestion == null)
                    {
                        ConsoleError("Name suggestion system failed subString match");
                        return false;
                    }

                    //Use suggestion for target
                    if (_PlayerDictionary.TryGetValue(suggestion, out aPlayer))
                    {
                        resultMessage = msg;
                        confirmNeeded = true;
                        return true;
                    }
                    ConsoleError("Substring match fetch failed.");
                    return false;
                }
                if (includeLeftPlayers)
                {
                    //There were no players found in the online dictionary. Run a search on the offline dictionary
                    //Get all subString matches
                    var subStringLeftMatches = new List<string>();
                    subStringLeftMatches.AddRange(leftPlayerNames.Where(playerName => Regex.Match(playerName, playerNameInput, RegexOptions.IgnoreCase).Success));
                    if (subStringLeftMatches.Count == 1)
                    {
                        //Only one subString match, call processing without confirmation if able
                        if (_PlayerLeftDictionary.TryGetValue(subStringLeftMatches[0], out aPlayer))
                        {
                            resultMessage = "OFFLINE player match found for '" + playerNameInput + "'";
                            confirmNeeded = true;
                            return true;
                        }
                        ConsoleError("Error fetching player for substring match.");
                        return false;
                    }
                    if (subStringLeftMatches.Count > 1)
                    {
                        //Multiple players matched the query, choose correct one
                        String msg = "'" + playerNameInput + "' matches multiple OFFLINE players: ";
                        bool first = true;
                        String suggestion = null;
                        foreach (String playerName in subStringLeftMatches)
                        {
                            if (first)
                            {
                                msg = msg + playerName;
                                first = false;
                            }
                            else
                            {
                                msg = msg + ", " + playerName;
                            }
                            //Suggest player names that start with the text admins entered over others
                            if (playerName.ToLower().StartsWith(playerNameInput.ToLower()))
                            {
                                suggestion = playerName;
                            }
                        }
                        if (suggestion == null)
                        {
                            //If no player id starts with what admins typed, suggest subString id with lowest Levenshtein distance
                            Int32 bestDistance = Int32.MaxValue;
                            foreach (String playerName in subStringLeftMatches)
                            {
                                Int32 distance = LevenshteinDistance(playerNameInput, playerName);
                                if (distance < bestDistance)
                                {
                                    bestDistance = distance;
                                    suggestion = playerName;
                                }
                            }
                        }
                        //If the suggestion is still null, something has failed
                        if (suggestion == null)
                        {
                            ConsoleError("Name suggestion system failed subString match");
                            return false;
                        }

                        //Use suggestion for target
                        if (_PlayerLeftDictionary.TryGetValue(suggestion, out aPlayer))
                        {
                            resultMessage = msg;
                            confirmNeeded = true;
                            return true;
                        }
                        ConsoleError("Substring match fetch failed.");
                        return false;
                    }
                }
                if (externalFetchOverFuzzy)
                {
                    //No online or left player found, run external fetch over checking for fuzzy match
                    aPlayer = FetchPlayer(false, true, true, null, -1, playerNameInput, null, null);
                    if (aPlayer == null)
                    {
                        return false;
                    }
                    resultMessage = "Offline player found.";
                    aPlayer.player_online = false;
                    aPlayer.player_server = null;
                    confirmNeeded = true;
                    return true;
                }
                if (externalOnlineFetchOverFuzzy) {
                    //No online or left player found, run external online player fetch over checking for fuzzy match
                    aPlayer = FetchMatchingExternalOnlinePlayer(playerNameInput);
                    if (aPlayer == null) {
                        return false;
                    }
                    resultMessage = "Online player found in '" + aPlayer.player_server.ServerName.Substring(0, 20) + "'.";
                    confirmNeeded = true;
                    return true;
                }
                //No other option, run fuzzy match
                if (currentPlayerNames.Count > 0)
                {
                    //Player not found in either dictionary, run a fuzzy search using Levenshtein Distance on all players in server
                    String fuzzyMatch = null;
                    Int32 bestFuzzyDistance = Int32.MaxValue;
                    foreach (String playerName in currentPlayerNames)
                    {
                        Int32 distance = LevenshteinDistance(playerNameInput, playerName);
                        if (distance < bestFuzzyDistance)
                        {
                            bestFuzzyDistance = distance;
                            fuzzyMatch = playerName;
                        }
                    }
                    //If the suggestion is still null, something has failed
                    if (fuzzyMatch == null)
                    {
                        ConsoleError("Name suggestion system failed fuzzy match");
                        return false;
                    }
                    if (_PlayerDictionary.TryGetValue(fuzzyMatch, out aPlayer))
                    {
                        resultMessage = "Fuzzy player match found for " + playerNameInput;
                        confirmNeeded = true;
                        return true;
                    }
                    ConsoleError("Player suggestion found matching player, but it could not be fetched.");
                    return false;
                }
                if (includeLeftPlayers && leftPlayerNames.Count > 0)
                {
                    //No players in the online dictionary, but there are players in the offline dictionary,
                    //run a fuzzy search using Levenshtein Distance on all players who have left
                    String fuzzyMatch = null;
                    Int32 bestFuzzyDistance = Int32.MaxValue;
                    foreach (String playerName in leftPlayerNames)
                    {
                        Int32 distance = LevenshteinDistance(playerNameInput, playerName);
                        if (distance < bestFuzzyDistance)
                        {
                            bestFuzzyDistance = distance;
                            fuzzyMatch = playerName;
                        }
                    }
                    //If the suggestion is still null, something has failed
                    if (fuzzyMatch == null)
                    {
                        ConsoleError("Name suggestion system failed fuzzy match");
                        return false;
                    }
                    if (_PlayerLeftDictionary.TryGetValue(fuzzyMatch, out aPlayer))
                    {
                        resultMessage = "Fuzzy player match found for " + playerNameInput;
                        confirmNeeded = true;
                        return true;
                    }
                    ConsoleError("Player suggestion found matching player, but it could not be fetched.");
                    return false;
                }
                ConsoleError("Unable to find a matching player.");
                return false;
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching player from name.", e));
            }
            return false;
        }

        public void ConfirmActionWithSource(AdKatsRecord record) {
            DebugWrite("Entering confirmActionWithSource", 7);
            try {
                if (_bypassCommandConfirmation) {
                    QueueRecordForProcessing(record);
                    return;
                }
                lock (_ActionConfirmDic) {
                    //Cancel any source pending action
                    CancelSourcePendingAction(record);
                    //Send record to attempt list
                    _ActionConfirmDic.Add(record.source_name, record);

                    SendMessageToSource(record, record.command_type.command_name + "->" + record.GetTargetNames() + " for " + record.record_message + "?");
                }
            }
            catch (Exception e) {
                record.record_exception = HandleException(new AdKatsException("Error while confirming action with record source.", e));
            }
            DebugWrite("Exiting confirmActionWithSource", 7);
        }

        public void CancelSourcePendingAction(AdKatsRecord record) {
            DebugWrite("Entering cancelSourcePendingAction", 7);
            try {
                DebugWrite("attempting to cancel command", 6);
                lock (_ActionConfirmDic) {
                    if (_ActionConfirmDic.Remove(record.source_name)) {
                        SendMessageToSource(record, "Previous command Canceled.");
                    }
                }
            }
            catch (Exception e) {
                record.record_exception = HandleException(new AdKatsException("Error while canceling source pending action.", e));
            }
            DebugWrite("Exiting cancelSourcePendingAction", 7);
        }

        public AdKatsRecord FetchRoundReport(String reportID, Boolean remove) {
            AdKatsRecord reportedRecord = null;
            try {
                lock (_RoundReports) {
                    if (_RoundReports.TryGetValue(reportID, out reportedRecord) && remove) {
                        if (_RoundReports.Remove(reportID)) {
                            DebugWrite("Round report [" + reportID + "] removed.", 3);
                            _RoundReportHistory.Add(reportID);
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching round report.", e));
            }
            return reportedRecord;
        }

        public Boolean DenyRoundReport(AdKatsRecord record)
        {
            try
            {
                DebugWrite("Attempting to handle based on round report.", 6);
                AdKatsRecord reportedRecord = FetchRoundReport(record.target_name, true);
                if (reportedRecord != null)
                {
                    DebugWrite("Denying round report.", 5);
                    reportedRecord.command_action = GetCommandByKey("player_report_deny");
                    UpdateRecord(reportedRecord);
                    SendMessageToSource(reportedRecord, "Your report [" + reportedRecord.command_numeric + "] has been denied.");
                    OnlineAdminSayMessage("Report [" + reportedRecord.command_numeric + "] has been denied by " + record.GetSourceName() + ".");

                    record.target_name = reportedRecord.source_name;
                    record.target_player = reportedRecord.source_player;
                    QueueRecordForProcessing(record);
                    return true;
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while denying round report.", e));
            }
            return false;
        }

        public Boolean IgnoreRoundReport(AdKatsRecord record)
        {
            try
            {
                DebugWrite("Attempting to handle based on round report.", 6);
                AdKatsRecord reportedRecord = FetchRoundReport(record.target_name, true);
                if (reportedRecord != null)
                {
                    DebugWrite("Ignoring round report.", 5);
                    reportedRecord.command_action = GetCommandByKey("player_report_ignore");
                    UpdateRecord(reportedRecord);
                    //Do not inform the player their report was ignored
                    //SendMessageToSource(reportedRecord, "Your report [" + reportedRecord.command_numeric + "] has been ignored.");
                    OnlineAdminSayMessage("Report [" + reportedRecord.command_numeric + "] has been ignored by " + record.GetSourceName() + ".");

                    record.target_name = reportedRecord.source_name;
                    record.target_player = reportedRecord.source_player;
                    QueueRecordForProcessing(record);
                    return true;
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while ignoring round report.", e));
            }
            return false;
        }

        public Boolean AcceptRoundReport(AdKatsRecord record) {
            try {
                DebugWrite("Attempting to handle based on round report.", 6);
                AdKatsRecord reportedRecord = FetchRoundReport(record.target_name, true);
                if (reportedRecord != null) {
                    DebugWrite("Accepting round report.", 5);
                    reportedRecord.command_action = GetCommandByKey("player_report_confirm");
                    UpdateRecord(reportedRecord);
                    SendMessageToSource(reportedRecord, "Your report [" + reportedRecord.command_numeric + "] has been accepted. Thank you.");
                    OnlineAdminSayMessage("Report [" + reportedRecord.command_numeric + "] has been accepted by " + record.GetSourceName() + ".");

                    record.target_name = reportedRecord.source_name;
                    record.target_player = reportedRecord.source_player;

                    record.record_action_executed = true;
                    QueueRecordForProcessing(record);
                    return true;
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while denying round report.", e));
            }
            return false;
        }

        public Boolean HandleRoundReport(AdKatsRecord record) {
            try {
                DebugWrite("Attempting to handle based on round report.", 6);
                AdKatsRecord reportedRecord = FetchRoundReport(record.target_name, false);
                if (reportedRecord != null) {
                    if (record.source_player != null &&
                        !PlayerIsAdmin(record.source_player))
                    {
                        return false;
                    }
                    if ((UtcDbTime() - reportedRecord.record_time).TotalSeconds < _MinimumReportHandleSeconds) {
                        SendMessageToSource(record, "Report [" + record.target_name + "] cannot be acted on. " + FormatTimeString(TimeSpan.FromSeconds(_MinimumReportHandleSeconds - (UtcDbTime() - reportedRecord.record_time).TotalSeconds), 2) + " remaining.");
                        return true;
                    }
                    if (_RoundReports.Remove(record.target_name))
                    {
                        DebugWrite("Round report [" + record.target_name + "] removed.", 3);
                        _RoundReportHistory.Add(record.target_name);
                    }
                    if (reportedRecord.isContested) {  
                        SendMessageToSource(record, "Report [" + reportedRecord.command_numeric + "] is contested. Please investigate.");
                        if (record.source_player != null) {
                            PlayerYellMessage(record.source_player.player_name, "Report [" + reportedRecord.command_numeric + "] is contested. Please investigate.");
                        }
                        return true;
                    }
                    DebugWrite("Handling round report.", 5);
                    SendMessageToSource(reportedRecord, "Your report [" + reportedRecord.command_numeric + "] has been acted on. Thank you.");
                    OnlineAdminSayMessage("Report [" + reportedRecord.command_numeric + "] has been acted on by " + record.GetSourceName() + ".");
                    reportedRecord.command_action = GetCommandByKey("player_report_confirm");
                    UpdateRecord(reportedRecord);

                    record.target_name = reportedRecord.target_name;
                    record.target_player = reportedRecord.target_player;
                    if (String.IsNullOrEmpty(record.record_message) || record.record_message.Length < _RequiredReasonLength) {
                        record.record_message = reportedRecord.record_message;
                    }
                    QueueRecordForProcessing(record);
                    return true;
                }
                if (_RoundReportHistory.Contains(record.target_name)) {
                    SendMessageToSource(record, "Report [" + record.target_name + "] has already been acted on.");
                    return true;
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while handling round report.", e);
                HandleException(record.record_exception);
            }
            return false;
        }

        //replaces the message with a pre-message
        public String GetPreMessage(String message, Boolean required) {
            DebugWrite("Entering getPreMessage", 7);
            try {
                if (!string.IsNullOrEmpty(message)) {
                    //Attempt to fill the message via pre-message ID
                    Int32 preMessageID = 0;
                    DebugWrite("Raw preMessageID: " + message, 6);
                    Boolean valid = Int32.TryParse(message, out preMessageID);
                    if (valid && (preMessageID > 0) && (preMessageID <= _PreMessageList.Count)) {
                        message = _PreMessageList[preMessageID - 1];
                    }
                    else if (required) {
                        return null;
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while getting pre-message.", e));
            }
            DebugWrite("Exiting getPreMessage", 7);
            return message;
        }

        private void QueuePlayerForIPInfoFetch(AdKatsPlayer aPlayer)
        {
            DebugWrite("Entering QueuePlayerForIPInfoFetch", 6);
            try
            {
                DebugWrite("Preparing to queue player for IP info fetch.", 6);
                lock (_IPInfoFetchQueue)
                {
                    _IPInfoFetchQueue.Enqueue(aPlayer);
                    DebugWrite("Player queued for IP info fetch.", 6);
                    _IPInfoWaitHandle.Set();
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while queuing player for IP info fetch.", e));
            }
            DebugWrite("Exiting QueuePlayerForIPInfoFetch", 6);
        }

        public void IPAPICommThreadLoop()
        {
            try
            {
                DebugWrite("IPAPI: Starting IP API Comm Thread", 1);
                Thread.CurrentThread.Name = "IPAPIComm";
                DateTime loopStart = UtcDbTime();
                while (true)
                {
                    try
                    {
                        DebugWrite("IPAPI: Entering IP API Comm Thread Loop", 7);
                        if (!_pluginEnabled)
                        {
                            DebugWrite("IPAPI: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }
                        //Sleep for 10ms
                        _threadMasterWaitHandle.WaitOne(10);

                        //Handle Inbound player fetches
                        if (_IPInfoFetchQueue.Count > 0)
                        {
                            Queue<AdKatsPlayer> unprocessedPlayers;
                            lock (_IPInfoFetchQueue)
                            {
                                DebugWrite("IPAPI: Inbound players found. Grabbing.", 6);
                                //Grab all items in the queue
                                unprocessedPlayers = new Queue<AdKatsPlayer>(_IPInfoFetchQueue.ToArray());
                                //Clear the queue for next run
                                _IPInfoFetchQueue.Clear();
                            }
                            //Loop through all players in order that they came in
                            while (unprocessedPlayers.Count > 0)
                            {
                                if (!_pluginEnabled)
                                {
                                    break;
                                }
                                DebugWrite("IPAPI: Preparing to fetch IP API info for player", 6);
                                //Dequeue the record
                                AdKatsPlayer aPlayer = unprocessedPlayers.Dequeue();
                                //Run the appropriate action
                                FetchIPLocation(aPlayer);
                            }
                        }
                        else
                        {
                            DebugWrite("IPAPI: No inbound players. Waiting.", 6);
                            //Wait for new actions
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _IPInfoWaitHandle.Reset();
                            _IPInfoWaitHandle.WaitOne(TimeSpan.FromSeconds(5));
                            loopStart = UtcDbTime();
                        }
                    }
                    catch (Exception e)
                    {
                        if (e is ThreadAbortException)
                        {
                            HandleException(new AdKatsException("IP API comm thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in IP API comm thread. Skipping current loop.", e));
                    }
                }
                DebugWrite("IPAPI: Ending IP API Comm Thread", 1);
                LogThreadExit();
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error occured in IP API comm thread.", e));
            }
        }

        private void QueuePlayerForBattlelogInfoFetch(AdKatsPlayer aPlayer)
        {
            DebugWrite("Entering QueuePlayerForBattlelogInfoFetch", 6);
            try
            {
                DebugWrite("Preparing to queue player for battlelog info fetch.", 6);
                lock (_BattlelogFetchQueue)
                {
                    _BattlelogFetchQueue.Enqueue(aPlayer);
                    DebugWrite("Player queued for battlelog info fetch.", 6);
                    _BattlelogCommWaitHandle.Set();
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while queuing player for battlelog info fetch.", e));
            }
            DebugWrite("Exiting QueuePlayerForBattlelogInfoFetch", 6);
        }

        public void BattlelogCommThreadLoop()
        {
            try
            {
                DebugWrite("BTLOG: Starting Battlelog Comm Thread", 1);
                Thread.CurrentThread.Name = "BattlelogComm";
                DateTime loopStart = UtcDbTime();
                while (true)
                {
                    try
                    {
                        DebugWrite("BTLOG: Entering Battlelog Comm Thread Loop", 7);
                        if (!_pluginEnabled)
                        {
                            DebugWrite("BTLOG: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }
                        //Sleep for 10ms
                        _threadMasterWaitHandle.WaitOne(10);

                        //Handle Inbound player fetches
                        if (_BattlelogFetchQueue.Count > 0)
                        {
                            Queue<AdKatsPlayer> unprocessedPlayers;
                            lock (_BattlelogFetchQueue)
                            {
                                DebugWrite("BTLOG: Inbound players found. Grabbing.", 6);
                                //Grab all items in the queue
                                unprocessedPlayers = new Queue<AdKatsPlayer>(_BattlelogFetchQueue.ToArray());
                                //Clear the queue for next run
                                _BattlelogFetchQueue.Clear();
                            }
                            //Loop through all players in order that they came in
                            while (unprocessedPlayers.Count > 0)
                            {
                                if (!_pluginEnabled)
                                {
                                    break;
                                }
                                DebugWrite("BTLOG: Preparing to fetch battlelog info for player", 6);
                                //Dequeue the record
                                AdKatsPlayer aPlayer = unprocessedPlayers.Dequeue();
                                //Old Tag
                                String oldTag = aPlayer.player_clanTag;
                                //Run the appropriate action
                                FetchPlayerBattlelogInformation(aPlayer);
                                //Update database with clan tag
                                if (!String.IsNullOrEmpty(aPlayer.player_clanTag) && (String.IsNullOrEmpty(oldTag) || aPlayer.player_clanTag != oldTag)) {
                                    UpdatePlayer(aPlayer);
                                }
                            }
                        }
                        else
                        {
                            DebugWrite("BTLOG: No inbound players. Waiting.", 6);
                            //Wait for new actions
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _BattlelogCommWaitHandle.Reset();
                            _BattlelogCommWaitHandle.WaitOne(TimeSpan.FromSeconds(5));
                            loopStart = UtcDbTime();
                        }
                    }
                    catch (Exception e)
                    {
                        if (e is ThreadAbortException)
                        {
                            HandleException(new AdKatsException("Battlelog comm thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in Battlelog comm thread. Skipping current loop.", e));
                    }
                }
                DebugWrite("BTLOG: Ending Battlelog Comm Thread", 1);
                LogThreadExit();
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error occured in battlelog comm thread.", e));
            }
        }

        private void QueueRecordForActionHandling(AdKatsRecord record) {
            DebugWrite("Entering queueRecordForActionHandling", 6);
            try {
                DebugWrite("Preparing to queue record for action handling", 6);
                lock (_UnprocessedActionQueue) {
                    _UnprocessedActionQueue.Enqueue(record);
                    DebugWrite("Record queued for action handling", 6);
                    _ActionHandlingWaitHandle.Set();
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while queuing record for action handling.", e);
                HandleException(record.record_exception);
            }
            DebugWrite("Exiting queueRecordForActionHandling", 6);
        }

        private void ActionHandlingThreadLoop() {
            try {
                DebugWrite("ACTION: Starting Action Thread", 1);
                Thread.CurrentThread.Name = "action";
                DateTime loopStart = UtcDbTime();
                while (true) {
                    try {
                        DebugWrite("ACTION: Entering Action Thread Loop", 7);
                        if (!_pluginEnabled) {
                            DebugWrite("ACTION: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }
                        //Sleep for 10ms
                        _threadMasterWaitHandle.WaitOne(10);

                        //Handle Inbound Actions
                        if (_UnprocessedActionQueue.Count > 0) {
                            Queue<AdKatsRecord> unprocessedActions;
                            lock (_UnprocessedActionQueue) {
                                DebugWrite("ACTION: Inbound actions found. Grabbing.", 6);
                                //Grab all messages in the queue
                                unprocessedActions = new Queue<AdKatsRecord>(_UnprocessedActionQueue.ToArray());
                                //Clear the queue for next run
                                _UnprocessedActionQueue.Clear();
                            }
                            //Loop through all records in order that they came in
                            while (unprocessedActions.Count > 0)
                            {
                                if (!_pluginEnabled)
                                {
                                    break;
                                }
                                DebugWrite("ACTION: Preparing to Run Actions for record", 6);
                                //Dequeue the record
                                AdKatsRecord record = unprocessedActions.Dequeue();
                                //Run the appropriate action
                                RunAction(record);
                                //If more processing is needed, then perform it
                                //If any errors exist in the record, do not re-queue
                                if (record.record_exception == null) {
                                    QueueRecordForProcessing(record);
                                }
                                else {
                                    DebugWrite("ACTION: Record has errors, not re-queueing after action.", 3);
                                }
                            }
                        }
                        else {
                            DebugWrite("ACTION: No inbound actions. Waiting.", 6);
                            //Wait for new actions
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _ActionHandlingWaitHandle.Reset();
                            _ActionHandlingWaitHandle.WaitOne(TimeSpan.FromSeconds(5));
                            loopStart = UtcDbTime();
                        }
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            HandleException(new AdKatsException("Action Handling thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in Action Handling thread. Skipping current loop.", e));
                    }
                }
                DebugWrite("ACTION: Ending Action Handling Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in action handling thread.", e));
            }
        }

        private void RunAction(AdKatsRecord record) {
            DebugWrite("Entering runAction", 6);
            try {
                //Make sure record has an action
                if (record.command_action == null) {
                    record.command_action = record.command_type;
                }
                //Automatic player locking
                if (!record.record_action_executed && 
                    record.target_player != null && 
                    (record.source_player == null || PlayerIsAdmin(record.source_player)) &&
                    _playerLockingAutomaticLock && 
                    !record.target_player.IsLocked()) {
                    record.target_player.Lock(record.source_name, TimeSpan.FromMinutes(_playerLockingAutomaticDuration));
                }
                //Perform Actions
                switch (record.command_action.command_key) {
                    case "player_move":
                        MoveTarget(record);
                        break;
                    case "player_fmove":
                        ForceMoveTarget(record);
                        break;
                    case "self_teamswap":
                        ForceMoveTarget(record);
                        break;
                    case "self_assist":
                        AssistWeakTeam(record);
                        break;
                    case "self_kill":
                        ForceKillTarget(record);
                        break;
                    case "player_kill":
                        KillTarget(record);
                        break;
                    case "player_kill_force":
                        ForceKillTarget(record);
                        break;
                    case "player_warn":
                        WarnTarget(record);
                        break;
                    case "player_kill_lowpop":
                        KillTarget(record);
                        break;
                    case "player_kill_repeat":
                        KillTarget(record);
                        break;
                    case "player_kick":
                        KickTarget(record);
                        break;
                    case "player_ban_temp":
                        TempBanTarget(record);
                        break;
                    case "player_ban_perm":
                        PermaBanTarget(record);
                        break;
                    case "player_ban_perm_future":
                        FuturePermaBanTarget(record);
                        break;
                    case "player_unban":
                        UnBanTarget(record);
                        break;
                    case "player_punish":
                        PunishTarget(record);
                        break;
                    case "player_forgive":
                        ForgiveTarget(record);
                        break;
                    case "player_mute":
                        MuteTarget(record);
                        break;
                    case "player_join":
                        JoinTarget(record);
                        break;
                    case "player_pull":
                        PullTarget(record);
                        break;
                    case "player_report":
                        ReportTarget(record);
                        break;
                    case "player_calladmin":
                        CallAdminOnTarget(record);
                        break;
                    case "player_info":
                        SendTargetInfo(record);
                        break;
                    case "player_chat":
                        SendTargetChat(record);
                        break;
                    case "player_find":
                        FindTarget(record);
                        break;
                    case "player_lock":
                        LockTarget(record);
                        break;
                    case "player_unlock":
                        UnlockTarget(record);
                        break;
                    case "player_mark":
                        MarkTarget(record);
                        break;
                    case "server_afk":
                        ManageAFKPlayers(record);
                        break;
                    case "round_restart":
                        RestartLevel(record);
                        break;
                    case "round_next":
                        NextLevel(record);
                        break;
                    case "round_end":
                        EndLevel(record);
                        break;
                    case "server_nuke":
                        NukeTarget(record);
                        break;
                    case "server_countdown":
                        CountdownTarget(record);
                        break;
                    case "server_kickall":
                        KickAllPlayers(record);
                        break;
                    case "server_swapnuke":
                        SwapNukeServer(record);
                        break;
                    case "admin_say":
                        AdminSay(record);
                        break;
                    case "player_say":
                        PlayerSay(record);
                        break;
                    case "admin_yell":
                        AdminYell(record);
                        break;
                    case "player_yell":
                        PlayerYell(record);
                        break;
                    case "admin_tell":
                        AdminTell(record);
                        break;
                    case "player_tell":
                        PlayerTell(record);
                        break;
                    case "player_pm_send":
                        PMSendTarget(record);
                        break;
                    case "player_pm_reply":
                        PMReplyTarget(record);
                        break;
                    case "player_pm_start":
                        PMStartTarget(record);
                        break;
                    case "player_pm_cancel":
                        PMCancelTarget(record);
                        break;
                    case "player_pm_transmit":
                        PMTransmitTarget(record);
                        break;
                    case "admin_pm_send":
                        PMOnlineAdmins(record);
                        break;
                    case "player_dequeue":
                        DequeueTarget(record);
                        break;
                    case "player_blacklistdisperse":
                        BalanceDisperseTarget(record);
                        break;
                    case "player_whitelistbalance":
                        BalanceWhitelistTarget(record);
                        break;
                    case "player_slotreserved":
                        ReservedSlotTarget(record);
                        break;
                    case "player_slotspectator":
                        SpectatorSlotTarget(record);
                        break;
                    case "player_whitelisthackerchecker":
                        HackerCheckerWhitelistTarget(record);
                        break;
                    case "player_whitelistping":
                        PingWhitelistTarget(record);
                        break;
                    case "player_whitelistaa":
                        AAWhitelistTarget(record);
                        break;
                    case "player_whitelistspambot":
                        SpamBotWhitelistTarget(record);
                        break;
                    case "player_log":
                        SendMessageToSource(record, "Log saved for " + record.GetTargetNames());
                        break;
                    case "player_population_success":
                        SendPopulationSuccess(record);
                        break;
                    case "self_rules":
                        SendServerRules(record);
                        break;
                    case "self_surrender":
                        SourceVoteSurrender(record);
                        break;
                    case "self_nosurrender":
                        SourceVoteNoSurrender(record);
                        break;
                    case "self_votenext":
                        SourceVoteSurrender(record);
                        break;
                    case "self_help":
                        SendServerCommands(record);
                        break;
                    case "self_rep":
                        SendTargetRep(record);
                        break;
                    case "self_uptime":
                        SendUptime(record);
                        break;
                    case "self_admins":
                        SendOnlineAdmins(record);
                        break;
                    case "self_lead":
                        LeadCurrentSquad(record);
                        break;
                    case "self_reportlist":
                        SendRoundReports(record);
                        break;
                    case "plugin_restart":
                        RebootPlugin(record);
                        break;
                    case "plugin_update":
                        UpdatePlugin(record);
                        break;
                    case "server_shutdown":
                        ShutdownServer(record);
                        break;
                    case "adkats_exception":
                        record.record_action_executed = true;
                        break;
                    case "player_changename":
                    case "player_changeip":
                    case "admin_accept":
                    case "admin_deny":
                    case "admin_ignore":
                    case "self_contest":
                    case "banenforcer_enforce":
                    case "player_repboost":
                    case "server_map_detriment":
                    case "server_map_benefit":
                        record.record_action_executed = true;
                        //Don't do anything here
                        break;
                    default:
                        record.record_action_executed = true;
                        SendMessageToSource(record, "Command not recognized when running " + record.command_action.command_key + " action.");
                        record.record_exception = HandleException(new AdKatsException("Command " + record.command_action + " not found in runAction"));
                        FinalizeRecord(record);
                        break;
                }
                DebugWrite(record.command_type.command_key + " last used " + FormatTimeString(UtcDbTime() - _commandUsageTimes[record.command_type.command_key], 10) + " ago.", 3);
                _commandUsageTimes[record.command_type.command_key] = UtcDbTime();
            }
            catch (Exception e) {
                record.record_exception = HandleException(new AdKatsException("Error while choosing action for record.", e));
            }
            DebugWrite("Exiting runAction", 6);
        }

        public void MoveTarget(AdKatsRecord record) {
            DebugWrite("Entering moveTarget", 6);
            try
            {
                record.record_action_executed = true;
                if (_gameVersion == GameVersion.BF4 && !record.isAliveChecked)
                {
                    if (!_ActOnIsAliveDictionary.ContainsKey(record.target_player.player_name))
                    {
                        lock (_ActOnIsAliveDictionary)
                        {
                            _ActOnIsAliveDictionary.Add(record.target_player.player_name, record);
                        }
                    }
                    ExecuteCommand("procon.protected.send", "player.isAlive", record.target_name);
                    return;
                }

                QueuePlayerForMove(record.target_player.frostbitePlayerInfo);
                PlayerSayMessage(record.target_name, "On your next death you will be moved to the opposing team.");
                SendMessageToSource(record, record.GetTargetNames() + " will be sent to TeamSwap on their next death.");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for move record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting moveTarget", 6);
        }

        public void ForceMoveTarget(AdKatsRecord record) {
            DebugWrite("Entering forceMoveTarget", 6);
            String message = null;
            try
            {
                record.record_action_executed = true;
                if (record.command_type == GetCommandByKey("self_teamswap")) {
                    if ((record.source_player != null && HasAccess(record.source_player, GetCommandByKey("self_teamswap"))) || ((_TeamSwapTicketWindowHigh >= _highestTicketCount) && (_TeamSwapTicketWindowLow <= _lowestTicketCount))) {
                        message = "Calling Teamswap on self";
                        DebugWrite(message, 6);
                        QueuePlayerForForceMove(record.target_player.frostbitePlayerInfo);
                    }
                    else {
                        message = "Player unable to TeamSwap";
                        DebugWrite(message, 6);
                        SendMessageToSource(record, "You cannot TeamSwap at this time. Game outside ticket window [" + _TeamSwapTicketWindowLow + ", " + _TeamSwapTicketWindowHigh + "].");
                    }
                }
                else {
                    message = "TeamSwap called on " + record.GetTargetNames();
                    DebugWrite("Calling Teamswap on target", 6);
                    SendMessageToSource(record, "" + record.GetTargetNames() + " sent to TeamSwap.");
                    QueuePlayerForForceMove(record.target_player.frostbitePlayerInfo);
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for force-move/teamswap record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting forceMoveTarget", 6);
        }

        public void AssistWeakTeam(AdKatsRecord record) {
            DebugWrite("Entering AssistLosingTeam", 6);
            try
            {
                record.record_action_executed = true;
                QueuePlayerForForceMove(record.target_player.frostbitePlayerInfo);
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for assist record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting AssistLosingTeam", 6);
        }

        public void KillTarget(AdKatsRecord record) {
            DebugWrite("Entering killTarget", 6);
            String message = null;
            try
            {
                record.record_action_executed = true;
                if (record.source_name != record.target_name) {
                    switch (_gameVersion) {
                        case GameVersion.BF3:
                            if (record.command_type.command_key == "player_punish") {
                                if (record.source_name == "AutoAdmin" || record.source_name == "ProconAdmin") {
                                    AdminSayMessage("Punishing " + record.GetTargetNames() + " for " + record.record_message);
                                } else {
                                    AdminSayMessage(record.GetTargetNames() + " PUNISHED by " + ((_ShowAdminNameInAnnouncement) ? (record.GetSourceName()) : ("admin")) + " for " + record.record_message);
                                }
                            }
                            var seconds = (int) UtcDbTime().Subtract(record.target_player.lastDeath).TotalSeconds;
                            DebugWrite("Killing player. Player last died " + seconds + " seconds ago.", 3);
                            if (seconds < 6 && record.command_action.command_key != "player_kill_repeat") {
                                DebugWrite("Queueing player for kill on spawn. (" + seconds + ")&(" + record.command_action + ")", 3);
                                if (!_ActOnSpawnDictionary.ContainsKey(record.target_player.player_name)) {
                                    lock (_ActOnSpawnDictionary) {
                                        record.command_action = GetCommandByKey("player_kill_repeat");
                                        _ActOnSpawnDictionary.Add(record.target_player.player_name, record);
                                    }
                                }
                            }
                            break;
                        case GameVersion.BF4:
                            if (!record.isAliveChecked)
                            {
                                if (record.command_type.command_key == "player_punish")
                                {
                                    if (record.source_name == "AutoAdmin" || record.source_name == "ProconAdmin")
                                    {
                                        AdminSayMessage("Punishing " + record.GetTargetNames() + " for " + record.record_message);
                                    }
                                    else
                                    {
                                        AdminSayMessage(record.GetTargetNames() + " PUNISHED by " + ((_ShowAdminNameInAnnouncement) ? (record.GetSourceName()) : ("admin")) + " for " + record.record_message);
                                    }
                                }
                                if (!_ActOnIsAliveDictionary.ContainsKey(record.target_player.player_name)) {
                                    lock (_ActOnIsAliveDictionary) {
                                        _ActOnIsAliveDictionary.Add(record.target_player.player_name, record);
                                    }
                                }
                                ExecuteCommand("procon.protected.send", "player.isAlive", record.target_name);
                                return;
                            }
                            break;
                        default:
                            ConsoleError("Invalid game version in killtarget");
                            return;
                    }
                }

                //Perform actions
                if (String.IsNullOrEmpty(record.target_player.player_name)) {
                    ConsoleError("playername null in 5437");
                }
                else {
                    ExecuteCommand("procon.protected.send", "admin.killPlayer", record.target_player.player_name);
                    if (record.source_name != record.target_name || record.command_type.command_key == "player_punish") {
                        PlayerTellMessage(record.target_name, "Killed by admin for " + record.record_message);
                        SendMessageToSource(record, "You KILLED " + record.GetTargetNames() + " for " + record.record_message);
                    }
                    else {
                        PlayerTellMessage(record.target_name, "You killed yourself");
                    }
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for kill record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting killTarget", 6);
        }

        public void ForceKillTarget(AdKatsRecord record)
        {
            DebugWrite("Entering ForceKillTarget", 6);
            String message = null;
            try
            {
                record.record_action_executed = true;
                //Perform actions
                if (String.IsNullOrEmpty(record.target_player.player_name))
                {
                    ConsoleError("playername null in 14491");
                }
                else
                {
                    ExecuteCommand("procon.protected.send", "admin.killPlayer", record.target_player.player_name);
                    if (record.source_name != record.target_name)
                    {
                        PlayerTellMessage(record.target_name, "Killed by admin for " + record.record_message);
                        SendMessageToSource(record, "You KILLED " + record.GetTargetNames() + " for " + record.record_message);
                    }
                    else
                    {
                        PlayerTellMessage(record.target_name, "You killed yourself");
                    }
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for kill record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting ForceKillTarget", 6);
        }

        public void WarnTarget(AdKatsRecord record)
        {
            DebugWrite("Entering WarnTarget", 6);
            String message = null;
            try
            {
                record.record_action_executed = true;
                //Perform actions
                if (String.IsNullOrEmpty(record.target_player.player_name))
                {
                    ConsoleError("playername null in 14526");
                }
                else
                {
                    SendMessageToSource(record, "You WARNED " + record.GetTargetNames() + " for " + record.record_message);
                    AdminSayMessage(record.GetTargetNames() + " WARNED by " + ((_ShowAdminNameInAnnouncement) ? (record.GetSourceName()) : ("admin")) + " for " + record.record_message);
                    PlayerTellMessage(record.target_name, "Warned by admin for " + record.record_message, true, 3);
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for warn record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting WarnTarget", 6);
        }

        public void DequeueTarget(AdKatsRecord record)
        {
            DebugWrite("Entering DequeueTarget", 6);
            try
            {
                record.record_action_executed = true;
                if (record.target_player != null) {
                    DequeuePlayer(record.target_player);
                    PlayerSayMessage(record.target_name, "All queued actions canceled.");
                    SendMessageToSource(record, "All queued actions for " + record.GetTargetNames() + " canceled.");
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for dequeue record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting DequeueTarget", 6);
        }

        public void DequeuePlayer(AdKatsPlayer aPlayer)
        {
            DebugWrite("Entering DequeuePlayer", 6);
            try
            {
                //Handle spawn action
                if (_ActOnSpawnDictionary.ContainsKey(aPlayer.player_name))
                {
                    _ActOnSpawnDictionary.Remove(aPlayer.player_name);
                }
                //Handle teamswap action
                lock (_Team1MoveQueue)
                {
                    CPlayerInfo info = _Team1MoveQueue.FirstOrDefault(playerInfo => playerInfo.SoldierName == aPlayer.player_name);
                    if (info != null)
                        _Team1MoveQueue = new Queue<CPlayerInfo>(_Team1MoveQueue.Where(p => p != info));
                }
                lock (_Team2MoveQueue)
                {
                    CPlayerInfo info = _Team2MoveQueue.FirstOrDefault(playerInfo => playerInfo.SoldierName == aPlayer.player_name);
                    if (info != null)
                        _Team2MoveQueue = new Queue<CPlayerInfo>(_Team2MoveQueue.Where(p => p != info));
                }
                lock (_TeamswapForceMoveQueue)
                {
                    CPlayerInfo info = _TeamswapForceMoveQueue.FirstOrDefault(playerInfo => playerInfo.SoldierName == aPlayer.player_name);
                    if (info != null)
                        _TeamswapForceMoveQueue = new Queue<CPlayerInfo>(_TeamswapForceMoveQueue.Where(p => p != info));
                }
                lock (_TeamswapOnDeathCheckingQueue)
                {
                    CPlayerInfo info = _TeamswapOnDeathCheckingQueue.FirstOrDefault(playerInfo => playerInfo.SoldierName == aPlayer.player_name);
                    if (info != null)
                        _TeamswapOnDeathCheckingQueue = new Queue<CPlayerInfo>(_TeamswapOnDeathCheckingQueue.Where(p => p != info));
                }
                if (_TeamswapOnDeathMoveDic.ContainsKey(aPlayer.player_name))
                {
                    _TeamswapOnDeathMoveDic.Remove(aPlayer.player_name);
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while dequeuing player.", e));
            }
            DebugWrite("Exiting DequeuePlayer", 6);
        }

        public void KickTarget(AdKatsRecord record) {
            DebugWrite("Entering kickTarget", 6);
            try
            {
                record.record_action_executed = true;
                String kickReason = GenerateKickReason(record);
                //Perform Actions
                DebugWrite("Kick Message: '" + kickReason + "'", 3);
                if (String.IsNullOrEmpty(record.target_player.player_name) || String.IsNullOrEmpty(kickReason)) {
                    ConsoleError("Item null in 5464");
                }
                else {
                    ExecuteCommand("procon.protected.send", "admin.kickPlayer", record.target_player.player_name, kickReason);
                    if (record.target_name != record.source_name && record.source_name != "AFKManager") {
                        AdminSayMessage(record.GetTargetNames() + " was KICKED by " + ((_ShowAdminNameInAnnouncement) ? (record.GetSourceName()) : ("admin")) + " for " + record.record_message);
                    }
                    if (record.target_player.frostbitePlayerInfo != null) {
                        String teamLocation;
                        SendMessageToSource(record, "You KICKED " + record.GetTargetNames() + " from " + GetPlayerTeamName(record.target_player) + " for " + record.record_message);
                    }
                    else
                    {
                        SendMessageToSource(record, "You KICKED " + record.GetTargetNames() + " for " + record.record_message);
                    }
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for kick record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting kickTarget", 6);
        }

        public void TempBanTarget(AdKatsRecord record) {
            DebugWrite("Entering tempBanTarget", 6);
            try
            {
                record.record_action_executed = true;
                //Subtract 1 second for visual effect
                Int32 seconds = (record.command_numeric * 60) - 1;

                //Perform Actions
                //Only post to ban enforcer if there are no exceptions
                if (_UseBanEnforcer && record.record_exception == null) {
                    //Update the ban enforcement depending on available information
                    Boolean nameAvailable = !String.IsNullOrEmpty(record.target_player.player_name);
                    Boolean guidAvailable = !String.IsNullOrEmpty(record.target_player.player_guid);
                    Boolean ipAvailable = !String.IsNullOrEmpty(record.target_player.player_ip);

                    //Create the ban
                    var aBan = new AdKatsBan {
                        ban_record = record,
                        ban_enforceName = nameAvailable && (_DefaultEnforceName || (!guidAvailable && !ipAvailable)),
                        ban_enforceGUID = guidAvailable && (_DefaultEnforceGUID || (!nameAvailable && !ipAvailable)),
                        ban_enforceIP = ipAvailable && (_DefaultEnforceIP || (!nameAvailable && !guidAvailable))
                    };

                    //Queue the ban for upload
                    QueueBanForProcessing(aBan);
                }
                else {
                    if (record.record_exception != null) {
                        HandleException(new AdKatsException("Defaulting to procon banlist usage since exceptions existed in record"));
                    }
                    //Trim the ban message if necessary
                    String banMessage = record.record_message + " [" + record.source_name + "]";
                    Int32 cutLength = banMessage.Length - 80;
                    if (cutLength > 0) {
                        banMessage = banMessage.Substring(0, banMessage.Length - cutLength);
                    }
                    DebugWrite("Ban Message: '" + banMessage + "'", 3);
                    if (!String.IsNullOrEmpty(record.target_player.player_guid)) {
                        ExecuteCommand("procon.protected.send", "banList.add", "guid", record.target_player.player_guid, "seconds", seconds + "", banMessage);
                        ExecuteCommand("procon.protected.send", "banList.save");
                        ExecuteCommand("procon.protected.send", "banList.list");
                    }
                    else if (!String.IsNullOrEmpty(record.target_player.player_ip)) {
                        ExecuteCommand("procon.protected.send", "banList.add", "ip", record.target_player.player_ip, "seconds", seconds + "", banMessage);
                        ExecuteCommand("procon.protected.send", "banList.save");
                        ExecuteCommand("procon.protected.send", "banList.list");
                    }
                    else if (!String.IsNullOrEmpty(record.target_player.player_name)) {
                        ExecuteCommand("procon.protected.send", "banList.add", "id", record.target_player.player_name, "seconds", seconds + "", banMessage);
                        ExecuteCommand("procon.protected.send", "banList.save");
                        ExecuteCommand("procon.protected.send", "banList.list");
                    }
                    else {
                        ConsoleError("Player has no information to ban with.");
                        SendMessageToSource(record, "ERROR");
                    }
                }
                if (record.target_name != record.source_name) {
                    AdminSayMessage(record.GetTargetNames() + " was BANNED by " + ((_ShowAdminNameInAnnouncement) ? (record.GetSourceName()) : ("admin")) + " for " + record.record_message);
                }
                SendMessageToSource(record, "You TEMP BANNED " + record.GetTargetNames() + " for " + FormatTimeString(TimeSpan.FromMinutes(record.command_numeric), 3));
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for TempBan record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting tempBanTarget", 6);
        }

        public void PermaBanTarget(AdKatsRecord record) {
            DebugWrite("Entering permaBanTarget", 6);
            try
            {
                record.record_action_executed = true;
                //Perform Actions
                //Only post to ban enforcer if there are no exceptions
                if (_UseBanEnforcer && record.record_exception == null) {
                    //Update the ban enforcement depending on available information
                    Boolean nameAvailable = !String.IsNullOrEmpty(record.target_player.player_name);
                    Boolean guidAvailable = !String.IsNullOrEmpty(record.target_player.player_guid);
                    Boolean ipAvailable = !String.IsNullOrEmpty(record.target_player.player_ip);

                    //Create the ban
                    var aBan = new AdKatsBan {
                        ban_record = record,
                        ban_enforceName = nameAvailable && (_DefaultEnforceName || (!guidAvailable && !ipAvailable)),
                        ban_enforceGUID = guidAvailable && (_DefaultEnforceGUID || (!nameAvailable && !ipAvailable)),
                        ban_enforceIP = ipAvailable && (_DefaultEnforceIP || (!nameAvailable && !guidAvailable))
                    };

                    //Queue the ban for upload
                    QueueBanForProcessing(aBan);
                }
                else {
                    if (record.record_exception != null) {
                        HandleException(new AdKatsException("Defaulting to procon banlist usage since exceptions existed in record"));
                    }
                    //Trim the ban message if necessary
                    String banMessage = record.record_message + " [" + record.source_name + "]";
                    Int32 cutLength = banMessage.Length - 80;
                    if (cutLength > 0) {
                        banMessage = banMessage.Substring(0, banMessage.Length - cutLength);
                    }
                    DebugWrite("Ban Message: '" + banMessage + "'", 3);
                    if (!String.IsNullOrEmpty(record.target_player.player_guid)) {
                        ExecuteCommand("procon.protected.send", "banList.add", "guid", record.target_player.player_guid, "perm", banMessage);
                        ExecuteCommand("procon.protected.send", "banList.save");
                        ExecuteCommand("procon.protected.send", "banList.list");
                    }
                    else if (!String.IsNullOrEmpty(record.target_player.player_ip)) {
                        ExecuteCommand("procon.protected.send", "banList.add", "ip", record.target_player.player_ip, "perm", banMessage);
                        ExecuteCommand("procon.protected.send", "banList.save");
                        ExecuteCommand("procon.protected.send", "banList.list");
                    }
                    else if (!String.IsNullOrEmpty(record.target_player.player_name)) {
                        ExecuteCommand("procon.protected.send", "banList.add", "id", record.target_player.player_name, "perm", banMessage);
                        ExecuteCommand("procon.protected.send", "banList.save");
                        ExecuteCommand("procon.protected.send", "banList.list");
                    }
                    else {
                        ConsoleError("Player has no information to ban with.");
                        SendMessageToSource(record, "ERROR");
                    }
                }
                if (record.target_name != record.source_name) {
                    AdminSayMessage(record.GetTargetNames() + " was BANNED by " + ((_ShowAdminNameInAnnouncement) ? (record.GetSourceName()) : ("admin")) + " for " + record.record_message);
                }
                SendMessageToSource(record, "You PERMA BANNED " + record.GetTargetNames());
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for PermaBan record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting permaBanTarget", 6);
        }

        public void FuturePermaBanTarget(AdKatsRecord record) {
            DebugWrite("Entering permaBanTarget", 6);
            try {
                record.record_action_executed = true;
                if (_UseBanEnforcer && record.record_exception == null) {
                    Boolean nameAvailable = !String.IsNullOrEmpty(record.target_player.player_name);
                    Boolean guidAvailable = !String.IsNullOrEmpty(record.target_player.player_guid);
                    Boolean ipAvailable = !String.IsNullOrEmpty(record.target_player.player_ip);
                    var aBan = new AdKatsBan {
                        ban_record = record,
                        ban_enforceName = nameAvailable && (_DefaultEnforceName || (!guidAvailable && !ipAvailable)),
                        ban_enforceGUID = guidAvailable && (_DefaultEnforceGUID || (!nameAvailable && !ipAvailable)),
                        ban_enforceIP = ipAvailable && (_DefaultEnforceIP || (!nameAvailable && !guidAvailable))
                    };
                    QueueBanForProcessing(aBan);
                    DateTime endTime = record.record_time + TimeSpan.FromMinutes(record.command_numeric);
                    SendMessageToSource(record, "You FUTURE BANNED " + record.GetTargetNames() + ". Their ban will activate at " + endTime + " UTC.");
                }
                else {
                    SendMessageToSource(record, "Future ban cannot be posted.");
                    FinalizeRecord(record);
                    return;
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for PermaBan record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting permaBanTarget", 6);
        }

        public void UnBanTarget(AdKatsRecord record) {
            DebugWrite("Entering UnBanTarget", 6);
            try
            {
                record.record_action_executed = true;
                //Cancel call if not using ban enforcer
                if (!_UseBanEnforcer || !_UseBanEnforcerPreviousState)
                {
                    return;
                }
                if (record.target_player == null) {
                    ConsoleError("Player was null when attempting to unban.");
                    FinalizeRecord(record);
                    return;
                }
                List<AdKatsBan> banList = FetchPlayerBans(record.target_player);
                if (banList.Count == 0) {
                    FinalizeRecord(record);
                    return;
                }
                foreach (AdKatsBan aBan in banList) {
                    aBan.ban_status = "Disabled";
                    UpdateBanStatus(aBan);
                    if (aBan.ban_record.command_action.command_key == "player_ban_perm" ||
                        aBan.ban_record.command_action.command_key == "player_ban_perm_future")
                    {
                        aBan.ban_record.command_action = GetCommandByKey("player_ban_perm_old");
                    }
                    else if (aBan.ban_record.command_action.command_key == "player_ban_temp")
                    {
                        aBan.ban_record.command_action = GetCommandByKey("player_ban_temp_old");
                    }
                    UpdateRecord(aBan.ban_record);

                    //Submit ban removal to metabans
                    if (_useMetabans && !String.IsNullOrEmpty(_metabansUsername) && !String.IsNullOrEmpty(_metabansAPIKey))
                    {
                        SubmitToMetabans(aBan, AssessmentTypes.none);
                    }
                }
                SendMessageToSource(record, record.GetTargetNames() + " is now unbanned.");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for UnBan record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting UnBanTarget", 6);
        }

        public void EnforceBan(AdKatsBan aBan, Boolean verbose) {
            DebugWrite("Entering enforceBan", 6);
            try {
                //Create the total kick message
                String generatedBanReason = GenerateBanReason(aBan);
                DebugWrite("Ban Enforce Message: '" + generatedBanReason + "'", 3);

                //Perform Actions
                if (_PlayerDictionary.ContainsKey(aBan.ban_record.target_player.player_name) && aBan.ban_startTime < UtcDbTime()) {
                    ExecuteCommand("procon.protected.send", "admin.kickPlayer", aBan.ban_record.target_player.player_name, generatedBanReason);
                    //Inform the server of the enforced ban
                    if (verbose) {
                        String banDurationString;
                        //If ban time > 1000 days just say perm
                        TimeSpan remainingTime = GetRemainingBanTime(aBan);
                        TimeSpan totalTime = aBan.ban_endTime.Subtract(aBan.ban_startTime);
                        if (remainingTime.TotalDays > 365) {
                            banDurationString = "permanent";
                        }
                        else {
                            banDurationString = FormatTimeString(totalTime, 2) + " (" + FormatTimeString(remainingTime, 2) + ")";
                        }
                        AdminSayMessage("Enforcing " + banDurationString + " ban on " + aBan.ban_record.GetTargetNames() + " for " + aBan.ban_record.record_message);
                    }
                }
            }
            catch (Exception e) {
                aBan.ban_exception = new AdKatsException("Error while enforcing ban.", e);
                HandleException(aBan.ban_exception);
            }
            DebugWrite("Exiting enforceBan", 6);
        }

        public void PunishTarget(AdKatsRecord record) {
            DebugWrite("Entering PunishTarget", 6);
            try
            {
                record.record_action_executed = true;
                //If the record has any exceptions, skip everything else and just kill the player
                if (record.record_exception == null) {
                    //Get number of points the player from server
                    Int32 points = FetchPoints(record.target_player, false);
                    DebugWrite(record.GetTargetNames() + " has " + points + " points.", 5);
                    //Get the proper action to take for player punishment
                    String action = "noaction";
                    String skippedAction = null;
                    if (points > (_PunishmentHierarchy.Length - 1)) {
                        action = _PunishmentHierarchy[_PunishmentHierarchy.Length - 1];
                    }
                    else if (points > 1) {
                        action = _PunishmentHierarchy[points - 1];
                        if (record.isIRO) {
                            skippedAction = _PunishmentHierarchy[points - 2];
                        }
                    }
                    else {
                        action = _PunishmentHierarchy[0];
                    }

                    //Handle the case where and IRO punish skips higher level punishment for a lower one, use the higher one
                    if (skippedAction != null && _PunishmentSeverityIndex.IndexOf(skippedAction) > _PunishmentSeverityIndex.IndexOf(action)) {
                        action = skippedAction;
                    }
                    if (_isTestingAuthorized && record.target_player.player_reputation > 15)
                    {
                        action = "repwarn";
                    }

                    //Set additional message
                    String pointMessage = " [" + ((record.isIRO) ? ("IRO ") : ("")) + points + "pts]";
                    if (!record.record_message.Contains(pointMessage)) {
                        record.record_message += pointMessage;
                    }

                    Boolean isLowPop = _OnlyKillOnLowPop && (_PlayerDictionary.Count < _highPopulationPlayerCount);
                    Boolean iroOverride = record.isIRO && _IROOverridesLowPop;

                    DebugWrite("Server low population: " + isLowPop + " (" + _PlayerDictionary.Count + " <? " + _highPopulationPlayerCount + ") | Override: " + iroOverride, 5);

                    //Call correct action
                    if (action == "repwarn")
                    {
                        record.command_action = GetCommandByKey("player_warn");
                        WarnTarget(record);
                        _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(1));
                        PlayerTellMessage(record.target_name, "Your reputation protected you from a punish, but has been reduced. Inform an admin!", true, 3);
                    }
                    else if (action == "warn")
                    {
                        record.command_action = GetCommandByKey("player_warn");
                        WarnTarget(record);
                    }
                    else if ((action == "kill" || (isLowPop && !iroOverride)) && !action.Equals("ban")) 
                    {
                        record.command_action = (isLowPop) ? (GetCommandByKey("player_kill_lowpop")) : (GetCommandByKey("player_kill"));
                        if (_subscribedClients.Any(client => client.ClientName == "AdKatsLRT" && client.SubscriptionEnabled))
                        {
                            ExecuteCommand("procon.protected.plugins.call", "AdKatsLRT", "CallLoadoutCheckOnPlayer", "AdKats", JSON.JsonEncode(new Hashtable{
                                {"caller_identity", "AdKats"},
                                {"response_requested", false},
                                {"player_name", record.target_player.player_name},
                                {"loadoutCheck_reason", "punished"}
                            }));
                        }
                        KillTarget(record);
                    }
                    else if (action == "kick") {
                        record.command_action = GetCommandByKey("player_kick");
                        KickTarget(record);
                    }
                    else if (action == "tban60") {
                        record.command_numeric = 60;
                        record.command_action = GetCommandByKey("player_ban_temp");
                        TempBanTarget(record);
                    }
                    else if (action == "tban120") {
                        record.command_numeric = 120;
                        record.command_action = GetCommandByKey("player_ban_temp");
                        TempBanTarget(record);
                    }
                    else if (action == "tbanday")
                    {
                        record.command_numeric = 1440;
                        record.command_action = GetCommandByKey("player_ban_temp");
                        TempBanTarget(record);
                    }
                    else if (action == "tban2days")
                    {
                        record.command_numeric = 2880;
                        record.command_action = GetCommandByKey("player_ban_temp");
                        TempBanTarget(record);
                    }
                    else if (action == "tban3days")
                    {
                        record.command_numeric = 4320;
                        record.command_action = GetCommandByKey("player_ban_temp");
                        TempBanTarget(record);
                    }
                    else if (action == "tbanweek") {
                        record.command_numeric = 10080;
                        record.command_action = GetCommandByKey("player_ban_temp");
                        TempBanTarget(record);
                    }
                    else if (action == "tban2weeks") {
                        record.command_numeric = 20160;
                        record.command_action = GetCommandByKey("player_ban_temp");
                        TempBanTarget(record);
                    }
                    else if (action == "tbanmonth") {
                        record.command_numeric = 43200;
                        record.command_action = GetCommandByKey("player_ban_temp");
                        TempBanTarget(record);
                    }
                    else if (action == "ban") {
                        record.command_action = GetCommandByKey("player_ban_perm");
                        PermaBanTarget(record);
                    }
                    else {
                        record.command_action = GetCommandByKey("player_kill");
                        if (_subscribedClients.Any(client => client.ClientName == "AdKatsLRT" && client.SubscriptionEnabled) && record.target_player.player_reputation < 0)
                        {
                            ExecuteCommand("procon.protected.plugins.call", "AdKatsLRT", "CallLoadoutCheckOnPlayer", "AdKats", JSON.JsonEncode(new Hashtable{
                                {"caller_identity", "AdKats"},
                                {"response_requested", false},
                                {"player_name", record.target_player.player_name},
                                {"loadoutCheck_reason", "punished"}
                            }));
                        }
                        KillTarget(record);
                        record.record_exception = new AdKatsException("Punish options are set incorrectly. '" + action + "' not found. Inform plugin setting manager.");
                        HandleException(record.record_exception);
                    }
                    record.target_player.LastPunishment = record;
                }
                else {
                    //Exception found, just kill the player
                    record.command_action = GetCommandByKey("player_kill");
                    KillTarget(record);
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for Punish record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting PunishTarget", 6);
        }

        public void ForgiveTarget(AdKatsRecord record) {
            DebugWrite("Entering forgiveTarget", 6);
            try
            {
                record.record_action_executed = true;
                //If the record has any exceptions, skip everything
                if (record.record_exception == null) {
                    Int32 points = FetchPoints(record.target_player, false);
                    PlayerSayMessage(record.target_player.player_name, "Forgiven 1 infraction point. You now have " + points + " point(s) against you.");
                    SendMessageToSource(record, "Forgive Logged for " + record.GetTargetNames() + ". They now have " + points + " infraction points.");
                    record.target_player.LastForgive = record;
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for Forgive record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting forgiveTarget", 6);
        }

        public void BalanceDisperseTarget(AdKatsRecord record) {
            DebugWrite("Entering DisperseTarget", 6);
            try {
                record.record_action_executed = true;
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        INSERT INTO
	                        `adkats_specialplayers`
                        (
	                        `player_group`,
	                        `player_id`,
                            `player_server`,
                            `player_identifier`,
                            `player_effective`,
                            `player_expiration`
                        )
                        VALUES
                        (
	                        'blacklist_dispersion',
	                        @player_id,
                            @player_server,
                            @player_identifier,
                            UTC_TIMESTAMP(),
                            DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)
                        )";
                        if (record.target_player.player_id <= 0) {
                            ConsoleError("Player ID invalid when dispersing. Unable to complete.");
                            SendMessageToSource(record, "Player ID invalid when dispersing. Unable to complete.");
                            FinalizeRecord(record);
                            return;
                        }
                        command.Parameters.AddWithValue("@player_id", record.target_player.player_id);
                        command.Parameters.AddWithValue("@player_server", _serverInfo.ServerID);
                        command.Parameters.AddWithValue("@player_identifier", record.target_player.player_name);

                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (rowsAffected > 0) {
                            SendMessageToSource(record, "Player " + record.GetTargetNames() + " added to even dispersion for this server.");
                            DebugWrite("Player " + record.GetTargetNames() + " added to even dispersion for this server.", 3);
                            FetchAllAccess(true);
                        }
                        else {
                            ConsoleError("Unable to add player to even dispersion. Error uploading.");
                        }
                    }
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for Disperse record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting DisperseTarget", 6);
        }

        public void BalanceWhitelistTarget(AdKatsRecord record) {
            DebugWrite("Entering BalanceWhitelistTarget", 6);
            try {
                record.record_action_executed = true;
                List<AdKatsSpecialPlayer> matchingPlayers = GetMatchingASPlayersOfGroup("whitelist_multibalancer", record.target_player);
                if (matchingPlayers.Count > 0) {
                    SendMessageToSource(record, matchingPlayers.Count + " matching player(s) already under autobalance whitelist for this server.");
                    return;
                }
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        INSERT INTO
	                        `adkats_specialplayers`
                        (
	                        `player_group`,
	                        `player_id`,
                            `player_server`,
                            `player_identifier`,
                            `player_effective`,
                            `player_expiration`
                        )
                        VALUES
                        (
	                        'whitelist_multibalancer',
	                        @player_id,
                            @player_server,
	                        @player_name,
                            UTC_TIMESTAMP(),
                            DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)
                        )";
                        command.Parameters.AddWithValue("@player_id", record.target_player.player_id);
                        command.Parameters.AddWithValue("@player_server", _serverInfo.ServerID);
                        command.Parameters.AddWithValue("@player_name", record.target_player.player_name);

                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (rowsAffected > 0) {
                            SendMessageToSource(record, "Player " + record.GetTargetNames() + " added to autobalance whitelist for this server.");
                            DebugWrite("Player " + record.GetTargetNames() + " added to autobalance whitelist for this server.", 3);
                            FetchAllAccess(true);
                        }
                        else {
                            ConsoleError("Unable to add player to autobalance whitelist. Error uploading.");
                        }
                    }
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for Balance Whitelist record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting BalanceWhitelistTarget", 6);
        }

        public void ReservedSlotTarget(AdKatsRecord record) {
            DebugWrite("Entering ReservedSlotTarget", 6);
            try {
                record.record_action_executed = true;
                List<AdKatsSpecialPlayer> matchingPlayers = GetMatchingASPlayersOfGroup("slot_reserved", record.target_player);
                if (matchingPlayers.Count > 0) {
                    SendMessageToSource(record, matchingPlayers.Count + " matching player(s) already in reserved slot list for this server.");
                    return;
                }
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        INSERT INTO
	                        `adkats_specialplayers`
                        (
	                        `player_group`,
	                        `player_id`,
                            `player_server`,
                            `player_identifier`,
                            `player_effective`,
                            `player_expiration`
                        )
                        VALUES
                        (
	                        'slot_reserved',
	                        @player_id,
                            @player_server,
	                        @player_name,
                            UTC_TIMESTAMP(),
                            DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)
                        )";
                        command.Parameters.AddWithValue("@player_id", record.target_player.player_id);
                        command.Parameters.AddWithValue("@player_server", _serverInfo.ServerID);
                        command.Parameters.AddWithValue("@player_name", record.target_player.player_name);

                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (rowsAffected > 0) {
                            SendMessageToSource(record, "Player " + record.GetTargetNames() + " added to reserved slot for this server.");
                            DebugWrite("Player " + record.GetTargetNames() + " added to reserved slot for this server.", 3);
                            FetchAllAccess(true);
                        }
                        else {
                            ConsoleError("Unable to add player to reserved slot. Error uploading.");
                        }
                    }
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for Reserved Slot record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting ReservedSlotTarget", 6);
        }

        public void SpectatorSlotTarget(AdKatsRecord record)
        {
            DebugWrite("Entering SpectatorSlotTarget", 6);
            try
            {
                record.record_action_executed = true;
                List<AdKatsSpecialPlayer> matchingPlayers = GetMatchingASPlayersOfGroup("slot_spectator", record.target_player);
                if (matchingPlayers.Count > 0)
                {
                    SendMessageToSource(record, matchingPlayers.Count + " matching player(s) already in spectator slot list for this server.");
                    return;
                }
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = @"
                        INSERT INTO
	                        `adkats_specialplayers`
                        (
	                        `player_group`,
	                        `player_id`,
                            `player_server`,
                            `player_identifier`,
                            `player_effective`,
                            `player_expiration`
                        )
                        VALUES
                        (
	                        'slot_spectator',
	                        @player_id,
                            @player_server,
	                        @player_name,
                            UTC_TIMESTAMP(),
                            DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)
                        )";
                        command.Parameters.AddWithValue("@player_id", record.target_player.player_id);
                        command.Parameters.AddWithValue("@player_server", _serverInfo.ServerID);
                        command.Parameters.AddWithValue("@player_name", record.target_player.player_name);

                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (rowsAffected > 0)
                        {
                            SendMessageToSource(record, "Player " + record.GetTargetNames() + " added to spectator slot for this server.");
                            DebugWrite("Player " + record.GetTargetNames() + " added to spectator slot for this server.", 3);
                            FetchAllAccess(true);
                        }
                        else
                        {
                            ConsoleError("Unable to add player to spectator slot. Error uploading.");
                        }
                    }
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Spectator Slot record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SpectatorSlotTarget", 6);
        }
        public void HackerCheckerWhitelistTarget(AdKatsRecord record)
        {
            DebugWrite("Entering HackerCheckerWhitelistTarget", 6);
            try
            {
                //Case for multiple targets
                if (record.target_player == null) {
                    SendMessageToSource(record, "HackerCheckerWhitelistTarget not available for multiple targets.");
                    ConsoleError("HackerCheckerWhitelistTarget not available for multiple targets.");
                    FinalizeRecord(record);
                    return;
                }
                record.record_action_executed = true;
                List<AdKatsSpecialPlayer> matchingPlayers = GetMatchingASPlayersOfGroup("whitelist_hackerchecker", record.target_player);
                if (matchingPlayers.Count > 0)
                {
                    SendMessageToSource(record, matchingPlayers.Count + " matching player(s) already in hacker checker whitelist.");
                    return;
                }
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = @"
                        INSERT INTO
	                        `adkats_specialplayers`
                        (
	                        `player_group`,
	                        `player_id`,
	                        `player_identifier`,
	                        `player_effective`,
	                        `player_expiration`
                        )
                        VALUES
                        (
	                        'whitelist_hackerchecker',
	                        @player_id,
	                        @player_name,
	                        UTC_TIMESTAMP(),
	                        DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)
                        )";
                        command.Parameters.AddWithValue("@player_id", record.target_player.player_id);
                        command.Parameters.AddWithValue("@player_name", record.target_player.player_name);

                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (rowsAffected > 0)
                        {
                            SendMessageToSource(record, "Player " + record.GetTargetNames() + " added to hacker checker whitelist for all servers.");
                            DebugWrite("Player " + record.GetTargetNames() + " added to hacker checker whitelist for all servers.", 3);
                            FetchAllAccess(true);
                        }
                        else
                        {
                            ConsoleError("Unable to add player to Hacker-Checker whitelist. Error uploading.");
                        }
                    }
                }
                //Unban the player
                UnBanTarget(record);
                //Fetch the special player cache
                FetchAllAccess(true);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Hacker-Checker Whitelist record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting HackerCheckerWhitelistTarget", 6);
        }
        
        public void PingWhitelistTarget(AdKatsRecord record)
        {
            DebugWrite("Entering PingWhitelistTarget", 6);
            try
            {
                //Case for multiple targets
                if (record.target_player == null) {
                    SendMessageToSource(record, "PingWhitelistTarget not available for multiple targets.");
                    ConsoleError("PingWhitelistTarget not available for multiple targets.");
                    FinalizeRecord(record);
                    return;
                }
                record.record_action_executed = true;
                List<AdKatsSpecialPlayer> matchingPlayers = GetMatchingASPlayersOfGroup("whitelist_ping", record.target_player);
                if (matchingPlayers.Count > 0)
                {
                    SendMessageToSource(record, matchingPlayers.Count + " matching player(s) already in the ping whitelist.");
                    return;
                }
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = @"
                        INSERT INTO
	                        `adkats_specialplayers`
                        (
	                        `player_group`,
	                        `player_id`,
	                        `player_identifier`,
	                        `player_effective`,
	                        `player_expiration`
                        )
                        VALUES
                        (
	                        'whitelist_ping',
	                        @player_id,
	                        @player_name,
	                        UTC_TIMESTAMP(),
	                        DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)
                        )";
                        command.Parameters.AddWithValue("@player_id", record.target_player.player_id);
                        command.Parameters.AddWithValue("@player_name", record.target_player.player_name);

                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (rowsAffected > 0)
                        {
                            SendMessageToSource(record, "Player " + record.GetTargetNames() + " added to ping whitelist for all servers.");
                            DebugWrite("Player " + record.GetTargetNames() + " added to ping whitelist for all servers.", 3);
                            FetchAllAccess(true);
                        }
                        else
                        {
                            ConsoleError("Unable to add player to ping whitelist. Error uploading.");
                        }
                    }
                }
                //Fetch the special player cache
                FetchAllAccess(true);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Ping Whitelist record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting PingWhitelistTarget", 6);
        }

        public void AAWhitelistTarget(AdKatsRecord record)
        {
            DebugWrite("Entering AAWhitelistTarget", 6);
            try
            {
                //Case for multiple targets
                if (record.target_player == null)
                {
                    SendMessageToSource(record, "AAWhitelistTarget not available for multiple targets.");
                    ConsoleError("AAWhitelistTarget not available for multiple targets.");
                    FinalizeRecord(record);
                    return;
                }
                record.record_action_executed = true;
                List<AdKatsSpecialPlayer> matchingPlayers = GetMatchingASPlayersOfGroup("whitelist_adminassistant", record.target_player);
                if (matchingPlayers.Count > 0)
                {
                    SendMessageToSource(record, matchingPlayers.Count + " matching player(s) already in the Admin Assistant whitelist.");
                    return;
                }
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = @"
                        INSERT INTO
	                        `adkats_specialplayers`
                        (
	                        `player_group`,
	                        `player_id`,
	                        `player_identifier`,
	                        `player_effective`,
	                        `player_expiration`
                        )
                        VALUES
                        (
	                        'whitelist_adminassistant',
	                        @player_id,
	                        @player_name,
	                        UTC_TIMESTAMP(),
	                        DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)
                        )";
                        command.Parameters.AddWithValue("@player_id", record.target_player.player_id);
                        command.Parameters.AddWithValue("@player_name", record.target_player.player_name);

                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (rowsAffected > 0)
                        {
                            SendMessageToSource(record, "Player " + record.GetTargetNames() + " added to Admin Assistant whitelist for all servers.");
                            DebugWrite("Player " + record.GetTargetNames() + " added to Admin Assistant whitelist for all servers.", 3);
                            FetchAllAccess(true);
                        }
                        else
                        {
                            ConsoleError("Unable to add player to Admin Assistant whitelist. Error uploading.");
                        }
                    }
                }
                //Fetch the special player cache
                FetchAllAccess(true);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Admin Assistant Whitelist record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting AAWhitelistTarget", 6);
        }

        public void SpamBotWhitelistTarget(AdKatsRecord record)
        {
            DebugWrite("Entering SpamBotWhitelistTarget", 6);
            try
            {
                //Case for multiple targets
                if (record.target_player == null)
                {
                    SendMessageToSource(record, "SpamBotWhitelistTarget not available for multiple targets.");
                    ConsoleError("SpamBotWhitelistTarget not available for multiple targets.");
                    FinalizeRecord(record);
                    return;
                }
                record.record_action_executed = true;
                List<AdKatsSpecialPlayer> matchingPlayers = GetMatchingASPlayersOfGroup("whitelist_spambot", record.target_player);
                if (matchingPlayers.Count > 0)
                {
                    SendMessageToSource(record, matchingPlayers.Count + " matching player(s) already in the SpamBot whitelist.");
                    return;
                }
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = @"
                        INSERT INTO
	                        `adkats_specialplayers`
                        (
	                        `player_group`,
	                        `player_id`,
	                        `player_identifier`,
	                        `player_effective`,
	                        `player_expiration`
                        )
                        VALUES
                        (
	                        'whitelist_spambot',
	                        @player_id,
	                        @player_name,
	                        UTC_TIMESTAMP(),
	                        DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)
                        )";
                        command.Parameters.AddWithValue("@player_id", record.target_player.player_id);
                        command.Parameters.AddWithValue("@player_name", record.target_player.player_name);

                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (rowsAffected > 0)
                        {
                            SendMessageToSource(record, "Player " + record.GetTargetNames() + " added to SpamBot whitelist for all servers.");
                            DebugWrite("Player " + record.GetTargetNames() + " added to SpamBot whitelist for all servers.", 3);
                            FetchAllAccess(true);
                        }
                        else
                        {
                            ConsoleError("Unable to add player to SpamBot whitelist. Error uploading.");
                        }
                    }
                }
                //Fetch the special player cache
                FetchAllAccess(true);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for SpamBot Whitelist record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SpamBotWhitelistTarget", 6);
        }

        public void MuteTarget(AdKatsRecord record) {
            DebugWrite("Entering muteTarget", 6);
            try
            {
                record.record_action_executed = true;
                if (!HasAccess(record.target_player, GetCommandByKey("player_mute"))) {
                    if (!_RoundMutedPlayers.ContainsKey(record.target_player.player_name)) {
                        _RoundMutedPlayers.Add(record.target_player.player_name, 0);
                        PlayerSayMessage(record.target_player.player_name, _MutedPlayerMuteMessage);
                        SendMessageToSource(record, record.GetTargetNames() + " has been muted for this round.");
                    }
                    else {
                        SendMessageToSource(record, record.GetTargetNames() + " already muted for this round.");
                    }
                }
                else {
                    SendMessageToSource(record, "You can't mute an admin.");
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for Mute record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting muteTarget", 6);
        }

        public void JoinTarget(AdKatsRecord record)
        {
            DebugWrite("Entering joinTarget", 6);
            try
            {
                record.record_action_executed = true;
                //Get source player
                AdKatsPlayer sourcePlayer = null;
                if (_PlayerDictionary.TryGetValue(record.source_name, out sourcePlayer))
                {
                    //If the source has access to move players, then the squad will be unlocked for their entry
                    if (HasAccess(record.source_player, GetCommandByKey("player_move")))
                    {
                        //Unlock target squad
                        SendMessageToSource(record, "Unlocking target squad if needed, please wait.");
                        ExecuteCommand("procon.protected.send", "squad.private", record.target_player.frostbitePlayerInfo.TeamID + "", record.target_player.frostbitePlayerInfo.SquadID + "", "false");
                        //If anything longer is needed...tisk tisk
                        _threadMasterWaitHandle.WaitOne(500);
                    }
                    //Check for player access to change teams
                    if (record.target_player.frostbitePlayerInfo.TeamID != sourcePlayer.frostbitePlayerInfo.TeamID && !HasAccess(record.source_player, GetCommandByKey("self_teamswap")))
                    {
                        SendMessageToSource(record, "Target player is not on your team, you need @" + GetCommandByKey("self_teamswap").command_text + "/TeamSwap access to join them.");
                    }
                    else
                    {
                        //Move to specific squad
                        DebugWrite("MULTIBalancer Unswitcher Disabled", 3);
                        ExecuteCommand("procon.protected.plugins.call", "MULTIbalancer", "UpdatePluginData", "AdKats", "bool", "DisableUnswitcher", "True");
                        _MULTIBalancerUnswitcherDisabled = true;
                        ExecuteCommand("procon.protected.send", "admin.movePlayer", record.source_name, record.target_player.frostbitePlayerInfo.TeamID + "", record.target_player.frostbitePlayerInfo.SquadID + "", "true");
                        _LastPlayerMoveIssued = UtcDbTime();
                        SendMessageToSource(record, "Attempting to join " + record.GetTargetNames());
                    }
                }
                else
                {
                    SendMessageToSource(record, "Unable to find you in the player list, please try again.");
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Join record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting joinTarget", 6);
        }

        public void PullTarget(AdKatsRecord record)
        {
            DebugWrite("Entering PullTarget", 6);
            try
            {
                record.record_action_executed = true;
                //Unlock squad
                SendMessageToSource(record, "Unlocking source squad for player entry.");
                ExecuteCommand("procon.protected.send", "squad.private", record.source_player.frostbitePlayerInfo.TeamID + "", record.source_player.frostbitePlayerInfo.SquadID + "", "false");
                _threadMasterWaitHandle.WaitOne(500);
                //Move to specific squad
                DebugWrite("MULTIBalancer Unswitcher Disabled", 3);
                ExecuteCommand("procon.protected.plugins.call", "MULTIbalancer", "UpdatePluginData", "AdKats", "bool", "DisableUnswitcher", "True");
                _MULTIBalancerUnswitcherDisabled = true;
                ExecuteCommand("procon.protected.send", "admin.movePlayer", record.target_name, record.source_player.frostbitePlayerInfo.TeamID + "", record.source_player.frostbitePlayerInfo.SquadID + "", "true");
                _LastPlayerMoveIssued = UtcDbTime();
                SendMessageToSource(record, "Attempting to pull " + record.GetTargetNames());
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Join record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting PullTarget", 6);
        }

        public void ReportTarget(AdKatsRecord record) {
            DebugWrite("Entering reportTarget", 6);
            try {
                var random = new Random();
                Int32 reportID = record.command_numeric;
                if (record.command_numeric == 0) {
                    do {
                        reportID = random.Next(100, 999);
                    } while (_RoundReports.ContainsKey(reportID + ""));
                    record.command_numeric = reportID;
                    _RoundReports.Add(reportID + "", record);
                }
                record.record_action_executed = true;
                if (_subscribedClients.Any(client => client.ClientName == "AdKatsLRT" && client.SubscriptionEnabled) && record.target_player.player_reputation < 0)
                {
                    ConsoleWarn("Running loadout case for report record " + reportID);
                    if (!record.isLoadoutChecked)
                    {
                        if (!_LoadoutConfirmDictionary.ContainsKey(record.target_player.player_name))
                        {
                            lock (_LoadoutConfirmDictionary)
                            {
                                _LoadoutConfirmDictionary.Add(record.target_player.player_name, record);
                            }
                            ConsoleWarn("Report record " + reportID + " waiting for loadout confirmation.");
                            ExecuteCommand("procon.protected.plugins.call", "AdKatsLRT", "CallLoadoutCheckOnPlayer", "AdKats", JSON.JsonEncode(new Hashtable{
                                {"caller_identity", "AdKats"},
                                {"response_requested", false},
                                {"player_name", record.target_player.player_name},
                                {"loadoutCheck_reason", "reported"}
                            }));
                        }
                        return;
                    }
                    if (!record.targetLoadoutValid && !FetchOnlineAdminSoldiers().Any())
                    {
                        SendMessageToSource(record, "Your report [" + reportID + "] has been acted on. Thank you.");
                        OnlineAdminSayMessage("Report " + reportID + " is being acted on by Loadout Enforcer.");
                        record.command_action = GetCommandByKey("player_report_confirm");
                        UpdateRecord(record);
                        return;
                    }
                }
                AttemptReportAutoAction(record, reportID + "");
                String sourceAAIdentifier = (record.source_player != null && record.source_player.player_aa) ? ("(AA)") : ("");
                String targetAAIdentifier = (record.target_player != null && record.target_player.player_aa) ? ("(AA)") : ("");
                String slotID = (record.target_player != null) ? (record.target_player.player_slot) : (null);
                if (!String.IsNullOrEmpty(slotID)) {
                    ExecuteCommand("procon.protected.send", "punkBuster.pb_sv_command", "pb_sv_getss " + slotID);
                }
                String sourcePlayerInfo = "";
                if (record.source_player != null && record.source_player.frostbitePlayerInfo != null) {
                    if (record.source_player.player_online) {
                        sourcePlayerInfo = " (" + Math.Round(record.source_player.player_reputation, 1) + ")(" + GetPlayerTeamKey(record.source_player) + "/" +
                                    (_PlayerDictionary.Values.Where(aPlayer => aPlayer.frostbitePlayerInfo.TeamID == record.source_player.frostbitePlayerInfo.TeamID).OrderBy(aPlayer => aPlayer.frostbitePlayerInfo.Score).Reverse().ToList().IndexOf(record.target_player) + 1) + ")";
                    }
                    else
                    {
                        sourcePlayerInfo = " (OFFLINE)";
                    }
                }
                String targetPlayerInfo = "";
                if (record.target_player != null && record.target_player.frostbitePlayerInfo != null)
                {
                    if (record.target_player.player_online)
                    {
                        targetPlayerInfo = " (" + Math.Round(record.target_player.player_reputation, 1) + ")(" + GetPlayerTeamKey(record.target_player) + "/" +
                                    (_PlayerDictionary.Values.Where(aPlayer => aPlayer.frostbitePlayerInfo.TeamID == record.target_player.frostbitePlayerInfo.TeamID).OrderBy(aPlayer => aPlayer.frostbitePlayerInfo.Score).Reverse().ToList().IndexOf(record.target_player) + 1) + ")";
                    }
                    else
                    {
                        targetPlayerInfo = " (OFFLINE)";
                    }
                }
                OnlineAdminSayMessage("R[" + reportID + "] Source: " + sourceAAIdentifier + record.GetSourceName() + sourcePlayerInfo);
                OnlineAdminSayMessage("R[" + reportID + "] Target: " + targetAAIdentifier + record.GetTargetNames() + targetPlayerInfo);
                OnlineAdminSayMessage("R[" + reportID + "] Reason: " + record.record_message);
                if (_isTestingAuthorized && record.target_player != null && (record.target_player.player_reputation > _reputationThresholdGood || PlayerIsAdmin(record.target_player)))
                {
                    //Set Contested
                    record.isContested = true;
                    //Inform All Parties
                    SendMessageToSource(record, record.GetTargetNames() + "'s reputation has automatically contested your report against them.");
                    PlayerTellMessage(record.target_player.player_name, "Your reputation has automatically contested " + record.GetSourceName() + "'s report against you.");
                    OnlineAdminSayMessage(record.GetTargetNames() + "'s reputation has automatically contested report [" + record.command_numeric + "]");
                }
                else if (_InformReportedPlayers) {
                    String mesLow = record.record_message.ToLower();
                    if (!_PlayerInformExclusionStrings.Any(exc => mesLow.Contains(exc.ToLower())))
                    {
                        PlayerTellMessage(record.target_name, record.GetSourceName() + " reported you for " + record.record_message, true, 6);
                    }
                }
                if (_UseEmail) {
                    if (_emailReportsOnlyWhenAdminless && FetchOnlineAdminSoldiers().Any()) 
                    {
                        DebugWrite("Email cancelled, admins online.", 3);
                    }
                    else
                    {
                        DebugWrite("Preparing to send report email.", 3);
                        _EmailHandler.SendReport(record);
                    }
                }
                if (record.source_player != null && 
                    record.source_name != record.target_name &&
                    record.source_player.player_type == PlayerType.Spectator)
                {
                    //Custom record to boost rep for reporting from spectator mode
                    var repRecord = new AdKatsRecord
                    {
                        record_source = AdKatsRecord.Sources.InternalAutomated,
                        server_id = _serverInfo.ServerID,
                        command_type = GetCommandByKey("player_repboost"),
                        command_numeric = 0,
                        target_name = record.source_player.player_name,
                        target_player = record.source_player,
                        source_name = "RepManager",
                        record_message = "Player reported from Spectator Mode"
                    };
                    UploadRecord(repRecord);
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for Report record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting reportTarget", 6);
        }

        public void CallAdminOnTarget(AdKatsRecord record) {
            DebugWrite("Entering callAdminOnTarget", 6);
            try
            {
                var random = new Random();
                Int32 reportID = record.command_numeric;
                if (record.command_numeric == 0)
                {
                    do
                    {
                        reportID = random.Next(100, 999);
                    } while (_RoundReports.ContainsKey(reportID + ""));
                    record.command_numeric = reportID;
                    _RoundReports.Add(reportID + "", record);
                }
                record.record_action_executed = true;
                if (_subscribedClients.Any(client => client.ClientName == "AdKatsLRT" && client.SubscriptionEnabled) && record.target_player.player_reputation < 0)
                {
                    ConsoleWarn("Running loadout case for report record " + reportID);
                    if (!record.isLoadoutChecked)
                    {
                        if (!_LoadoutConfirmDictionary.ContainsKey(record.target_player.player_name))
                        {
                            lock (_LoadoutConfirmDictionary)
                            {
                                _LoadoutConfirmDictionary.Add(record.target_player.player_name, record);
                            }
                            ConsoleWarn("Report record " + reportID + " waiting for loadout confirmation.");
                            ExecuteCommand("procon.protected.plugins.call", "AdKatsLRT", "CallLoadoutCheckOnPlayer", "AdKats", JSON.JsonEncode(new Hashtable{
                                {"caller_identity", "AdKats"},
                                {"response_requested", false},
                                {"player_name", record.target_player.player_name},
                                {"loadoutCheck_reason", "reported"}
                            }));
                        }
                        return;
                    }
                    if (!record.targetLoadoutValid && !FetchOnlineAdminSoldiers().Any())
                    {
                        OnlineAdminSayMessage("Report " + reportID + " is being acted on by loadout enforcer.");
                        record.command_action = GetCommandByKey("player_report_confirm");
                        UpdateRecord(record);
                        return;
                    }
                }
                AttemptReportAutoAction(record, reportID + "");
                String sourceAAIdentifier = (record.source_player != null && record.source_player.player_aa) ? ("(AA)") : ("");
                String targetAAIdentifier = (record.target_player != null && record.target_player.player_aa) ? ("(AA)") : ("");
                String slotID = (record.target_player != null) ? (record.target_player.player_slot) : (null);
                if (!String.IsNullOrEmpty(slotID)) {
                    ExecuteCommand("procon.protected.send", "punkBuster.pb_sv_command", "pb_sv_getss " + slotID);
                }
                String sourcePlayerInfo = "";
                if (record.source_player != null && record.source_player.frostbitePlayerInfo != null)
                {
                    if (record.source_player.player_online)
                    {
                        sourcePlayerInfo = " (" + Math.Round(record.source_player.player_reputation, 1) + ")(" + GetPlayerTeamKey(record.source_player) + "/" +
                                    (_PlayerDictionary.Values.Where(aPlayer => aPlayer.frostbitePlayerInfo.TeamID == record.source_player.frostbitePlayerInfo.TeamID).OrderBy(aPlayer => aPlayer.frostbitePlayerInfo.Score).Reverse().ToList().IndexOf(record.source_player) + 1) + ")";
                    }
                    else
                    {
                        sourcePlayerInfo = " (OFFLINE)";
                    }
                }
                String targetPlayerInfo = "";
                if (record.target_player != null && record.target_player.frostbitePlayerInfo != null)
                {
                    if (record.target_player.player_online)
                    {
                        targetPlayerInfo = " (" + Math.Round(record.target_player.player_reputation, 1) + ")(" + GetPlayerTeamKey(record.target_player) + "/" +
                                    (_PlayerDictionary.Values.Where(aPlayer => aPlayer.frostbitePlayerInfo.TeamID == record.target_player.frostbitePlayerInfo.TeamID).OrderBy(aPlayer => aPlayer.frostbitePlayerInfo.Score).Reverse().ToList().IndexOf(record.target_player) + 1) + ")";
                    }
                    else
                    {
                        targetPlayerInfo = " (OFFLINE)";
                    }
                }
                OnlineAdminSayMessage("A[" + reportID + "] Source: " + sourceAAIdentifier + record.GetSourceName() + sourcePlayerInfo);
                OnlineAdminSayMessage("A[" + reportID + "] Target: " + targetAAIdentifier + record.GetTargetNames() + targetPlayerInfo);
                OnlineAdminSayMessage("A[" + reportID + "] Reason: " + record.record_message);
                if (_InformReportedPlayers)
                {
                    String mesLow = record.record_message.ToLower();
                    if (!_PlayerInformExclusionStrings.Any(exc => mesLow.Contains(exc.ToLower())))
                    {
                        PlayerTellMessage(record.target_name, record.GetSourceName() + " reported you for " + record.record_message, true, 6);
                    }
                }
                if (_UseEmail)
                {
                    if (_emailReportsOnlyWhenAdminless && FetchOnlineAdminSoldiers().Any())
                    {
                        DebugWrite("Email cancelled, admins online.", 3);
                    }
                    else
                    {
                        DebugWrite("Preparing to send report email.", 3);
                        _EmailHandler.SendReport(record);
                    }
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for CallAdmin record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting callAdminOnTarget", 6);
        }

        public void AttemptReportAutoAction(AdKatsRecord record, String reportID) {
            Boolean sourceAA = record.source_player != null && record.source_player.player_aa;
            Int32 onlineAdminCount = FetchOnlineAdminSoldiers().Count;
            String messageLower = record.record_message.ToLower();
            Boolean canAutoHandle = 
                _UseAAReportAutoHandler && 
                sourceAA && 
                _AutoReportHandleStrings.Any() && 
                !String.IsNullOrEmpty(_AutoReportHandleStrings[0]) && 
                _AutoReportHandleStrings.Any(messageLower.Contains) && 
                !record.target_player.player_aa &&
                !PlayerIsAdmin(record.target_player);
            Boolean adminsOnline = onlineAdminCount > 0;
            String reportMessage = "";
            if (!_isTestingAuthorized || !sourceAA || !adminsOnline) {
                reportMessage = "REPORT [" + reportID + "] sent on " + record.GetTargetNames() + " for " + record.record_message;
            }
            else {
                reportMessage = "REPORT [" + reportID + "] on " + record.GetTargetNames() + " sent to " + onlineAdminCount + " in-game admin" + ((onlineAdminCount > 1) ? ("s") : ("")) + ". " + ((canAutoHandle) ? ("Admins have 45 seconds before auto-handling.") : (""));
            }
            SendMessageToSource(record, reportMessage);
            if (!canAutoHandle) {
                //ConsoleWarn("canceling auto-handler.");
                return;
            }
            var reportAutoHandler = new Thread(new ThreadStart(delegate {
                //ConsoleWarn("Starting report auto-handler thread.");
                try {
                    Thread.CurrentThread.Name = "reportautohandler";
                    //If admins are online, act after 45 seconds. If they are not, act after 5 seconds.
                    _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds((adminsOnline) ? (45.0) : (5.0)));
                    //Get the reported record
                    AdKatsRecord reportedRecord;
                    if (_RoundReports.TryGetValue(reportID, out reportedRecord) && _useExperimentalTools) {
                        if (CanPunish(reportedRecord, 90) || !adminsOnline) {
                            //Remove it from the reports for this round
                            _RoundReports.Remove(reportID);
                            //Update it in the database
                            reportedRecord.command_action = GetCommandByKey("player_report_confirm");
                            UpdateRecord(reportedRecord);
                            //Get target information
                            var aRecord = new AdKatsRecord {
                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                server_id = _serverInfo.ServerID,
                                command_type = GetCommandByKey("player_punish"),
                                command_numeric = 0,
                                target_name = reportedRecord.target_player.player_name,
                                target_player = reportedRecord.target_player,
                                source_name = "ProconAdmin",
                                record_message = reportedRecord.record_message
                            };
                            //Inform the reporter that they helped the admins
                            SendMessageToSource(reportedRecord, "Your report [" + reportedRecord.command_numeric + "] has been acted on. Thank you.");
                            //Queue for processing
                            QueueRecordForProcessing(aRecord);
                        }
                        else {
                            SendMessageToSource(reportedRecord, "Reported player has already been acted on.");
                        }
                    }
                }
                catch (Exception) {
                    HandleException(new AdKatsException("Error while auto-handling report."));
                }
                DebugWrite("Exiting a report auto-handler.", 5);
            }));

            //Start the thread
            StartAndLogThread(reportAutoHandler);
        }

        public void RestartLevel(AdKatsRecord record) {
            DebugWrite("Entering restartLevel", 6);
            try
            {
                record.record_action_executed = true;
                ExecuteCommand("procon.protected.send", "mapList.restartRound");
                SendMessageToSource(record, "Round Restarted.");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for RestartLevel record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting restartLevel", 6);
        }

        public void NextLevel(AdKatsRecord record) {
            DebugWrite("Entering nextLevel", 6);
            try
            {
                record.record_action_executed = true;
                ExecuteCommand("procon.protected.send", "mapList.runNextRound");
                SendMessageToSource(record, "Next round has been run.");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for NextLevel record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting nextLevel", 6);
        }

        public void EndLevel(AdKatsRecord record) {
            DebugWrite("Entering EndLevel", 6);
            try
            {
                record.record_action_executed = true;
                ExecuteCommand("procon.protected.send", "mapList.endRound", record.command_numeric + "");
                SendMessageToSource(record, "Ended round with " + record.GetTargetNames() + " as winner.");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for EndLevel record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting EndLevel", 6);
        }

        public void NukeTarget(AdKatsRecord record)
        {
            DebugWrite("Entering NukeTarget", 6);
            try
            {
                record.record_action_executed = true;
                lock (_PlayerDictionary)
                {
                    if (record.source_name == "RoundManager")
                    {
                        AdminTellMessage(record.record_message);
                    }
                    foreach (AdKatsPlayer player in _PlayerDictionary.Values.Where(player => (player.frostbitePlayerInfo.TeamID == record.command_numeric) || (record.target_name == "Everyone")))
                    {
                        ExecuteCommand("procon.protected.send", "admin.killPlayer", player.player_name);
                        if (record.source_name != "RoundManager")
                        {
                            PlayerSayMessage(record.source_name, "Admin Nuke Issued On " + record.GetTargetNames());
                        }
                    }
                }
                SendMessageToSource(record, "You NUKED " + record.GetTargetNames() + " for " + record.record_message + ".");
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for NukeServer record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting NukeTarget", 6);
        }

        public void CountdownTarget(AdKatsRecord record)
        {
            DebugWrite("Entering CountdownTarget", 6);
            try
            {
                record.record_action_executed = true;
                if (record.command_numeric < 1 || record.command_numeric > 30)
                {
                    SendMessageToSource(record, "Invalid duration, must be 1-30. Unable to act.");
                    FinalizeRecord(record);
                    return;
                }
                if (String.IsNullOrEmpty(record.record_message))
                {
                    SendMessageToSource(record, "Invalid countdown message, unable to act.");
                    FinalizeRecord(record);
                    return;
                }
                List<AdKatsPlayer> targetedPlayers = new List<AdKatsPlayer>();
                lock (_PlayerDictionary)
                {
                    switch (record.target_name)
                    {
                        case "Squad":
                            if (record.source_player == null ||
                                !record.source_player.player_online ||
                                !_PlayerDictionary.ContainsKey(record.source_player.player_name) ||
                                record.source_player.player_type == PlayerType.Spectator)
                            {
                                SendMessageToSource(record, "Source must be an online player to use squad option. Unable to act.");
                                FinalizeRecord(record);
                                return;
                            }
                            targetedPlayers.AddRange(_PlayerDictionary.Values.Where(aPlayer =>
                                aPlayer.frostbitePlayerInfo.TeamID == record.source_player.frostbitePlayerInfo.TeamID &&
                                aPlayer.frostbitePlayerInfo.SquadID == record.source_player.frostbitePlayerInfo.SquadID).ToList());
                            break;
                        case "Team":
                            if (record.source_player == null ||
                                !record.source_player.player_online ||
                                !_PlayerDictionary.ContainsKey(record.source_player.player_name) ||
                                record.source_player.player_type == PlayerType.Spectator)
                            {
                                SendMessageToSource(record, "Source must be an online player to use team option. Unable to act.");
                                FinalizeRecord(record);
                                return;
                            }
                            targetedPlayers.AddRange(_PlayerDictionary.Values.Where(aPlayer =>
                                aPlayer.frostbitePlayerInfo.TeamID == record.source_player.frostbitePlayerInfo.TeamID).ToList());
                            break;
                        case "All":
                            //All players, so include spectators and commanders
                            break;
                        default:
                            SendMessageToSource(record, "Invalid target, must be Squad, Team, or All. Unable to Act.");
                            FinalizeRecord(record);
                            return;
                    }
                }
                //Start the thread
                StartAndLogThread(new Thread(new ThreadStart(delegate
                {
                    DebugWrite("Starting a countdown printer thread.", 5);
                    try
                    {
                        Thread.CurrentThread.Name = "countdownprinter";
                        for(Int32 countdown = record.command_numeric; countdown > 0; countdown--)
                        {
                            if (!_pluginEnabled) {
                                LogThreadExit();
                                return;
                            }
                            if (record.target_name == "All") {
                                AdminTellMessage(record.record_message + " in " + countdown + "...");
                            }
                            else {
                                foreach (AdKatsPlayer aPlayer in targetedPlayers) {
                                    PlayerTellMessage(aPlayer.player_name, record.record_message + " in " + countdown + "...");
                                }
                            }
                            _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(1));
                        }
                        if (record.target_name == "All")
                        {
                            AdminTellMessage(record.record_message + " NOW!");
                        }
                        else
                        {
                            foreach (AdKatsPlayer aPlayer in targetedPlayers)
                            {
                                PlayerTellMessage(aPlayer.player_name, record.record_message + " NOW!");
                            }
                        }
                    }
                    catch (Exception)
                    {
                        HandleException(new AdKatsException("Error while printing server countdown"));
                    }
                    DebugWrite("Exiting a countdown printer.", 5);
                    LogThreadExit();
                })));
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for ServerCountdown record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting CountdownTarget", 6);
        }

        public void SwapNukeServer(AdKatsRecord record) {
            DebugWrite("Entering SwapNukeServer", 6);
            try
            {
                record.record_action_executed = true;
                lock (_PlayerDictionary) {
                    foreach (AdKatsPlayer player in _PlayerDictionary.Values.Where(aPlayer => aPlayer.player_type == PlayerType.Player)) {
                        QueuePlayerForForceMove(player.frostbitePlayerInfo);
                    }
                }
                SendMessageToSource(record, "You SwapNuked the server.");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for SwapNuke record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SwapNukeServer", 6);
        }

        public void KickAllPlayers(AdKatsRecord record) {
            DebugWrite("Entering kickAllPlayers", 6);
            try
            {
                record.record_action_executed = true;
                lock (_PlayerDictionary) {
                    foreach (AdKatsPlayer player in _PlayerDictionary.Values.Where(player => player.player_role.role_key == "guest_default")) {
                        _threadMasterWaitHandle.WaitOne(50);
                        ExecuteCommand("procon.protected.send", "admin.kickPlayer", player.player_name, "(" + record.source_name + ") " + record.record_message);
                    }
                }
                AdminSayMessage("All guest players have been kicked.");
                SendMessageToSource(record, "You KICKED EVERYONE for '" + record.record_message + "'");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for KickAll record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting kickAllPlayers", 6);
        }

        public void AdminSay(AdKatsRecord record) {
            DebugWrite("Entering adminSay", 6);
            try
            {
                record.record_action_executed = true;
                AdminSayMessage(record.record_message);
                if (record.record_source != AdKatsRecord.Sources.InGame && record.record_source != AdKatsRecord.Sources.ServerCommand) {
                    SendMessageToSource(record, "Server has been told '" + record.record_message + "' by SAY");
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for AdminSay record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting adminSay", 6);
        }

        public void PlayerSay(AdKatsRecord record) {
            DebugWrite("Entering playerSay", 6);
            try
            {
                record.record_action_executed = true;
                PlayerSayMessage(record.target_player.player_name, record.record_message);
                SendMessageToSource(record, record.GetTargetNames() + " has been told '" + record.record_message + "' by SAY");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for playerSay record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting playerSay", 6);
        }

        public void PMSendTarget(AdKatsRecord record)
        {
            DebugWrite("Entering PMSendTarget", 6);
            try
            {
                record.record_action_executed = true;

                AdKatsPlayer sender = record.source_player;
                AdKatsPlayer partner = record.target_player;
                Boolean adminInformedChange = false;

                //Check sender conditions
                if (sender.conversationPartner == null) {
                    //No conversation partner exists. Inform of the new one.
                    if (PlayerIsAdmin(sender) && !PlayerIsAdmin(partner) && !adminInformedChange)
                    {
                        OnlineAdminSayMessage("Admin " + sender.GetVerboseName() + " is now in a private conversation with " + partner.GetVerboseName());
                        adminInformedChange = true;
                    }
                    else {
                        PlayerSayMessage(sender.player_name, "You are now in a private conversation with " + partner.GetVerboseName() + ". Use /" + GetCommandByKey("player_pm_reply").command_text + " msg to reply.");
                    }
                }
                else
                {
                    //Conversation partner exists. Cancel that conversation.
                    AdKatsPlayer oldPartner = sender.conversationPartner;

                    if (oldPartner.player_guid != partner.player_guid) {
                        if (PlayerIsAdmin(sender) && !PlayerIsAdmin(partner) && !adminInformedChange)
                        {
                            OnlineAdminSayMessage("Admin " + sender.GetVerboseName() + " is now in a private conversation with " + partner.GetVerboseName());
                            adminInformedChange = true;
                        }
                        else {
                            PlayerSayMessage(sender.player_name, "Private conversation partner changed from " + oldPartner.GetVerboseName() + " to " + partner.GetVerboseName());
                        }
                    }
                    else
                    {
                        PlayerSayMessage(sender.player_name, "You are already in a conversation with " + oldPartner.GetVerboseName() + ". Use /" + GetCommandByKey("player_pm_reply").command_text + " msg to reply.");
                        return;
                    }

                    if (PlayerIsExternal(sender.conversationPartner))
                    {
                        QueueRecordForProcessing(new AdKatsRecord {
                            record_source = AdKatsRecord.Sources.InternalAutomated,
                            server_id = oldPartner.player_server.ServerID,
                            record_orchestrate = true,
                            command_type = GetCommandByKey("player_pm_cancel"),
                            command_numeric = 0,
                            target_name = oldPartner.player_name,
                            target_player = oldPartner,
                            source_name = sender.player_name,
                            source_player = sender,
                            record_message = sender.GetVerboseName() + " has left the private conversation."
                        });
                    }
                    else
                    {
                        PlayerSayMessage(oldPartner.player_name, sender.GetVerboseName() + " has left the private conversation.");
                        oldPartner.conversationPartner = null;
                    }
                }
                //Assign local conversation partner
                sender.conversationPartner = partner;

                //Check for external case on new conversation partner
                if (PlayerIsExternal(partner)) {
                    //Player is external, have that instance handle the needed actions
                    QueueRecordForProcessing(new AdKatsRecord {
                        record_source = AdKatsRecord.Sources.InternalAutomated,
                        server_id = partner.player_server.ServerID,
                        record_orchestrate = true,
                        command_type = GetCommandByKey("player_pm_start"),
                        command_numeric = 0,
                        target_name = partner.player_name,
                        target_player = partner,
                        source_name = sender.player_name,
                        source_player = sender,
                        record_message = record.record_message
                    });
                }
                else {
                    //Player is local, inform them of the conversation start/change.
                    if (partner.conversationPartner == null)
                    {
                        //No conversation partner exists. Inform of the new one.
                        if (PlayerIsAdmin(partner) && !PlayerIsAdmin(sender) && !adminInformedChange)
                        {
                            OnlineAdminSayMessage("Admin " + sender.GetVerboseName() + " is now in a private conversation with " + partner.GetVerboseName());
                            adminInformedChange = true;
                        }
                        else
                        {
                            PlayerSayMessage(partner.player_name, "You are now in a private conversation with " + sender.GetVerboseName() + ". Use /" + GetCommandByKey("player_pm_reply").command_text + " msg to reply.");
                        }
                        partner.conversationPartner = sender;
                    }
                    else
                    {
                        //Conversation partner exists. Cancel that conversation. Inform all parties.
                        AdKatsPlayer oldPartner = partner.conversationPartner;

                        if (oldPartner.player_guid != sender.player_guid)
                        {
                            //Inform partner of change
                            PlayerSayMessage(partner.player_name, "Private conversation partner changed from " + oldPartner.GetVerboseName() + " to " + sender.GetVerboseName());

                            //Cancel oldPartner conversation
                            if (PlayerIsExternal(oldPartner))
                            {
                                QueueRecordForProcessing(new AdKatsRecord
                                {
                                    record_source = AdKatsRecord.Sources.InternalAutomated,
                                    server_id = oldPartner.player_server.ServerID,
                                    record_orchestrate = true,
                                    command_type = GetCommandByKey("player_pm_cancel"),
                                    command_numeric = 0,
                                    target_name = oldPartner.player_name,
                                    target_player = oldPartner,
                                    source_name = sender.player_name,
                                    source_player = sender,
                                    record_message = partner.GetVerboseName() + " has left the private conversation."
                                });
                            }
                            else
                            {
                                PlayerSayMessage(oldPartner.player_name, partner.GetVerboseName() + " has left the private conversation.");
                                oldPartner.conversationPartner = null;
                            }
                        }
                        else
                        {
                            ConsoleError("Code 14211: Inform ColColonCleaner");
                            return;
                        }
                    }
                    partner.conversationPartner = sender;
                }

                //Post the first message to the sender
                PlayerSayMessage(sender.player_name, "(MSG)(" + sender.player_name + "): " + record.record_message);
                //Post the first message to the partner
                if (!PlayerIsExternal(partner))
                {
                    PlayerSayMessage(partner.player_name, "(MSG)(" + sender.player_name + "): " + record.record_message);
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Private Message record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting PMSendTarget", 6);
        }

        public void PMReplyTarget(AdKatsRecord record)
        {
            DebugWrite("Entering PMReplyTarget", 6);
            try
            {
                record.record_action_executed = true;
                AdKatsPlayer sender = record.source_player;
                AdKatsPlayer partner = record.target_player;
                if (PlayerIsExternal(partner))
                {
                    QueueRecordForProcessing(new AdKatsRecord
                    {
                        record_source = AdKatsRecord.Sources.InternalAutomated,
                        server_id = partner.player_server.ServerID,
                        record_orchestrate = true,
                        command_type = GetCommandByKey("player_pm_transmit"),
                        command_numeric = 0,
                        target_name = partner.player_name,
                        target_player = partner,
                        source_name = sender.player_name,
                        source_player = sender,
                        record_message = record.record_message
                    });
                }
                else
                {
                    PlayerSayMessage(partner.player_name, "(MSG)(" + sender.player_name + "): " + record.record_message);
                }
                PlayerSayMessage(sender.player_name, "(MSG)(" + sender.player_name + "): " + record.record_message);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Private Message Reply record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting PMReplyTarget", 6);
        }

        public void PMStartTarget(AdKatsRecord record)
        {
            DebugWrite("Entering PMStartTarget", 6);
            try {
                record.record_action_executed = true;

                AdKatsPlayer sender = record.source_player;
                AdKatsPlayer partner = record.target_player;
                Boolean adminInformedChange = false;

                //Sender may not be in this server
                sender = FetchMatchingExternalOnlinePlayer(sender.player_name);

                if (sender == null) {
                    return;
                }

                //Inform partner of the conversation start/change.
                if (partner.conversationPartner == null)
                {
                    //No conversation partner exists. Inform of the new one.
                    if (PlayerIsAdmin(partner) && !PlayerIsAdmin(sender) && !adminInformedChange)
                    {
                        OnlineAdminSayMessage("Admin " + sender.GetVerboseName() + " is now in a private conversation with " + partner.GetVerboseName());
                        adminInformedChange = true;
                    }
                    else
                    {
                        PlayerSayMessage(partner.player_name, "You are now in a private conversation with " + sender.GetVerboseName() + ". Use /" + GetCommandByKey("player_pm_reply").command_text + " msg to reply.");
                    }
                    partner.conversationPartner = sender;
                }
                else
                {
                    //Conversation partner exists. Cancel that conversation. Inform all parties.
                    AdKatsPlayer oldPartner = partner.conversationPartner;

                    if (oldPartner.player_guid != sender.player_guid)
                    {
                        //Inform partner of change
                        PlayerSayMessage(partner.player_name, "Private conversation partner changed from " + oldPartner.GetVerboseName() + " to " + sender.GetVerboseName());

                        //Cancel oldPartner conversation
                        if (PlayerIsExternal(oldPartner))
                        {
                            QueueRecordForProcessing(new AdKatsRecord
                            {
                                record_source = AdKatsRecord.Sources.InternalAutomated,
                                server_id = oldPartner.player_server.ServerID,
                                record_orchestrate = true,
                                command_type = GetCommandByKey("player_pm_cancel"),
                                command_numeric = 0,
                                target_name = oldPartner.player_name,
                                target_player = oldPartner,
                                source_name = sender.player_name,
                                source_player = sender,
                                record_message = partner.GetVerboseName() + " has left the private conversation."
                            });
                        }
                        else
                        {
                            PlayerSayMessage(oldPartner.player_name, partner.GetVerboseName() + " has left the private conversation.");
                            oldPartner.conversationPartner = null;
                        }
                    }
                    else
                    {
                        ConsoleError("Code 14368: Inform ColColonCleaner");
                        return;
                    }
                }
                partner.conversationPartner = sender;

                PlayerSayMessage(partner.player_name, "(MSG)(" + sender.player_name + "): " + record.record_message);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Private Message Start record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting PMStartTarget", 6);
        }

        public void PMCancelTarget(AdKatsRecord record)
        {
            DebugWrite("Entering PMCancelTarget", 6);
            try
            {
                record.record_action_executed = true;

                AdKatsPlayer sender = record.source_player;
                AdKatsPlayer partner = record.target_player;

                if (partner.conversationPartner != null)
                {
                    PlayerSayMessage(partner.player_name, record.record_message);
                    partner.conversationPartner = null;
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Private Message Cancel record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting PMCancelTarget", 6);
        }

        public void PMTransmitTarget(AdKatsRecord record)
        {
            DebugWrite("Entering PMTransmitTarget", 6);
            try
            {
                record.record_action_executed = true;

                AdKatsPlayer sender = record.source_player;
                AdKatsPlayer partner = record.target_player;
                Boolean adminInformedChange = false;

                //Sender may not be in this server
                sender = FetchMatchingExternalOnlinePlayer(sender.player_name);

                if (sender == null)
                {
                    return;
                }

                if (partner.conversationPartner == null || partner.conversationPartner.player_guid != sender.player_guid) {
                    //Cancel oldPartner conversation
                    if (PlayerIsExternal(sender)) {
                        QueueRecordForProcessing(new AdKatsRecord {
                            record_source = AdKatsRecord.Sources.InternalAutomated,
                            server_id = sender.player_server.ServerID,
                            record_orchestrate = true,
                            command_type = GetCommandByKey("player_pm_cancel"),
                            command_numeric = 0,
                            target_name = sender.player_name,
                            target_player = sender,
                            source_name = partner.player_name,
                            source_player = partner,
                            record_message = partner.GetVerboseName() + " is not in a private conversation with you."
                        });
                    }
                    else {
                        PlayerSayMessage(partner.player_name, partner.GetVerboseName() + " is not in a private conversation with you.");
                        sender.conversationPartner = null;
                    }
                }
                else
                {
                    PlayerSayMessage(partner.player_name, "(MSG)(" + sender.player_name + "): " + record.record_message);
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Private Message Transmit record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting PMTransmitTarget", 6);
        }

        public void PMOnlineAdmins(AdKatsRecord record)
        {
            DebugWrite("Entering PMAdmin", 6);
            try
            {
                record.record_action_executed = true;
                OnlineAdminSayMessage("(MSG)(" + record.source_name + "): " + record.record_message);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for Private Message Admin record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting PMAdmin", 6);
        }

        public void AdminYell(AdKatsRecord record) {
            DebugWrite("Entering adminYell", 6);
            try
            {
                record.record_action_executed = true;
                AdminYellMessage(record.record_message);
                if (record.record_source != AdKatsRecord.Sources.InGame && record.record_source != AdKatsRecord.Sources.ServerCommand)
                {
                    SendMessageToSource(record, "Server has been told '" + record.record_message + "' by YELL");
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for AdminYell record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting adminYell", 6);
        }

        public void PlayerYell(AdKatsRecord record) {
            DebugWrite("Entering playerYell", 6);
            try
            {
                record.record_action_executed = true;
                PlayerYellMessage(record.target_player.player_name, record.record_message);
                SendMessageToSource(record, record.GetTargetNames() + " has been told '" + record.record_message + "' by YELL");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for playerYell record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting playerYell", 6);
        }

        public void AdminTell(AdKatsRecord record) {
            DebugWrite("Entering adminTell", 6);
            try
            {
                record.record_action_executed = true;
                AdminTellMessage(record.record_message);
                if (record.record_source != AdKatsRecord.Sources.InGame && record.record_source != AdKatsRecord.Sources.ServerCommand)
                {
                    SendMessageToSource(record, "Server has been told '" + record.record_message + "' by TELL");
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for AdminYell record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting adminTell", 6);
        }

        public void PlayerTell(AdKatsRecord record) {
            DebugWrite("Entering playerTell", 6);
            try
            {
                record.record_action_executed = true;
                PlayerTellMessage(record.target_player.player_name, record.record_message);
                SendMessageToSource(record, record.GetTargetNames() + " has been told '" + record.record_message + "' by TELL");
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while taking action for playerTell record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting playerTell", 6);
        }

        public void SendPopulationSuccess(AdKatsRecord record)
        {
            DebugWrite("Entering SendPopulationSuccess", 6);
            try
            {
                record.record_action_executed = true;
                if (_isTestingAuthorized)
                {
                    PlayerTellMessage(record.target_player.player_name, "Thank you for helping populate the server!");
                }
                else
                {
                    PlayerSayMessage(record.target_player.player_name, "Thank you for helping populate the server!");
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while taking action for population success record.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SendPopulationSuccess", 6);
        }

        public void SendServerRules(AdKatsRecord record)
        {
            DebugWrite("Entering sendServerRules", 6);
            try
            {
                record.record_action_executed = true;
                //If server has rules
                if (_ServerRulesList.Length > 0)
                {
                    //If requesting rules on yourself as an admin, rules should be sent to the whole server.
                    Boolean sourceIsAdmin = ((record.source_player != null && PlayerIsAdmin(record.source_player) || record.source_player == null));
                    Boolean allPlayers = (sourceIsAdmin) &&
                                         (record.target_player == null || record.target_name == record.source_name);
                    if (record.source_name != record.target_name) {
                        if (!sourceIsAdmin)
                        {
                            SendMessageToSource(record, "Telling server rules to " + record.GetTargetNames());
                        }
                        OnlineAdminSayMessage(((sourceIsAdmin) ? ("Admin ") : ("")) + record.GetSourceName() + " told server rules to " + record.GetTargetNames() + ".");
                    }
                    else
                    {
                        OnlineAdminSayMessage(((sourceIsAdmin) ? ("Admin ") : ("")) + record.GetSourceName() + " requested server rules.");
                    }

                    var rulePrinter = new Thread(new ThreadStart(delegate
                    {
                        DebugWrite("Starting a rule printer thread.", 5);
                        try
                        {
                            Thread.CurrentThread.Name = "ruleprinter";
                            //Wait the rule delay duration
                            _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(_ServerRulesDelay));
                            Int32 ruleIndex = 0;
                            IEnumerable<string> validRules = _ServerRulesList.Where(rule => !String.IsNullOrEmpty(rule));
                            foreach (string rule in validRules)
                            {
                                String currentPrefix = (_ServerRulesNumbers) ? ("(" + (++ruleIndex) + "/" + validRules.Count() + ") ") : ("");
                                if (allPlayers) {
                                    AdminSayMessage(currentPrefix + GetPreMessage(rule, false));
                                }
                                else
                                {
                                    if (record.target_player != null)
                                    {
                                        if (_ServerRulesYell)
                                        {
                                            PlayerTellMessage(record.target_player.player_name, currentPrefix + GetPreMessage(rule, false));
                                        }
                                        else
                                        {
                                            PlayerSayMessage(record.target_player.player_name, currentPrefix + GetPreMessage(rule, false));
                                        }
                                    }
                                    else
                                    {
                                        SendMessageToSource(record, currentPrefix + GetPreMessage(rule, false));
                                    }
                                }
                                _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(_ServerRulesInterval));
                            }
                        }
                        catch (Exception)
                        {
                            HandleException(new AdKatsException("Error while printing server rules"));
                        }
                        DebugWrite("Exiting a rule printer.", 5);
                        LogThreadExit();
                    }));

                    //Start the thread
                    StartAndLogThread(rulePrinter);
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while sending server rules.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting sendServerRules", 6);
        }

        public void SourceVoteSurrender(AdKatsRecord record)
        {
            DebugWrite("Entering SourceVoteSurrender", 6);
            try
            {
                record.record_action_executed = true;

                //Case for database added records 
                if (!_surrenderVoteEnable)
                {
                    SendMessageToSource(record, "Surrender Vote must be enabled in AdKats settings to use this command.");
                    FinalizeRecord(record);
                    return;
                }
                if (_roundState != RoundState.Playing)
                {
                    SendMessageToSource(record, "Round state must be playing to use surrender. Current: " + _roundState);
                    FinalizeRecord(record);
                    return;
                }
                if (_surrenderVoteSucceeded)
                {
                    SendMessageToSource(record, "Surrender already succeeded.");
                    FinalizeRecord(record);
                    return;
                }
                if (_surrenderVoteList.Contains(record.source_name))
                {
                    SendMessageToSource(record, "You already voted! You can cancel your vote with @" + GetCommandByKey("command_cancel").command_text);
                    FinalizeRecord(record);
                    return;
                }
                var voteEnabled = false;
                AdKatsTeam team1 = _teamDictionary[1];
                AdKatsTeam team2 = _teamDictionary[2];
                AdKatsTeam winningTeam, losingTeam;
                if (team1.TeamTicketCount > team2.TeamTicketCount) {
                    winningTeam = team1;
                    losingTeam = team2;
                }
                else {
                    winningTeam = team2;
                    losingTeam = team1;
                }
                if (!_surrenderVoteActive)
                {
                    Int32 playerCount = _PlayerDictionary.Values.Count(player => player.player_type == PlayerType.Player);
                    if (playerCount < _surrenderVoteMinimumPlayerCount)
                    {
                        SendMessageToSource(record, _surrenderVoteMinimumPlayerCount + " players needed to start Surrender Vote. Current: " + playerCount);
                        FinalizeRecord(record);
                        return;
                    }
                    Int32 ticketGap = Math.Abs(team1.TeamTicketCount - team2.TeamTicketCount);
                    if (ticketGap < _surrenderVoteMinimumTicketGap)
                    {
                        SendMessageToSource(record, _surrenderVoteMinimumTicketGap + " ticket gap needed to start Surrender Vote. Current: " + ticketGap);
                        FinalizeRecord(record);
                        return;
                    }
                    Double ticketRateGap = Math.Abs(team1.TeamTicketDifferenceRate - team2.TeamTicketDifferenceRate);
                    if (_surrenderVoteTicketRateGapEnable && ticketRateGap < _surrenderVoteMinimumTicketRateGap)
                    {
                        SendMessageToSource(record, _surrenderVoteMinimumTicketRateGap + " ticket rate gap needed to start Surrender Vote. Current: " + Math.Round(ticketRateGap, 2));
                        FinalizeRecord(record);
                        return;
                    }

                    _surrenderVoteActive = true;
                    voteEnabled = true;
                    _surrenderVoteStartTime = UtcDbTime();
                    if (_surrenderVoteTimeoutEnable)
                    {
                        var surrenderTimingThread = new Thread(new ThreadStart(delegate
                        {
                            DebugWrite("Starting a surrender timing thread.", 5);
                            try
                            {
                                while (_pluginEnabled &&
                                       (UtcDbTime() - _surrenderVoteStartTime).TotalMinutes < _surrenderVoteTimeoutMinutes &&
                                       !_surrenderVoteSucceeded &&
                                       _surrenderVoteActive)
                                {
                                    _threadMasterWaitHandle.WaitOne(500);
                                }
                                if (!_surrenderVoteSucceeded && _roundState == RoundState.Playing && _pluginEnabled)
                                {
                                    _surrenderVoteActive = false;
                                    _surrenderVoteList.Clear();
                                    AdminTellMessage("Surrender Vote Timed Out. Votes removed.");
                                }
                            }
                            catch (Exception)
                            {
                                HandleException(new AdKatsException("Error while running surrender timing."));
                            }
                            DebugWrite("Exiting a surrender timing thread.", 5);
                            LogThreadExit();
                        }));
                        StartAndLogThread(surrenderTimingThread);
                    }
                }

                //Remove nosurrender vote if any
                _nosurrenderVoteList.Remove(record.source_name);
                //Add the vote
                _surrenderVoteList.Add(record.source_name);
                Int32 requiredVotes = (Int32)((_PlayerDictionary.Count / 2.0) * (_surrenderVoteMinimumPlayerPercentage / 100.0));
                Int32 voteCount = _surrenderVoteList.Count - _nosurrenderVoteList.Count;
                if (voteCount >= requiredVotes) {
                    //Vote succeeded, trigger winning team
                    _surrenderVoteSucceeded = true;
                    if (!_endingRound)
                    {
                        _endingRound = true;
                        var roundEndDelayThread = new Thread(new ThreadStart(delegate
                        {
                            DebugWrite("Starting a round end delay thread.", 5);
                            try
                            {
                                Thread.CurrentThread.Name = "roundenddelay";
                                for (int i = 0; i < 6; i++)
                                {
                                    AdminTellMessage("Surrender Vote Succeeded. " + winningTeam.TeamName + " wins!");
                                    Thread.Sleep(50);
                                }
                                _threadMasterWaitHandle.WaitOne(7000);
                                var repRecord = new AdKatsRecord
                                {
                                    record_source = AdKatsRecord.Sources.InternalAutomated,
                                    server_id = _serverInfo.ServerID,
                                    command_type = GetCommandByKey("round_end"),
                                    command_numeric = winningTeam.TeamID,
                                    target_name = winningTeam.TeamName,
                                    source_name = "RoundManager",
                                    record_message = "Surrender Vote (" + winningTeam.TeamKey + " Win)(" + winningTeam.TeamTicketCount + ":" + losingTeam.TeamTicketCount + ")(" + FormatTimeString(_serverInfo.GetRoundElapsedTime(), 3) + ")"
                                };
                                QueueRecordForProcessing(repRecord);
                            }
                            catch (Exception)
                            {
                                HandleException(new AdKatsException("Error while running round end delay."));
                            }
                            DebugWrite("Exiting a round end delay thread.", 5);
                            LogThreadExit();
                        }));
                        StartAndLogThread(roundEndDelayThread);
                    }
                }
                else
                {
                    SendMessageToSource(record, "You voted for round surrender!");
                    if (voteEnabled) {
                        AdminTellMessage("Surrender Vote started! Use @" + GetCommandByKey("self_surrender").command_text + ", @" + GetCommandByKey("self_votenext").command_text + ", or @" + GetCommandByKey("self_nosurrender").command_text + " to vote.");
                    }
                    else
                    {
                        AdminSayMessage((requiredVotes - voteCount) + " votes needed for surrender/scramble. Use @" + GetCommandByKey("self_surrender").command_text + ", @" + GetCommandByKey("self_votenext").command_text + ", or @" + GetCommandByKey("self_nosurrender").command_text + " to vote.");
                        AdminYellMessage((requiredVotes - voteCount) + " votes needed for surrender/scramble");
                    }
                    OnlineAdminSayMessage(record.GetSourceName() + " voted for round surrender.");
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while voting surrender.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SourceVoteSurrender", 6);
        }

        public void SourceVoteNoSurrender(AdKatsRecord record)
        {
            DebugWrite("Entering SourceVoteNoSurrender", 6);
            try
            {
                record.record_action_executed = true;

                //Case for database added records 
                if (!_surrenderVoteEnable)
                {
                    SendMessageToSource(record, "Surrender Vote must be enabled in AdKats settings to use this command.");
                    FinalizeRecord(record);
                    return;
                }
                if (_roundState != RoundState.Playing)
                {
                    SendMessageToSource(record, "Round state must be playing to vote against surrender. Current: " + _roundState);
                    FinalizeRecord(record);
                    return;
                }
                if (_surrenderVoteSucceeded)
                {
                    SendMessageToSource(record, "Surrender already succeeded.");
                    FinalizeRecord(record);
                    return;
                }
                if (_nosurrenderVoteList.Contains(record.source_name))
                {
                    SendMessageToSource(record, "You already voted against surrender!");
                    FinalizeRecord(record);
                    return;
                }
                if (!_surrenderVoteActive)
                {
                    SendMessageToSource(record, "A surrender vote must be active to vote against it.");
                    FinalizeRecord(record);
                    return;
                }

                //Remove surrender vote if any
                _surrenderVoteList.Remove(record.source_name);
                //Add the vote
                _nosurrenderVoteList.Add(record.source_name);
                Int32 requiredVotes = (Int32)((_PlayerDictionary.Count / 2.0) * (_surrenderVoteMinimumPlayerPercentage / 100.0));
                Int32 voteCount = _surrenderVoteList.Count - _nosurrenderVoteList.Count;
                SendMessageToSource(record, "You voted against round surrender!");
                AdminSayMessage((requiredVotes - voteCount) + " votes needed for surrender/scramble. Use @" + GetCommandByKey("self_surrender").command_text + ", @" + GetCommandByKey("self_votenext").command_text + ", or @" + GetCommandByKey("self_nosurrender").command_text + " to vote.");
                AdminYellMessage((requiredVotes - voteCount) + " votes needed for surrender/scramble");
                OnlineAdminSayMessage(record.GetSourceName() + " voted against round surrender.");
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while voting against surrender.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SourceVoteNoSurrender", 6);
        }

        public void SendServerCommands(AdKatsRecord record)
        {
            DebugWrite("Entering SendServerCommands", 6);
            try
            {
                record.record_action_executed = true;
                var commandPrinter = new Thread(new ThreadStart(delegate
                {
                    DebugWrite("Starting a command printer thread.", 5);
                    try
                    {
                        Thread.CurrentThread.Name = "commandprinter";

                        var fullCommandList = new List<String>();
                        foreach (AdKatsCommand aCommand in _CommandIDDictionary.Values)
                        {
                            if ((record.target_player == null && aCommand.command_active == AdKatsCommand.CommandActive.Active) || HasAccess(record.target_player, aCommand))
                            {
                                fullCommandList.Add("!" + aCommand.command_text);
                            }
                        }
                        if (record.target_player == null || PlayerIsAdmin(record.target_player))
                        {
                            fullCommandList.AddRange(_ExternalAdminCommands);
                        }
                        else
                        {
                            fullCommandList.AddRange(_ExternalPlayerCommands);
                        }
                        List<List<String>> commandSplits =
                        fullCommandList
                        .Select((x, i) => new { Index = i, Value = x })
                        .GroupBy(x => x.Index / 5)
                        .Select(x => x.Select(v => v.Value).ToList())
                        .ToList();
                        
                        foreach (var curCommands in commandSplits) {
                            String curCommandsStr = "";
                            foreach (String cur in curCommands) {
                                curCommandsStr += cur + ", ";
                            }
                            SendMessageToSource(record, curCommandsStr);
                            _threadMasterWaitHandle.WaitOne(TimeSpan.FromSeconds(2));
                        }
                    }
                    catch (Exception)
                    {
                        HandleException(new AdKatsException("Error while printing server commands"));
                    }
                    DebugWrite("Exiting a command printer.", 5);
                    LogThreadExit();
                }));

                //Start the thread
                StartAndLogThread(commandPrinter);

                if (record.source_name != record.target_name)
                {
                    SendMessageToSource(record, "Telling server commands to " + record.GetTargetNames());
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while sending server commands.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SendServerCommands", 6);
        }

        public void SendTargetRep(AdKatsRecord record)
        {
            DebugWrite("Entering SendTargetRep", 6);
            try
            {
                record.record_action_executed = true;
                var isAdmin = PlayerIsAdmin(record.target_player);
                if (record.source_name == record.target_name) {
                    SendMessageToSource(record, "Your server reputation is " + ((!isAdmin) ? (Math.Round(record.target_player.player_reputation, 2) + "") : (record.target_player.player_role.role_name)) + ((record.target_player.player_reputation > _reputationThresholdBad && (!isAdmin)) ? (", thank you for helping the admins!") : ("")));
                }
                else {
                    SendMessageToSource(record, record.GetTargetNames() + "'s server reputation is " + ((!isAdmin) ? (Math.Round(record.target_player.player_reputation, 2) + "") : (record.target_player.player_role.role_name)));
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while sending server rep.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SendTargetRep", 6);
        }
        
        public void SendUptime(AdKatsRecord record) {
            DebugWrite("Entering SendUptime", 6);
            try
            {
                record.record_action_executed = true;
                var uptimePrinter = new Thread(new ThreadStart(delegate {
                    DebugWrite("Starting a uptime printer thread.", 5);
                    try {
                        Thread.CurrentThread.Name = "uptimeprinter";
                        SendMessageToSource(record, "Server: " + FormatTimeString(TimeSpan.FromSeconds(_serverInfo.InfoObject.ServerUptime), 10));
                        _threadMasterWaitHandle.WaitOne(3000);
                        SendMessageToSource(record, "Procon: " + FormatTimeString(UtcDbTime() - _proconStartTime, 10));
                        _threadMasterWaitHandle.WaitOne(3000);
                        SendMessageToSource(record, "AdKats " + PluginVersion + ": " + FormatTimeString(UtcDbTime() - _AdKatsRunningTime, 10));
                        _threadMasterWaitHandle.WaitOne(3000);
                        SendMessageToSource(record, "Last Player List: " + FormatTimeString(UtcDbTime() - _lastSuccessfulPlayerList, 10) + " ago");
                        _threadMasterWaitHandle.WaitOne(3000);
                        SendMessageToSource(record, "Server has been in " + _populationStatus.ToString().ToLower() + " population for " + FormatTimeString(UtcDbTime() - _populationTransitionTime, 3));
                        Double totalPopulationDuration = 
                            _populationDurations[PopulationState.Low].TotalSeconds +
                            _populationDurations[PopulationState.Medium].TotalSeconds +
                            _populationDurations[PopulationState.High].TotalSeconds;
                        if (totalPopulationDuration > 0) {
                            _threadMasterWaitHandle.WaitOne(5000);
                            Int32 lowPopPercentage = (int)Math.Round(_populationDurations[PopulationState.Low].TotalSeconds / totalPopulationDuration * 100);
                            Int32 medPopPercentage = (int)Math.Round(_populationDurations[PopulationState.Medium].TotalSeconds / totalPopulationDuration * 100);
                            Int32 highPopPercentage = (int)Math.Round(_populationDurations[PopulationState.High].TotalSeconds / totalPopulationDuration * 100);
                            SendMessageToSource(record, "Population since AdKats start: " + lowPopPercentage + "% low. " + medPopPercentage + "% medium. " + highPopPercentage + "% high.");
                        }
                    }
                    catch (Exception) {
                        HandleException(new AdKatsException("Error while printing uptime"));
                    }
                    DebugWrite("Exiting a uptime printer.", 5);
                    LogThreadExit();
                }));

                //Start the thread
                StartAndLogThread(uptimePrinter);
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while sending uptime.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SendUptime", 6);
        }

        public void SendRoundReports(AdKatsRecord record)
        {
            DebugWrite("Entering SendRoundReports", 6);
            try
            {
                record.record_action_executed = true;
                List<AdKatsRecord> lastMissedReports = _RoundReports.Values.OrderByDescending(aRecord => aRecord.record_time).Take(6).Reverse().ToList();
                Boolean listed = false;
                foreach (var rRecord in lastMissedReports) {
                    String location;
                    if (rRecord.target_player.player_online)
                    {
                        location = GetPlayerTeamKey(rRecord.target_player) + "/" +
                            (_PlayerDictionary.Values.Where(aPlayer => aPlayer.frostbitePlayerInfo.TeamID == rRecord.target_player.frostbitePlayerInfo.TeamID).OrderBy(aPlayer => aPlayer.frostbitePlayerInfo.Score).Reverse().ToList().IndexOf(rRecord.target_player) + 1);
                    }
                    else
                    {
                        location = "OFFLINE";
                    }
                    SendMessageToSource(record, "(" + rRecord.command_numeric + ")(" + FormatTimeString(UtcDbTime() - rRecord.record_time, 2) + ")(" + rRecord.GetTargetNames() + "/" + location + "):" + rRecord.record_message);
                    Thread.Sleep(30);
                    listed = true;
                }
                if (!listed) {
                    SendMessageToSource(record, "No missed round reports were found.");
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while sending round reports.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SendRoundReports", 6);
        }

        public void RebootPlugin(AdKatsRecord record)
        {
            DebugWrite("Entering RebootPlugin", 6);
            try
            {
                record.record_action_executed = true;
                _pluginRebootOnDisable = true;
                if (record.record_source == AdKatsRecord.Sources.InGame)
                {
                    _pluginRebootOnDisableSource = record.source_name;
                }
                SendMessageToSource(record, "Rebooting AdKats shortly.");
                //Run the reboot delay thread
                StartAndLogThread(new Thread(new ThreadStart(delegate
                {
                    Thread.CurrentThread.Name = "RebootDelay";
                    Thread.Sleep(10000);
                    Disable();
                    LogThreadExit();
                })));
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while rebooting plugin.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting RebootPlugin", 6);
        }

        public void UpdatePlugin(AdKatsRecord record)
        {
            DebugWrite("Entering UpdatePlugin", 6);
            try
            {
                record.record_action_executed = true;
                _pluginUpdateCaller = record;
                CheckForPluginUpdates(true);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while rebooting plugin.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting UpdatePlugin", 6);
        }

        public void ShutdownServer(AdKatsRecord record)
        {
            DebugWrite("Entering ShutdownServer", 6);
            try
            {
                record.record_action_executed = true;
                ExecuteCommand("procon.protected.send", "admin.shutDown");
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while shutting down server.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting ShutdownServer", 6);
        }

        public void SendTargetInfo(AdKatsRecord record)
        {
            DebugWrite("Entering SendTargetInfo", 6);
            try
            {
                record.record_action_executed = true;
                var infoPrinter = new Thread(new ThreadStart(delegate
                {
                    DebugWrite("Starting a player info printer thread.", 5);
                    try
                    {
                        Thread.CurrentThread.Name = "playerinfoprinter";
                        if (record.target_player == null)
                        {
                            ConsoleError("Player null in player info printer.");
                            return;
                        }
                        _threadMasterWaitHandle.WaitOne(500);
                        String playerInfo = record.target_player.GetVerboseName() + ": " + record.target_player.player_id + ", " + record.target_player.player_role.role_name;
                        if (record.target_player != null && record.target_player.frostbitePlayerInfo != null)
                        {
                            if (record.target_player.player_online)
                            {
                                playerInfo += ", " + GetPlayerTeamName(record.target_player) + "/" +
                                    (_PlayerDictionary.Values.Where(aPlayer => aPlayer.frostbitePlayerInfo.TeamID == record.target_player.frostbitePlayerInfo.TeamID).OrderBy(aPlayer => aPlayer.frostbitePlayerInfo.Score).Reverse().ToList().IndexOf(record.target_player) + 1) + "/" +
                                    record.target_player.frostbitePlayerInfo.Score;
                            }
                            else
                            {
                                playerInfo += ", OFFLINE";
                            }
                        }
                        SendMessageToSource(record, playerInfo);
                        _threadMasterWaitHandle.WaitOne(2000);
                        SendMessageToSource(record, "First seen: " + FormatTimeString(UtcDbTime() - record.target_player.player_firstseen, 3) + " ago.");
                        _threadMasterWaitHandle.WaitOne(2000);
                        SendMessageToSource(record, "Time on server: " + FormatTimeString(record.target_player.player_serverplaytime, 3) + " + current session.");
                        _threadMasterWaitHandle.WaitOne(2000);
                        String playerLoc = "Unknown";
                        if (!String.IsNullOrEmpty(record.target_player.player_ip)) {
                            IPAPILocation loc = record.target_player.location;
                            if (loc != null && loc.status == "success") {
                                playerLoc = String.Empty;
                                if (!String.IsNullOrEmpty(loc.city)) {
                                    playerLoc += loc.city + ", ";
                                }
                                if (!String.IsNullOrEmpty(loc.regionName)) {
                                    playerLoc += loc.regionName + ", ";
                                }
                                playerLoc += loc.country;
                                IEnumerable<AdKatsRecord> locRecords = FetchRecentRecords(record.target_player.player_id, GetCommandByKey("player_changeip").command_id, 1000, 50, true, false).Where(aRecord => aRecord.record_message != "No previous IP on record");
                                if (locRecords.Count() > 0) {
                                    playerLoc += " with " + locRecords.Count() + " IP changes.";
                                }
                            }
                        }
                        else {
                            playerLoc = "Player IP not found";
                        }
                        SendMessageToSource(record, "Location: " + playerLoc);
                        _threadMasterWaitHandle.WaitOne(2000);
                        IEnumerable<AdKatsRecord> reportsFrom = _RoundReports.Values.Where(aRecord => aRecord.source_name == record.target_name);
                        IEnumerable<AdKatsRecord> reportsAgainst = _RoundReports.Values.Where(aRecord => aRecord.target_name == record.target_name);
                        String playerReps = "None from or against.";
                        if (reportsAgainst.Any() || reportsFrom.Any())
                        {
                            playerReps = String.Empty;
                            if (reportsAgainst.Any())
                            {
                                playerReps += "[" + reportsAgainst.Count() + " against:";
                                playerReps = reportsAgainst.Aggregate(playerReps, (current, playerRep) => current + (" (" + ((playerRep.isContested) ? ("-CONTESTED- ") : ("")) + playerRep.record_message + ")"));
                                playerReps += "]";
                            }
                            if (reportsFrom.Any())
                            {
                                playerReps += "[" + reportsFrom.Count() + " from:";
                                playerReps = reportsFrom.Aggregate(playerReps, (current, playerRep) => current + (" (" + ((playerRep.isContested) ? ("-CONTESTED- ") : ("")) + playerRep.record_message + ")"));
                                playerReps += "]";
                            }
                        }
                        SendMessageToSource(record, "Reports: " + playerReps);
                        _threadMasterWaitHandle.WaitOne(2000);
                        //Infraction Points
                        String playerInf = "Player in good standing.";
                        Int64 infPoints = FetchPoints(record.target_player, false);
                        if (infPoints > 0)
                        {
                            playerInf = infPoints + " points.";
                        }
                        SendMessageToSource(record, "Infractions: " + playerInf);
                        _threadMasterWaitHandle.WaitOne(2000);
                        //Last Punishment
                        String lastPunishText = "No punishments found.";
                        var punishments = FetchRecentRecords(record.target_player.player_id, GetCommandByKey("player_punish").command_id, 1000, 1, true, false);
                        if (punishments.Any()) {
                            var lastPunish = punishments[0];
                            lastPunishText = FormatTimeString(UtcDbTime() - lastPunish.record_time, 2) + " ago by " + lastPunish.GetSourceName() + ": " + lastPunish.record_message;
                        }
                        SendMessageToSource(record, "Last Punishment: " + lastPunishText);
                        _threadMasterWaitHandle.WaitOne(2000);
                        //Last Forgive
                        String lastForgiveText = "No forgives found.";
                        var forgives = FetchRecentRecords(record.target_player.player_id, GetCommandByKey("player_forgive").command_id, 1000, 1, true, false);
                        if (forgives.Any())
                        {
                            var lastForgive = forgives[0];
                            lastForgiveText = FormatTimeString(UtcDbTime() - lastForgive.record_time, 2) + " ago by " + lastForgive.GetSourceName() + ": " + lastForgive.record_message;
                        }
                        SendMessageToSource(record, "Last Forgive: " + lastForgiveText);
                        _threadMasterWaitHandle.WaitOne(2000);
                        //Rules requests
                        String rulesRequestsText = "Player has never requested rules.";
                        var rulesRequests = FetchRecentRecords(record.target_player.player_id, GetCommandByKey("self_rules").command_id, 1000, 50, true, false);
                        if (rulesRequests.Any(innerRecord => innerRecord.source_player != null && innerRecord.source_player.player_id == record.target_player.player_id))
                        {
                            var lastRulesRequest = rulesRequests[0];
                            rulesRequestsText = FormatTimeString(UtcDbTime() - lastRulesRequest.record_time, 2) + " ago.";
                        }
                        SendMessageToSource(record, "Last Rules Request: " + rulesRequestsText);
                        _threadMasterWaitHandle.WaitOne(2000);
                        //Ping Kicks
                        String pingKicksText = "Player never kicked for ping.";
                        var pingKicks = FetchRecentRecords(record.target_player.player_id, GetCommandByKey("player_kick").command_id, 1000, 50, true, false).Where(innerRecord => innerRecord.source_name == "PingEnforcer");
                        if (pingKicks.Any())
                        {
                            pingKicksText = "Kicked " + pingKicks.Count() + " time(s) for high ping.";
                        }
                        SendMessageToSource(record, "Ping Kicks: " + pingKicksText + " Current Ping [" + ((record.target_player.player_ping_avg > 0) ? (Math.Round(record.target_player.player_ping_avg, 2) + "") : ("Missing")) + "].");
                        _threadMasterWaitHandle.WaitOne(2000);
                        //Reputation
                        SendMessageToSource(record, "Reputation: " + ((!PlayerIsAdmin(record.target_player)) ? (Math.Round(record.target_player.player_reputation, 2) + "") : (record.target_player.player_role.role_name)));
                        _threadMasterWaitHandle.WaitOne(2000);
                        //Previous Names
                        String playerNames = "No previous names.";
                        List<AdKatsRecord> nameRecords = FetchRecentRecords(record.target_player.player_id, GetCommandByKey("player_changename").command_id, 1000, 50, true, false);
                        if (nameRecords.Count > 0)
                        {
                            playerNames = record.target_name;
                            foreach (AdKatsRecord nameRecord in nameRecords)
                            {
                                playerNames += ", " + nameRecord.record_message;
                            }
                        }
                        SendMessageToSource(record, "Previous names: " + playerNames);
                    }
                    catch (Exception)
                    {
                        HandleException(new AdKatsException("Error while printing player info"));
                    }
                    DebugWrite("Exiting a player info printer.", 5);
                    LogThreadExit();
                }));

                //Start the thread
                StartAndLogThread(infoPrinter);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while sending player info.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SendTargetInfo", 6);
        }

        public void SendTargetChat(AdKatsRecord record)
        {
            DebugWrite("Entering SendTargetChat", 6);
            try
            {
                record.record_action_executed = true;
                var chatPrinter = new Thread(new ThreadStart(delegate
                {
                    DebugWrite("Starting a player chat printer thread.", 5);
                    try
                    {
                        Thread.CurrentThread.Name = "playerchatprinter";
                        if (record.target_player != null)
                        {
                            List<KeyValuePair<DateTime, string>> chatList = FetchChat(record.target_player.player_id, record.command_numeric, 30);
                            if (chatList.Any())
                            {
                                int index = 1;
                                foreach (var chatLine in chatList)
                                {
                                    SendMessageToSource(record, "(" + index++ + ") " + chatLine.Value);
                                    _threadMasterWaitHandle.WaitOne(2000);
                                }
                            }
                            else {
                                SendMessageToSource(record, "Target player(s) have no chat to fetch.");
                            }
                        }
                        else if (record.TargetPlayersLocal.Count == 2)
                        {
                            long firstPlayerID = record.TargetPlayersLocal[0].player_id;
                            long secondPlayerID = record.TargetPlayersLocal[1].player_id;
                            List<KeyValuePair<DateTime, KeyValuePair<string, string>>> chatList = FetchConversation(firstPlayerID, secondPlayerID, record.command_numeric, 30);
                            if (chatList.Any())
                            {
                                int index = 1;
                                foreach (var chatLine in chatList)
                                {
                                    SendMessageToSource(record, "(" + index++ + "/" + chatLine.Value.Key + ") " + chatLine.Value.Value);
                                    _threadMasterWaitHandle.WaitOne(2000);
                                }
                            }
                            else
                            {
                                SendMessageToSource(record, "Target player(s) have no chat to fetch.");
                            }
                        }
                        else {
                            ConsoleError("Invalid target conditions when printing chat.");
                            SendMessageToSource(record, "Unable to fetch chat for target players.");
                        }
                    }
                    catch (Exception)
                    {
                        HandleException(new AdKatsException("Error while printing player chat"));
                    }
                    DebugWrite("Exiting a player chat printer.", 5);
                    LogThreadExit();
                }));

                //Start the thread
                StartAndLogThread(chatPrinter);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while sending player chat.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SendTargetChat", 6);
        }

        public void FindTarget(AdKatsRecord record)
        {
            DebugWrite("Entering FindTarget", 6);
            try
            {
                record.record_action_executed = true;
                if (record.target_player == null)
                {
                    ConsoleError("Player null when finding player.");
                    return;
                }
                String playerInfo = record.GetTargetNames() + ": ";
                if (record.target_player.player_online)
                {

                    playerInfo += GetPlayerTeamName(record.target_player) + "/" +
                        (_PlayerDictionary.Values.Where(aPlayer => aPlayer.frostbitePlayerInfo.TeamID == record.target_player.frostbitePlayerInfo.TeamID).OrderBy(aPlayer => aPlayer.frostbitePlayerInfo.Score).Reverse().ToList().IndexOf(record.target_player) + 1) + "/" +
                        record.target_player.frostbitePlayerInfo.Score;
                }
                else
                {
                    playerInfo += "OFFLINE";
                }
                SendMessageToSource(record, playerInfo);
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while sending player info.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting FindTarget", 6);
        }

        public void LockTarget(AdKatsRecord record)
        {
            DebugWrite("Entering LockTarget", 6);
            try
            {
                if (record.target_player == null)
                {
                    ConsoleError("Player null when locking player.");
                    FinalizeRecord(record);
                    return;
                }
                if (String.IsNullOrEmpty(record.source_name) && record.source_player == null)
                {
                    SendMessageToSource(record, "No source provided to lock player. Unable to lock.");
                    FinalizeRecord(record);
                    return;
                }
                //Set the executed bool
                record.record_action_executed = true;
                //Check if already locked
                if (record.target_player.IsLocked())
                {
                    SendMessageToSource(record, record.GetTargetNames() + " is already locked by " + record.target_player.GetLockSource() + " for " + FormatTimeString(record.target_player.GetLockRemaining(), 3) + ".");
                    FinalizeRecord(record);
                    return;
                }
                //Assign the new lock
                TimeSpan duration = TimeSpan.FromMinutes(_playerLockingManualDuration);
                record.target_player.Lock(record.source_name, duration);
                SendMessageToSource(record, record.GetTargetNames() + " is now locked for " + FormatTimeString(duration, 3) + ", or until you unlock them.");
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while locking player.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting LockTarget", 6);
        }

        public void UnlockTarget(AdKatsRecord record)
        {
            DebugWrite("Entering UnlockTarget", 6);
            try
            {
                if (record.target_player == null)
                {
                    ConsoleError("Player null when unlocking player.");
                    return;
                }
                //Set the executed bool
                record.record_action_executed = true;
                //Check if already locked
                if (!record.target_player.IsLocked())
                {
                    SendMessageToSource(record, record.GetTargetNames() + " is not locked.");
                    FinalizeRecord(record);
                    return;
                }
                record.target_player.Unlock();
                SendMessageToSource(record, record.GetTargetNames() + " is now unlocked.");
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while unlocking player.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting UnlockTarget", 6);
        }

        public void MarkTarget(AdKatsRecord record)
        {
            DebugWrite("Entering FindTarget", 6);
            try
            {
                if (record.target_player == null)
                {
                    ConsoleError("Player null when marking player.");
                    return;
                }
                record.record_action_executed = true;
                if (_subscribedClients.Any(client => client.ClientName == "AdKatsLRT" && client.SubscriptionEnabled)) {
                    ExecuteCommand("procon.protected.plugins.call", "AdKatsLRT", "CallLoadoutCheckOnPlayer", "AdKats", JSON.JsonEncode(new Hashtable {
                        {"caller_identity", "AdKats"},
                        {"response_requested", false},
                        {"player_name", record.target_player.player_name},
                        {"loadoutCheck_reason", "marked"}
                    }));
                    SendMessageToSource(record, record.GetTargetNames() + " marked for loadout check.");
                }
                else
                {
                    SendMessageToSource(record, record.GetTargetNames() + " marked for leave notification.");
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while marking player.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting MarkTarget", 6);
        }

        public void ManageAFKPlayers(AdKatsRecord record)
        {
            DebugWrite("Entering ManageAFKPlayers", 6);
            try
            {
                record.record_action_executed = true;
                if(_PlayerDictionary.Count < _AFKTriggerMinimumPlayers)
                {
                    SendMessageToSource(record, "Server contains less than " + _AFKTriggerMinimumPlayers + ", unable to kick AFK players.");
                }
                List<AdKatsPlayer> afkPlayers = _PlayerDictionary.Values.Where(
                    aPlayer =>
                        (UtcDbTime() - aPlayer.lastAction).TotalMinutes > _AFKTriggerDurationMinutes &&
                        aPlayer.player_type != PlayerType.Spectator &&
                        !PlayerIsAdmin(aPlayer)).Take(_PlayerDictionary.Count - _AFKTriggerMinimumPlayers).ToList();
                if (_AFKIgnoreUserList) {
                    IEnumerable<string> userSoldierGuids = FetchAllUserSoldiers().Select(aPlayer => aPlayer.player_guid);
                    afkPlayers = afkPlayers.Where(aPlayer => !userSoldierGuids.Contains(aPlayer.player_guid)).ToList();
                }
                else {
                    afkPlayers = afkPlayers.Where(aPlayer => !_AFKIgnoreRoles.Contains(aPlayer.player_role.role_key)).ToList();
                }
                if (afkPlayers.Any())
                {
                    foreach (AdKatsPlayer aPlayer in afkPlayers) {
                        string afkTime = FormatTimeString(UtcDbTime() - aPlayer.lastAction, 2);
                        DebugWrite("Kicking " + aPlayer.GetVerboseName() + " for being AFK " + afkTime + ".", 3);
                        var kickRecord = new AdKatsRecord
                        {
                            record_source = AdKatsRecord.Sources.InternalAutomated,
                            server_id = _serverInfo.ServerID,
                            command_type = GetCommandByKey("player_kick"),
                            command_numeric = 0,
                            target_name = aPlayer.player_name,
                            target_player = aPlayer,
                            source_name = "AFKManager",
                            record_message = "AFK time exceeded [" + afkTime + "/" + GetPlayerTeamKey(aPlayer) + "]. Please rejoin once you return."
                        };
                        QueueRecordForProcessing(kickRecord);
                    }
                    SendMessageToSource(record, afkPlayers.Count() + " players kicked for being AFK.");
                }
                else {
                    SendMessageToSource(record, "No AFK players found or kickable.");
                }
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Error while managing AFK players.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting ManageAFKPlayers", 6);
        }

        public void SendOnlineAdmins(AdKatsRecord record) {
            DebugWrite("Entering SendOnlineAdmins", 6);
            try
            {
                record.record_action_executed = true;
                var onlineAdminList = FetchOnlineAdminSoldiers();
                String onlineAdmins = "Admins: [" + onlineAdminList.Count + " Online] ";
                onlineAdmins = onlineAdminList.Aggregate(onlineAdmins, (current, aPlayer) => current + (
                    aPlayer.GetVerboseName() + 
                    " (" + 
                    GetPlayerTeamKey(aPlayer) + 
                    "/" + 
                    (_PlayerDictionary.Values.Where(innerPlayer => innerPlayer.frostbitePlayerInfo.TeamID == aPlayer.frostbitePlayerInfo.TeamID).OrderBy(innerPlayer => innerPlayer.frostbitePlayerInfo.Score).Reverse().ToList().IndexOf(aPlayer) + 1) + 
                    "), "));
                //Send online admins
                SendMessageToSource(record, onlineAdmins.Trim().TrimEnd(','));
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while sending online admins.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting SendOnlineAdmins", 6);
        }

        public void LeadCurrentSquad(AdKatsRecord record) {
            DebugWrite("Entering LeadCurrentSquad", 6);
            try
            {
                record.record_action_executed = true;
                ExecuteCommand("procon.protected.send", "squad.leader", record.target_player.frostbitePlayerInfo.TeamID.ToString(), record.target_player.frostbitePlayerInfo.SquadID.ToString(), record.target_player.player_name);
                PlayerSayMessage(record.target_player.player_name, "You are now the leader of your current squad.");
                if (record.source_name != record.target_name) {
                    SendMessageToSource(record, record.GetTargetNames() + " is now the leader of their current squad.");
                }
            }
            catch (Exception e) {
                record.record_exception = new AdKatsException("Error while leading curring squad.", e);
                HandleException(record.record_exception);
                FinalizeRecord(record);
            }
            DebugWrite("Exiting LeadCurrentSquad", 6);
        }

        private void QueueUserForUpload(AdKatsUser user) {
            try {
                DebugWrite("Preparing to queue user for access upload.", 6);
                lock (_UserUploadQueue) {
                    _UserUploadQueue.Enqueue(user);
                    DebugWrite("User queued for access upload", 6);
                    _DbCommunicationWaitHandle.Set();
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queuing user upload.", e));
            }
        }

        private void QueueUserForRemoval(AdKatsUser user) {
            try {
                DebugWrite("Preparing to queue user for access removal", 6);
                lock (_UserRemovalQueue) {
                    _UserRemovalQueue.Enqueue(user);
                    DebugWrite("User queued for access removal", 6);
                    _DbCommunicationWaitHandle.Set();
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queuing access removal.", e));
            }
        }

        private Boolean HasAccess(AdKatsPlayer aPlayer, AdKatsCommand command) {
            try {
                if (aPlayer == null) {
                    ConsoleError("player was null in hasAccess.");
                    return false;
                }
                if (aPlayer.player_role == null) {
                    ConsoleError("player role was null in hasAccess.");
                    return false;
                }
                if (command == null) {
                    ConsoleError("Command was null in hasAccess.");
                    return false;
                }
                lock (aPlayer.player_role) {
                    lock (aPlayer.player_role.RoleAllowedCommands) {
                        if (aPlayer.player_role.RoleAllowedCommands.ContainsKey(command.command_key)) {
                            return true;
                        }
                        if (aPlayer.player_role.ConditionalAllowedCommands.Values.Any(innerCommand => (innerCommand.Value.command_key == command.command_key) && innerCommand.Key(this, aPlayer))) {
                            return true;
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while checking command access on player.", e));
            }
            return false;
        }

        private void DatabaseCommunicationThreadLoop() {
            try {
                DebugWrite("DBCOMM: Starting Database Comm Thread", 1);
                Thread.CurrentThread.Name = "databasecomm";
                Boolean firstRun = true;
                DateTime loopStart;
                var counter = new Stopwatch();
                while (true) {
                    loopStart = UtcDbTime();
                    try {
                        DebugWrite("DBCOMM: Entering Database Comm Thread Loop", 7);
                        if (!_pluginEnabled) {
                            DebugWrite("DBCOMM: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                            break;
                        }
                        //Check if database connection settings have changed
                        if (_dbSettingsChanged) {
                            DebugWrite("DBCOMM: DB Settings have changed, calling test.", 6);
                            if (TestDatabaseConnection()) {
                                DebugWrite("DBCOMM: Database Connection Good. Continuing Thread.", 6);
                            }
                            else {
                                _dbSettingsChanged = true;
                                continue;
                            }
                        }
                        //On first run, pull all roles and commands, update database if needed
                        if (firstRun) {
                            counter.Reset();
                            counter.Start();

                            FetchCommands();
                            FetchRoles();
                            UpdateDatabase37014000();

                            counter.Stop();
                            //ConsoleWrite("DBCOMM: Initial command fetch took " + counter.ElapsedMilliseconds + "ms");
                        }
                        counter.Reset();
                        counter.Start();
                        //FeedStatLoggerSettings();
                        //ConsoleWrite("DBCOMM: FeedStatLoggerSettings took " + counter.ElapsedMilliseconds + "ms");

                        //Update server ID
                        if (_serverInfo.ServerID <= 0) {
                            //Checking for database server info
                            if (FetchDBServerInfo()) {
                                if (_serverInfo.ServerID <= 0) {
                                    //Inform the user
                                    ConsoleError("Database Server info could not be fetched! Make sure XpKiller's Stat Logger is running on this server!");
                                    //Disable the plugin
                                    Disable();
                                    break;
                                }
                                else
                                {
                                    ConsoleSuccess("Database server info fetched. Server ID is " + _serverInfo.ServerID + ".");
                                    //Push all settings for this instance to the database
                                    UploadAllSettings();
                                }
                            }
                            else {
                                //Inform the user
                                ConsoleError("Database Server info could not be fetched! Make sure XpKiller's Stat Logger is running on this server!");
                                //Disable the plugin
                                Disable();
                                break;
                            }
                        }
                        else {
                            DebugWrite("Skipping server ID fetch. Server ID: " + _serverInfo.ServerID, 7);
                        }

                        //Check if settings need sync
                        if (firstRun || _settingImportID != _serverInfo.ServerID || _lastDbSettingFetch.AddSeconds(DbSettingFetchFrequency) < UtcDbTime()) {
                            DebugWrite("Preparing to fetch settings from server " + _serverInfo.ServerID, 6);
                            //Fetch new settings from the database
                            FetchSettings(_settingImportID, _settingImportID != _serverInfo.ServerID);

                            counter.Reset();
                            counter.Start();
                            RunPluginOrchestration();
                            counter.Stop();
                            //ConsoleWrite("DBCOMM: RunPluginOrchestration took " + counter.ElapsedMilliseconds + "ms");
                            //Run any available SQL Updates
                            counter.Reset();
                            counter.Start();
                            RunSQLUpdates();
                            counter.Stop();
                            //ConsoleWrite("DBCOMM: RunSQLUpdates took " + counter.ElapsedMilliseconds + "ms");
                        }

                        counter.Reset();
                        counter.Start();
                        HandleSettingUploads();
                        counter.Stop();
                        //ConsoleWrite("DBCOMM: HandleSettingUploads took " + counter.ElapsedMilliseconds + "ms");

                        counter.Reset();
                        counter.Start();
                        HandleCommandUploads();
                        counter.Stop();
                        //ConsoleWrite("DBCOMM: HandleCommandUploads took " + counter.ElapsedMilliseconds + "ms");

                        counter.Reset();
                        counter.Start();
                        HandleRoleUploads();
                        counter.Stop();
                        //ConsoleWrite("DBCOMM: HandleRoleUploads took " + counter.ElapsedMilliseconds + "ms");

                        counter.Reset();
                        counter.Start();
                        HandleRoleRemovals();
                        counter.Stop();
                        //ConsoleWrite("DBCOMM: HandleRoleRemovals took " + counter.ElapsedMilliseconds + "ms");

                        counter.Reset();
                        counter.Start();
                        HandleStatisticUploads();
                        counter.Stop();
                        //ConsoleWrite("DBCOMM: HandleStatisticUploads took " + counter.ElapsedMilliseconds + "ms");

                        counter.Reset();
                        counter.Start();
                        //Check for new actions from the database at given interval
                        if (_fetchActionsFromDb && (UtcDbTime() > _lastDbActionFetch.AddSeconds(DbActionFetchFrequency))) {
                            RunActionsFromDB();
                        }
                        else {
                            DebugWrite("DBCOMM: Skipping DB action fetch", 7);
                        }
                        counter.Stop();
                        //ConsoleWrite("DBCOMM: RunActionsFromDB took " + counter.ElapsedMilliseconds + "ms");

                        HandleUserChanges();

                        //Start the other threads
                        if (firstRun)
                        {
                            //Set the start time
                            _AdKatsStartTime = UtcDbTime();

                            //Start other threads
                            StartAndLogThread(_PlayerListingThread);
                            StartAndLogThread(_AccessFetchingThread);
                            StartAndLogThread(_KillProcessingThread);
                            StartAndLogThread(_MessageProcessingThread);
                            StartAndLogThread(_CommandParsingThread);
                            StartAndLogThread(_ActionHandlingThread);
                            StartAndLogThread(_TeamSwapThread);
                            StartAndLogThread(_BanEnforcerThread);
                            StartAndLogThread(_HackerCheckerThread);

                            firstRun = false;
                            _threadsReady = true;
                        }

                        counter.Reset();
                        counter.Start();
                        if (_UseBanEnforcer) {
                            HandleActiveBanEnforcer();
                        }
                        else {
                            if (_UseBanEnforcerPreviousState) {
                                RepopulateProconBanList();
                                _UseBanEnforcerPreviousState = false;
                            }
                        }
                        counter.Stop();
                        //ConsoleWrite("DBCOMM: HandleActiveBanEnforcer took " + counter.ElapsedMilliseconds + "ms");

                        if (_UnprocessedRecordQueue.Count > 0) 
                        {
                            counter.Reset();
                            counter.Start();
                            DebugWrite("DBCOMM: Unprocessed Record: " + _UnprocessedRecordQueue.Count + " Current: 0", 4);
                            DebugWrite("DBCOMM: Preparing to lock inbound record queue to retrive new records", 7);
                            Queue<AdKatsRecord> inboundRecords;
                            lock (_UnprocessedRecordQueue) {
                                DebugWrite("DBCOMM: Inbound records found. Grabbing.", 6);
                                //Grab all records in the queue
                                inboundRecords = new Queue<AdKatsRecord>(_UnprocessedRecordQueue.ToArray());
                                //Clear the queue for next run
                                _UnprocessedRecordQueue.Clear();
                            }
                            //Loop through all records in order that they came in
                            while (inboundRecords.Count > 0)
                            {
                                if (!_pluginEnabled)
                                {
                                    break;
                                }
                                DebugWrite("DBCOMM: Unprocessed Record: " + _UnprocessedRecordQueue.Count + " Current: " + inboundRecords.Count, 4);
                                //Pull the next record
                                AdKatsRecord record = inboundRecords.Dequeue();
                                //Process the record message
                                record.record_message = ReplacePlayerInformation(record.record_message, record.target_player);
                                //Upload the record
                                Boolean success = HandleRecordUpload(record);
                                if (record.target_player != null) {
                                    //Assign the record to the user's recent records
                                    record.target_player.TargetedRecords.Add(record);
                                }
                                //Check for action handling needs
                                if (success &&
                                    !record.record_action_executed && 
                                    !record.record_orchestrate) {
                                    //Action is only called after initial upload, not after update
                                    DebugWrite("DBCOMM: Upload success. Attempting to add to action queue.", 6);

                                    //Only queue the record for action handling if it's not an enforced ban
                                    if (record.command_type.command_key != "banenforcer_enforce") {
                                        QueueRecordForActionHandling(record);
                                    }
                                }
                                else {
                                    DebugWrite("DBCOMM: Record does not need action handling by this server.", 6);
                                    //finalize the record
                                    FinalizeRecord(record);
                                }
                            }
                            counter.Stop();
                            //ConsoleWrite("DBCOMM: UnprocessedRecords took " + counter.ElapsedMilliseconds + "ms");
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                        }
                        else {
                            counter.Reset();
                            counter.Start();
                            DebugWrite("DBCOMM: No unprocessed records. Waiting for input", 7);
                            _DbCommunicationWaitHandle.Reset();
                            if ((UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                            _DbCommunicationWaitHandle.WaitOne(TimeSpan.FromSeconds(5));
                            counter.Stop();
                            //ConsoleWrite("DBCOMM: Waiting after complete took " + counter.ElapsedMilliseconds + "ms");
                        }
                    }
                    catch (Exception e) {
                        if (e is ThreadAbortException) {
                            HandleException(new AdKatsException("Database Comm thread aborted. Exiting."));
                            break;
                        }
                        HandleException(new AdKatsException("Error occured in Database Comm thread. Skipping current loop.", e));
                    }
                }
                DebugWrite("DBCOMM: Ending Database Comm Thread", 1);
                LogThreadExit();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error occured in database comm thread.", e));
            }
        }

        private void FeedStatLoggerSettings() {
            DebugWrite("FeedStatLoggerSettings starting!", 6);
            //Every 60 minutes feed stat logger settings
            if (_lastStatLoggerStatusUpdateTime.AddMinutes(60) < UtcDbTime())
            {
                if (_aliveThreads.Values.Any(aThread => aThread.Name == "StatLoggerSettingsFeeder"))
                {
                    if (_isTestingAuthorized)
                        ConsoleError("Attempted to start a stat logger setting feeder thread before a previous one was able to finish.");
                    return;
                }
                var statLoggerFeedingThread = new Thread(new ThreadStart(delegate
                {
                    try
                    {
                        Thread.CurrentThread.Name = "StatLoggerSettingsFeeder";
                        Thread.Sleep(250);
                        DebugWrite("Starting a stat logger setting feeder thread.", 5);
                        _lastStatLoggerStatusUpdateTime = UtcDbTime();
                        if (_isTestingAuthorized)
                        {
                            _FeedStatLoggerSettings = true;
                            _PostStatLoggerChatManually = true;
                        }
                        if (_statLoggerVersion == "BF3")
                        {
                            SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Enable Livescoreboard in DB?", "Yes");
                            if (_FeedStatLoggerSettings)
                            {
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Enable Statslogging?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Enable Weaponstats?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Enable KDR correction?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "MapStats ON?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Session ON?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Save Sessiondata to DB?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Log playerdata only (no playerstats)?", "No");
                                Double slOffset = UtcDbTime().Subtract(DateTime.Now).TotalHours;
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Servertime Offset", slOffset + "");
                            }
                            if (_PostStatLoggerChatManually)
                            {
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Enable Chatlogging?", "No");
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Instant Logging of Chat Messages?", "No");
                            }
                            else if (_FeedStatLoggerSettings)
                            {
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Enable Chatlogging?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Instant Logging of Chat Messages?", "Yes");
                            }
                        }
                        else if (_statLoggerVersion == "UNIVERSAL")
                        {
                            SetExternalPluginSetting("CChatGUIDStatsLogger", "Enable Livescoreboard in DB?", "Yes");
                            if (_FeedStatLoggerSettings)
                            {
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Enable Statslogging?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Enable Weaponstats?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Enable KDR correction?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "MapStats ON?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Session ON?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Save Sessiondata to DB?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Log playerdata only (no playerstats)?", "No");
                                Double slOffset = UtcDbTime().Subtract(DateTime.Now).TotalHours;
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Servertime Offset", slOffset + "");
                            }
                            if (_PostStatLoggerChatManually)
                            {
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Enable Chatlogging?", "No");
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Instant Logging of Chat Messages?", "No");
                            }
                            else if (_FeedStatLoggerSettings)
                            {
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Enable Chatlogging?", "Yes");
                                SetExternalPluginSetting("CChatGUIDStatsLogger", "Instant Logging of Chat Messages?", "Yes");
                            }
                        }
                        else
                        {
                            ConsoleError("Stat logger version is unknown, unable to feed stat logger settings.");
                        }
                        //TODO put back in the future
                        //confirmStatLoggerSetup();
                        DebugWrite("Exiting a stat logger setting feeder thread.", 5);
                    }
                    catch (Exception e)
                    {
                        HandleException(new AdKatsException("Error while feeding stat logger settings."));
                    }
                    LogThreadExit();
                }));
                StartAndLogThread(statLoggerFeedingThread);
            }
            DebugWrite("FeedStatLoggerSettings finished!", 6);
        }

        private void HandleSettingUploads() {
            //Handle Inbound Setting Uploads
            if (_SettingUploadQueue.Count > 0)
            {
                if (_aliveThreads.Values.Any(aThread => aThread.Name == "SettingUploader"))
                {
                    return;
                }
                StartAndLogThread(new Thread(new ThreadStart(delegate
                {
                    Thread.CurrentThread.Name = "SettingUploader";
                    Thread.Sleep(250);
                    try
                    {
                        DebugWrite("DBCOMM: Preparing to lock inbound setting queue to get new settings", 7);
                        Queue<CPluginVariable> inboundSettingUpload;
                        lock (_SettingUploadQueue)
                        {
                            DebugWrite("DBCOMM: Inbound settings found. Grabbing.", 6);
                            //Grab all settings in the queue
                            inboundSettingUpload = new Queue<CPluginVariable>(_SettingUploadQueue.ToArray());
                            //Clear the queue for next run
                            _SettingUploadQueue.Clear();
                        }
                        //Loop through all settings in order that they came in
                        while (inboundSettingUpload.Count > 0)
                        {
                            if (!_pluginEnabled)
                            {
                                break;
                            }
                            CPluginVariable setting = inboundSettingUpload.Dequeue();

                            UploadSetting(setting);
                        }
                    }
                    catch (Exception e) {
                        HandleException(new AdKatsException("Error while uploading settings.", e));
                    }
                    LogThreadExit();
                })));
            }
        }

        private void HandleCommandUploads() {
            //Handle Inbound Command Uploads
            if (_CommandUploadQueue.Count > 0) {
                DebugWrite("DBCOMM: Preparing to lock inbound command queue to get new commands", 7);
                Queue<AdKatsCommand> inboundCommandUpload;
                lock (_CommandUploadQueue) {
                    DebugWrite("DBCOMM: Inbound commands found. Grabbing.", 6);
                    //Grab all commands in the queue
                    inboundCommandUpload = new Queue<AdKatsCommand>(_CommandUploadQueue.ToArray());
                    //Clear the queue for next run
                    _CommandUploadQueue.Clear();
                }
                //Loop through all commands in order that they came in
                while (inboundCommandUpload.Count > 0) {
                    AdKatsCommand command = inboundCommandUpload.Dequeue();

                    UploadCommand(command);
                }
                UpdateSettingPage();
            }
        }

        private void HandleStatisticUploads()
        {
            if (_UnprocessedStatisticQueue.Count > 0)
            {
                DebugWrite("DBCOMM: Unprocessed Statistic: " + _UnprocessedStatisticQueue.Count + " Current: 0", 4);
                DebugWrite("DBCOMM: Preparing to lock inbound statistic queue to retrive new records", 7);
                Queue<AdKatsStatistic> inboundStats;
                lock (_UnprocessedStatisticQueue)
                {
                    DebugWrite("DBCOMM: Inbound statistics found. Grabbing.", 6);
                    //Grab all statistics in the queue
                    inboundStats = new Queue<AdKatsStatistic>(_UnprocessedStatisticQueue.ToArray());
                    //Clear the queue for next run
                    _UnprocessedStatisticQueue.Clear();
                }
                //Loop through all statistics in order that they came in
                while (inboundStats.Count > 0)
                {
                    if (!_pluginEnabled)
                    {
                        break;
                    }
                    DebugWrite("DBCOMM: Unprocessed Statistic: " + _UnprocessedStatisticQueue.Count + " Current: " + inboundStats.Count, 4);
                    //Pull the next statistic
                    AdKatsStatistic aStat = inboundStats.Dequeue();
                    //Upload the statistic
                    UploadStatistic(aStat);
                }
            }
        }

        private void HandleRoleUploads() {
            //Handle Inbound Role Uploads
            if (_RoleUploadQueue.Count > 0) {
                DebugWrite("DBCOMM: Preparing to lock inbound role queue to get new roles", 7);
                Queue<AdKatsRole> inboundRoleUpload;
                lock (_RoleUploadQueue) {
                    DebugWrite("DBCOMM: Inbound roles found. Grabbing.", 6);
                    //Grab all roles in the queue
                    inboundRoleUpload = new Queue<AdKatsRole>(_RoleUploadQueue.ToArray());
                    //Clear the queue for next run
                    _RoleUploadQueue.Clear();
                }
                //Loop through all roles in order that they came in
                while (inboundRoleUpload.Count > 0) {
                    AdKatsRole aRole = inboundRoleUpload.Dequeue();
                    UploadRole(aRole);
                    lock (_RoleIDDictionary) {
                        if (_RoleIDDictionary.ContainsKey(aRole.role_id)) {
                            _RoleIDDictionary[aRole.role_id] = aRole;
                        }
                        else {
                            _RoleIDDictionary.Add(aRole.role_id, aRole);
                        }
                        if (_RoleKeyDictionary.ContainsKey(aRole.role_key)) {
                            _RoleKeyDictionary[aRole.role_key] = aRole;
                        }
                        else {
                            _RoleKeyDictionary.Add(aRole.role_key, aRole);
                        }
                        if (_RoleNameDictionary.ContainsKey(aRole.role_name)) {
                            _RoleNameDictionary[aRole.role_name] = aRole;
                        }
                        else {
                            _RoleNameDictionary.Add(aRole.role_name, aRole);
                        }
                    }
                }
                UpdateSettingPage();
            }
        }

        private void HandleRoleRemovals() {
            //Handle Inbound Role Removal
            if (_RoleRemovalQueue.Count > 0) {
                DebugWrite("DBCOMM: Preparing to lock removal role queue to get new roles", 7);
                Queue<AdKatsRole> inboundRoleRemoval;
                lock (_RoleRemovalQueue) {
                    DebugWrite("DBCOMM: Inbound roles found. Grabbing.", 6);
                    //Grab all roles in the queue
                    inboundRoleRemoval = new Queue<AdKatsRole>(_RoleRemovalQueue.ToArray());
                    //Clear the queue for next run
                    _RoleRemovalQueue.Clear();
                }
                //Loop through all commands in order that they came in
                while (inboundRoleRemoval.Count > 0) {
                    AdKatsRole aRole = inboundRoleRemoval.Dequeue();
                    RemoveRole(aRole);
                    lock (_RoleIDDictionary) {
                        if (_RoleIDDictionary.ContainsKey(aRole.role_id)) {
                            _RoleIDDictionary.Remove(aRole.role_id);
                        }
                        if (_RoleKeyDictionary.ContainsKey(aRole.role_key)) {
                            _RoleKeyDictionary.Remove(aRole.role_key);
                        }
                        if (_RoleNameDictionary.ContainsKey(aRole.role_name)) {
                            _RoleNameDictionary.Remove(aRole.role_name);
                        }
                    }
                }
                UpdateSettingPage();
            }
        }

        private void HandleUserChanges() {
            //Handle access updates
            if (_UserUploadQueue.Count > 0 || _UserRemovalQueue.Count > 0) {
                DebugWrite("DBCOMM: Inbound access changes found. Grabbing.", 6);
                Queue<AdKatsUser> inboundUserUploads;
                lock (_UserUploadQueue) {
                    inboundUserUploads = new Queue<AdKatsUser>(_UserUploadQueue.ToArray());
                    _UserUploadQueue.Clear();
                }
                Queue<AdKatsUser> inboundUserRemoval;
                lock (_UserRemovalQueue) {
                    inboundUserRemoval = new Queue<AdKatsUser>(_UserRemovalQueue.ToArray());
                    _UserRemovalQueue.Clear();
                }
                //Loop through all records in order that they came in
                while (inboundUserUploads.Count > 0) {
                    AdKatsUser user = inboundUserUploads.Dequeue();
                    UploadUser(user);
                }
                //Loop through all records in order that they came in
                while (inboundUserRemoval.Count > 0) {
                    AdKatsUser user = inboundUserRemoval.Dequeue();
                    ConsoleInfo("Removing user " + user.user_name);
                    RemoveUser(user);
                }
                FetchAllAccess(true);
            }
            else if (UtcDbTime() > _lastUserFetch.AddSeconds(DbUserFetchFrequency) || _userCache.Count == 0) {
                FetchAllAccess(true);
            }
            else {
                DebugWrite("DBCOMM: No inbound user changes.", 7);
            }
        }

        private void HandleActiveBanEnforcer() {
            try
            {
                //Call banlist at set interval (20 seconds)
                if (_UseBanEnforcerPreviousState && (UtcDbTime() > _lastBanListCall.AddSeconds(20)))
                {
                    _lastBanListCall = UtcDbTime();
                    DebugWrite("banlist.list called at interval.", 6);
                    ExecuteCommand("procon.protected.send", "banList.list");

                    FetchNameBanCount();
                    FetchGUIDBanCount();
                    FetchIPBanCount();
                }
                if (!_UseBanEnforcerPreviousState || (UtcDbTime() > _lastDbBanFetch.AddSeconds(DbBanFetchFrequency)))
                {
                    //Load all bans on startup
                    if (!_UseBanEnforcerPreviousState)
                    {
                        //Get all bans from procon
                        ConsoleInfo("Preparing to queue procon bans for import. Please wait.");
                        _DbCommunicationWaitHandle.Reset();
                        ExecuteCommand("procon.protected.send", "banList.list");
                        _DbCommunicationWaitHandle.WaitOne(TimeSpan.FromMinutes(5));
                        if (_CBanProcessingQueue.Count > 0)
                        {
                            ConsoleWrite(_CBanProcessingQueue.Count + " procon bans queued for import. Import might take several minutes if you have many bans!");
                        }
                        else
                        {
                            ConsoleWrite("No procon bans to import into Ban Enforcer.");
                        }
                    }
                }
                else
                {
                    DebugWrite("DBCOMM: Skipping DB ban fetch", 7);
                }

                //Handle Inbound Ban Comms
                if (_BanEnforcerProcessingQueue.Count > 0)
                {
                    DebugWrite("DBCOMM: Preparing to lock inbound ban enforcer queue to retrive new bans", 7);
                    Queue<AdKatsBan> inboundBans;
                    lock (_BanEnforcerProcessingQueue)
                    {
                        DebugWrite("DBCOMM: Inbound bans found. Grabbing.", 6);
                        //Grab all messages in the queue
                        inboundBans = new Queue<AdKatsBan>(_BanEnforcerProcessingQueue.ToArray());
                        //Clear the queue for next run
                        _BanEnforcerProcessingQueue.Clear();
                    }
                    Int32 index = 1;
                    //Loop through all bans in order that they came in
                    while (inboundBans.Count > 0)
                    {
                        if (!_pluginEnabled || !_UseBanEnforcer)
                        {
                            ConsoleWarn("Canceling ban import mid-operation.");
                            break;
                        }
                        //Grab the ban
                        AdKatsBan aBan = inboundBans.Dequeue();

                        DebugWrite("DBCOMM: Processing Frostbite Ban: " + index++, 6);

                        //Upload the ban
                        UploadBan(aBan);

                        //Only perform special action when ban is direct
                        //Indirect bans are through the procon banlist, so the player has already been kicked
                        if (aBan.ban_record.source_name != "BanEnforcer")
                        {
                            //Enforce the ban
                            EnforceBan(aBan, false);
                        }
                    }
                }

                //Handle BF3 Ban Manager imports
                if (!_UseBanEnforcerPreviousState)
                {
                    //Import all bans from BF3 Ban Manager
                    ImportBansFromBBM5108();
                }

                //Handle Inbound CBan Uploads
                if (_CBanProcessingQueue.Count > 0)
                {
                    if (!_UseBanEnforcerPreviousState)
                    {
                        ConsoleWarn("Do not disable AdKats or change any settings until upload is complete!");
                    }
                    DebugWrite("DBCOMM: Preparing to lock inbound cBan queue to retrive new cBans", 7);
                    Double totalCBans = 0;
                    Double bansImported = 0;
                    Boolean earlyExit = false;
                    DateTime startTime = UtcDbTime();
                    Queue<CBanInfo> inboundCBans;
                    lock (_CBanProcessingQueue)
                    {
                        DebugWrite("DBCOMM: Inbound cBans found. Grabbing.", 6);
                        //Grab all cBans in the queue
                        inboundCBans = new Queue<CBanInfo>(_CBanProcessingQueue.ToArray());
                        totalCBans = inboundCBans.Count;
                        //Clear the queue for next run
                        _CBanProcessingQueue.Clear();
                    }
                    //Loop through all cBans in order that they came in
                    Boolean bansFound = false;
                    while (inboundCBans.Count > 0)
                    {
                        //Break from the loop if the plugin is disabled or the setting is reverted.
                        if (!_pluginEnabled || !_UseBanEnforcer)
                        {
                            ConsoleWarn("You exited the ban upload process early, the process was not completed.");
                            earlyExit = true;
                            break;
                        }

                        bansFound = true;

                        CBanInfo cBan = inboundCBans.Dequeue();

                        //Create the record
                        var record = new AdKatsRecord();
                        record.record_source = AdKatsRecord.Sources.InternalAutomated;
                        //Permabans and Temp bans longer than 1 year will be defaulted to permaban
                        switch (cBan.BanLength.Subset)
                        {
                            case TimeoutSubset.TimeoutSubsetType.Seconds:
                                record.command_type = GetCommandByKey("player_ban_temp");
                                record.command_action = GetCommandByKey("player_ban_temp");
                                record.command_numeric = cBan.BanLength.Seconds / 60;
                                break;
                            case TimeoutSubset.TimeoutSubsetType.Permanent:
                                record.command_type = GetCommandByKey("player_ban_perm");
                                record.command_action = GetCommandByKey("player_ban_perm");
                                record.command_numeric = 0;
                                break;
                            case TimeoutSubset.TimeoutSubsetType.Round:
                                //Accept round ban as 1 hour timeban
                                record.command_type = GetCommandByKey("player_ban_temp");
                                record.command_action = GetCommandByKey("player_ban_temp");
                                record.command_numeric = 60;
                                break;
                            default:
                                //Ban type is unknown, unable to process
                                continue;
                        }
                        record.source_name = _CBanAdminName;
                        record.server_id = _serverInfo.ServerID;
                        if (String.IsNullOrEmpty(cBan.SoldierName) && String.IsNullOrEmpty(cBan.Guid) && String.IsNullOrEmpty(cBan.IpAddress))
                        {
                            ConsoleError("Player did not contain any identifiers when processing CBan. Ignoring.");
                            continue;
                        }
                        record.target_player = FetchPlayer(true, false, false, null, -1, cBan.SoldierName, (!String.IsNullOrEmpty(cBan.Guid)) ? (cBan.Guid.ToUpper()) : (null), cBan.IpAddress);
                        if (record.target_player == null)
                        {
                            ConsoleError("Player could not be found/added when processing CBan. Ignoring.");
                            continue;
                        }
                        if (!String.IsNullOrEmpty(record.target_player.player_name))
                        {
                            record.target_name = record.target_player.player_name;
                        }
                        record.isIRO = false;
                        record.record_message = cBan.Reason;

                        //Update the ban enforcement depending on available information
                        Boolean nameAvailable = !String.IsNullOrEmpty(record.target_player.player_name);
                        Boolean guidAvailable = !String.IsNullOrEmpty(record.target_player.player_guid);
                        Boolean ipAvailable = !String.IsNullOrEmpty(record.target_player.player_ip);

                        //Create the ban
                        var aBan = new AdKatsBan
                        {
                            ban_record = record,
                            ban_enforceName = nameAvailable && (_DefaultEnforceName || (!guidAvailable && !ipAvailable) || !String.IsNullOrEmpty(cBan.SoldierName)),
                            ban_enforceGUID = guidAvailable && (_DefaultEnforceGUID || (!nameAvailable && !ipAvailable) || !String.IsNullOrEmpty(cBan.Guid)),
                            ban_enforceIP = ipAvailable && (_DefaultEnforceIP || (!nameAvailable && !guidAvailable) || !String.IsNullOrEmpty(cBan.IpAddress))
                        };
                        if (!aBan.ban_enforceName && !aBan.ban_enforceGUID && !aBan.ban_enforceIP)
                        {
                            ConsoleError("Unable to create ban, no proper player information");
                            continue;
                        }

                        //Check for duplicate ban posting
                        Boolean duplicateFound = false;
                        foreach (AdKatsBan storedBan in FetchPlayerBans(record.target_player))
                        {
                            if (storedBan.ban_record.record_message == record.record_message &&
                                storedBan.ban_record.source_name == record.source_name)
                            {
                                duplicateFound = true;
                            }
                        }
                        if (duplicateFound)
                        {
                            ConsoleInfo("Attempted to post duplicate ban for player " + record.target_player.player_id + ". Cancelling operation.");
                            continue;
                        }

                        //Upload the ban
                        DebugWrite("Uploading ban from procon.", 5);
                        UploadBan(aBan);

                        if (!_UseBanEnforcerPreviousState && (++bansImported % 25 == 0))
                        {
                            ConsoleWrite(Math.Round(100 * bansImported / totalCBans, 2) + "% of bans uploaded. AVG " + Math.Round(bansImported / ((UtcDbTime() - startTime).TotalSeconds), 2) + " uploads/sec.");
                        }
                    }
                    if (bansFound && !earlyExit)
                    {
                        //If all bans have been queued for processing, clear the ban list
                        ExecuteCommand("procon.protected.send", "banList.clear");
                        ExecuteCommand("procon.protected.send", "banList.save");
                        ExecuteCommand("procon.protected.send", "banList.list");
                        if (!_UseBanEnforcerPreviousState)
                        {
                            ConsoleSuccess("All bans uploaded into AdKats database.");
                        }
                    }
                }
                _UseBanEnforcerPreviousState = true;
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling active ban enforcer.", e));
            }
        }

        private void SubmitToMetabans(AdKatsBan aBan, AssessmentTypes type) {
            DebugWrite("^4Metabans (SubmitAssessment): Submitting assessment of GUID " + aBan.ban_record.target_player.player_guid, 3);

            var api = new MetabansAPI(_metabansUsername, _metabansAPIKey, enumBoolOnOff.On);
            api.ExecuteCommand += new MetabansAPI.ExecuteCommandHandler(api_ExecuteCommand);
            api.mb_assess_player_ok += new MetabansAPI.RequestSuccessHandler(api_mb_assess_player_ok);

            SupportedGames gameType;
            switch (_gameVersion) {
                case GameVersion.BF3:
                    gameType = SupportedGames.BF_3;
                    break;
                case GameVersion.BF4:
                    gameType = SupportedGames.BF_4;
                    break;
                default:
                    ConsoleError("Invalid game version when posting to metabans.");
                    return;
                    break;
            }
            api.mb_assess_player(gameType, aBan.ban_record.target_player.player_guid, type, aBan.ban_record.record_message, (int) (aBan.ban_endTime - aBan.ban_startTime).TotalSeconds).Post();
        }

        public void api_ExecuteCommand(params string[] commands) {
            ExecuteCommand(commands);
        }

        public void api_mb_assess_player_ok(Hashtable request, Hashtable data) {
            try {
                ConsoleInfo("^4Metabans (api_mb_assess_player_ok): Assessment accepted");
            }
            catch (Exception e) {
                ConsoleWarn("^1Metabans (api_mb_assess_player_ok): " + e.Message);
            }
        }

        private Boolean ConnectionCapable() {
            if (!string.IsNullOrEmpty(_mySqlSchemaName) && !string.IsNullOrEmpty(_mySqlHostname) && !string.IsNullOrEmpty(_mySqlPassword) && !string.IsNullOrEmpty(_mySqlPort) && !string.IsNullOrEmpty(_mySqlUsername)) {
                DebugWrite("MySql Connection capable. All variables in place.", 8);
                return true;
            }
            return false;
        }

        private MySqlConnection GetDatabaseConnection() {
            if (ConnectionCapable()) {
                var conn = new MySqlConnection(PrepareMySqlConnectionString());
                conn.Open();
                return conn;
            }
            ConsoleError("Attempted to connect to database without all variables in place.");
            return null;
        }

        private void UpdateMySqlConnectionStringBuilder() {
            lock (_dbCommStringBuilder) {
                UInt32 uintport = 3306;
                UInt32.TryParse(_mySqlPort, out uintport);
                //Add connection variables
                _dbCommStringBuilder.Port = uintport;
                _dbCommStringBuilder.Server = _mySqlHostname;
                _dbCommStringBuilder.UserID = _mySqlUsername;
                _dbCommStringBuilder.Password = _mySqlPassword;
                _dbCommStringBuilder.Database = _mySqlSchemaName;
                //Set up connection pooling
                if (UseConnectionPooling) {
                    _dbCommStringBuilder.Pooling = true;
                    _dbCommStringBuilder.MinimumPoolSize = Convert.ToUInt32(MinConnectionPoolSize);
                    _dbCommStringBuilder.MaximumPoolSize = Convert.ToUInt32(MaxConnectionPoolSize);
                    _dbCommStringBuilder.ConnectionLifeTime = 600;
                }
                else {
                    _dbCommStringBuilder.Pooling = false;
                }
                //Set Compression
                _dbCommStringBuilder.UseCompression = UseCompressedConnection;
                //Allow User Settings
                _dbCommStringBuilder.AllowUserVariables = true;
                //Set Timeout Settings
                _dbCommStringBuilder.DefaultCommandTimeout = 3600;
                _dbCommStringBuilder.ConnectionTimeout = 50;
            }
        }

        private String PrepareMySqlConnectionString() {
            return _dbCommStringBuilder.ConnectionString;
        }

        private Boolean TestDatabaseConnection() {
            Boolean databaseValid = false;
            DebugWrite("testDatabaseConnection starting!", 6);
            if (ConnectionCapable()) {
                Boolean success = false;
                Int32 attempt = 0;
                do {
                    if (!_pluginEnabled) {
                        return false;
                    }
                    attempt++;
                    try {
                        UpdateMySqlConnectionStringBuilder();
                        //Prepare the connection String and create the connection object
                        using (MySqlConnection connection = GetDatabaseConnection()) {
                            if (attempt > 1)
                            {
                                ConsoleWrite("Attempting database connection. Attempt " + attempt + " of 5.");
                            }
                            //Attempt a ping through the connection
                            if (connection.Ping()) {
                                //Connection good
                                ConsoleSuccess("Database connection open.");
                                success = true;
                            }
                            else {
                                //Connection poor
                                ConsoleError("Database connection FAILED ping test.");
                            }
                        } //databaseConnection gets closed here
                        if (success) {
                            //Make sure database structure is good
                            if (ConfirmDatabaseSetup()) {
                                //Confirm the database is valid
                                databaseValid = true;
                                //clear setting change monitor
                                _dbSettingsChanged = false;
                            }
                            else {
                                Disable();
                                break;
                            }
                        }
                    }
                    catch (Exception e) {
                        //Only perform retries if the error was a timeout
                        if (e.ToString().Contains("Unable to connect")) {
                            ConsoleError("Database connection failed. Attempt " + attempt + " of 5. " + ((attempt <= 5) ? ("Retrying in 5 seconds. ") : ("")));
                            _threadMasterWaitHandle.WaitOne(5000);
                        }
                        else {
                            break;
                        }
                    }
                } while (!success && attempt < 5);
                if (!success) {
                    //Invalid credentials or no connection to database
                    ConsoleError("Database connection FAILED with EXCEPTION. Bad credentials, invalid hostname, or invalid port.");
                    Disable();
                }
                else
                {
                    TimeSpan diffDBUTC;
                    _dbTimingValid = TestDBTiming(true, out diffDBUTC);
                    _dbTimingOffset = diffDBUTC;
                }
            }
            else {
                ConsoleError("Not DB connection capable yet, complete SQL connection variables.");
                Disable();
                _threadMasterWaitHandle.WaitOne(500);
            }
            DebugWrite("testDatabaseConnection finished!", 6);

            return databaseValid;
        }

        private Boolean ConfirmDatabaseSetup() {
            DebugWrite("Confirming Database Structure.", 3);
            try {
                if (!ConfirmStatLoggerTables()) {
                    ConsoleError("Tables from XPKiller's Stat Logger not present in the database. Enable that plugin then re-run AdKats!");
                    return false;
                }
                if (!ConfirmAdKatsTables()) {
                    ConsoleError("AdKats tables not present or valid in the database. Have you run the AdKats database setup script yet? If so, are your tables InnoDB?");
                    return false;
                }
                ConsoleSuccess("Database confirmed functional for AdKats use.");
                return true;
            }
            catch (Exception e) {
                ConsoleError("ERROR in helper_confirmDatabaseSetup: " + e);
                return false;
            }
        }

        private Boolean runDBSetupScript() {
            try {
                ConsoleWrite("Running database setup script. You will not lose any data.");
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        var client = new WebClient();
                        DebugWrite("Fetching plugin changelog...", 2);
                        try
                        {
                            command.CommandText = client.DownloadString("https://raw.github.com/AdKats/AdKats/master/adkats.sql");
                            DebugWrite("SQL setup script fetched.", 1);
                        }
                        catch (Exception)
                        {
                            try
                            {
                                command.CommandText = client.DownloadString("http://api.gamerethos.net/adkats/fetch/sqlsetup");
                                DebugWrite("SQL setup script fetched from backup location.", 1);
                            }
                            catch (Exception)
                            {
                                ConsoleError("Failed to fetch SQL setup script.");
                                return false;
                            }
                        }
                        try {
                            //Attempt to execute the query
                            Int32 rowsAffected = SafeExecuteNonQuery(command);
                            ConsoleWrite("Setup script successful, your database is now prepared for use by AdKats " + GetPluginVersion());
                            return true;
                        }
                        catch (Exception e) {
                            HandleException(new AdKatsException("Your database did not accept the script. Does your account have access to table, trigger, and stored procedure creation?", e));
                        }
                    }
                }
            }
            catch (Exception e) {
                ConsoleError("Unable to set up the database for AdKats use." + e);
            }
            return false;
        }

        private Boolean ConfirmAdKatsTables()
        {
            if (!ConfirmTable("adkats_specialplayers"))
            {
                ConsoleInfo("Special players table not found. Attempting to add.");
                SendNonQuery("Adding special soldiers table", @"
                    CREATE TABLE IF NOT EXISTS `adkats_specialplayers`( 
                      `specialplayer_id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
                      `player_group` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
                      `player_id` int(10) UNSIGNED DEFAULT NULL,
                      `player_game` tinyint(4) UNSIGNED DEFAULT NULL,
                      `player_server` smallint(5) UNSIGNED DEFAULT NULL,
                      `player_identifier` varchar(100) COLLATE utf8_unicode_ci DEFAULT NULL,
                      `player_expiration` DATETIME NOT NULL,
                      PRIMARY KEY (`specialplayer_id`)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='AdKats - Special Player List'", true);
                SendNonQuery("Adding special soldiers table foreign keys", @"
                    ALTER TABLE `adkats_specialplayers`
                        ADD CONSTRAINT `adkats_specialplayers_game_id` FOREIGN KEY (`player_game`) REFERENCES `tbl_games`(`GameID`) ON UPDATE NO ACTION ON DELETE CASCADE, 
                        ADD CONSTRAINT `adkats_specialplayers_server_id` FOREIGN KEY (`player_server`) REFERENCES `tbl_server`(`ServerID`) ON UPDATE NO ACTION ON DELETE CASCADE, 
                        ADD CONSTRAINT `adkats_specialplayers_player_id` FOREIGN KEY (`player_id`) REFERENCES `tbl_playerdata`(`PlayerID`) ON UPDATE NO ACTION ON DELETE CASCADE", true);
            }
            if (!ConfirmTable("adkats_player_reputation"))
            {
                ConsoleInfo("Player reputation table not found. Attempting to add.");
                SendNonQuery("Adding player reputation table", @"
                    CREATE TABLE `adkats_player_reputation` (
                      `player_id` int(10) unsigned NOT NULL,
                      `game_id` tinyint(4) unsigned NOT NULL,
                      `target_rep` float NOT NULL,
                      `source_rep` float NOT NULL,
                      `total_rep` float NOT NULL,
                      `total_rep_co` float NOT NULL,
                      PRIMARY KEY (`player_id`),
                      KEY `game_id` (`game_id`)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='AdKats - Player Reputation'", true);
                SendNonQuery("Adding player reputation table foreign keys", @"
                    ALTER TABLE `adkats_player_reputation`
                        ADD CONSTRAINT `adkats_player_reputation_ibfk_1` FOREIGN KEY (`player_id`) REFERENCES `tbl_playerdata` (`PlayerID`) ON DELETE CASCADE ON UPDATE CASCADE,
                        ADD CONSTRAINT `adkats_player_reputation_ibfk_2` FOREIGN KEY (`game_id`) REFERENCES `tbl_games` (`GameID`) ON DELETE CASCADE ON UPDATE CASCADE", true);
            }
            if (!ConfirmTable("adkats_orchestration"))
            {
                ConsoleInfo("Plugin orchestration table not found. Attempting to add.");
                SendNonQuery("Adding plugin orchestration table", @"
                     CREATE TABLE `adkats_orchestration` (
                        `setting_id` int(10) NOT NULL AUTO_INCREMENT,
                        `setting_server` SMALLINT(5) NOT NULL,
                        `setting_plugin` VARCHAR(100) NOT NULL,
                        `setting_name` VARCHAR(100) NOT NULL,
                        `setting_value` VARCHAR (2000) NOT NULL,
                        PRIMARY KEY (`setting_id`),
                        UNIQUE(`setting_server`, `setting_plugin`, `setting_name`)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='AdKats - Plugin Orchestration'", true);
            }
            if (!ConfirmTable("tbl_extendedroundstats"))
            {
                ConsoleInfo("Extended round stats table not found. Attempting to add.");
                SendNonQuery("Adding extended round stats table", @"
                    CREATE TABLE `tbl_extendedroundstats` (
                        `roundstat_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
                        `server_id` smallint(5) unsigned NOT NULL,
                        `round_id` int(10) unsigned NOT NULL,
                        `round_elapsedTimeSec` int(10) unsigned NOT NULL,
                        `team1_count` int(10) unsigned NOT NULL,
                        `team2_count` int(10) unsigned NOT NULL,
                        `team1_score` int(10) NOT NULL,
                        `team2_score` int(10) NOT NULL,
                        `team1_spm` double NOT NULL,
                        `team2_spm` double NOT NULL,
                        `team1_tickets` int(10) NOT NULL,
                        `team2_tickets` int(10) NOT NULL,
                        `team1_tpm` double NOT NULL,
                        `team2_tpm` double NOT NULL,
                        `roundstat_time` datetime NOT NULL,
                        PRIMARY KEY (`roundstat_id`)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='AdKats - Extended Round Stats'", true);
            }
            if (!ConfirmTable("adkats_statistics"))
            {
                ConsoleInfo("AdKats statistics table not found. Attempting to add.");
                SendNonQuery("Adding AdKats statistics table", @"
                    CREATE TABLE `adkats_statistics` (
                      `stat_id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
                      `server_id` SMALLINT(5) UNSIGNED NOT NULL,
                      `round_id` INT(10) UNSIGNED NOT NULL,
                      `stat_type` varchar(50) NOT NULL,
                      `target_name` varchar(50) NOT NULL,
                      `target_id` INT(10) UNSIGNED DEFAULT NULL,
                      `stat_value` FLOAT NOT NULL,
                      `stat_comment` TEXT,
                      `stat_time` DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00',
                      PRIMARY KEY (`stat_id`),
                      KEY `server_id` (`server_id`),
                      KEY `stat_type` (`stat_type`),
                      KEY `target_id` (`target_id`),
                      KEY `stat_time` (`stat_time`),
                      CONSTRAINT `adkats_statistics_target_id_fk` FOREIGN KEY (`target_id`) REFERENCES `tbl_playerdata` (`PlayerID`) ON DELETE NO ACTION ON UPDATE NO ACTION,
                      CONSTRAINT `adkats_statistics_server_id_fk` FOREIGN KEY (`server_id`) REFERENCES `tbl_server` (`ServerID`) ON DELETE NO ACTION ON UPDATE NO ACTION
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='AdKats - Statistics'", true);
            }
            if (!SendQuery("SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE ( TABLE_SCHEMA = '" + _mySqlSchemaName + "' AND TABLE_NAME = 'adkats_specialplayers' AND COLUMN_NAME = 'player_effective' )", false))
            {
                ConsoleInfo("Special player effective not found. Attempting to add.");
                SendNonQuery("Adding special player effective.", "ALTER TABLE `adkats_specialplayers` ADD COLUMN `player_effective` DATETIME NOT NULL AFTER `player_identifier`", true);
                SendNonQuery("Adding initial special player effective values.", "UPDATE `adkats_specialplayers` SET `player_effective` = UTC_TIMESTAMP()", true);
            }
            if (!SendQuery("SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE ( TABLE_SCHEMA = '" + _mySqlSchemaName + "' AND TABLE_NAME = 'adkats_specialplayers' AND COLUMN_NAME = 'player_expiration' )", false))
            {
                ConsoleInfo("Special player expiration not found. Attempting to add.");
                SendNonQuery("Adding special player expiration.", "ALTER TABLE `adkats_specialplayers` ADD COLUMN `player_expiration` DATETIME NOT NULL AFTER `player_effective`", true);
                SendNonQuery("Adding initial special player expiration values.", "UPDATE `adkats_specialplayers` SET `player_expiration` = DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)", true);
            }
            if (!ConfirmTable("adkats_rolegroups"))
            {
                ConsoleInfo("AdKats role groups table not found. Attempting to add.");
                SendNonQuery("Adding AdKats role groups table", @"
                    CREATE TABLE `adkats_rolegroups` (
                      `role_id` int(11) unsigned NOT NULL,
                      `group_key` VARCHAR(100) NOT NULL,
                      PRIMARY KEY (`role_id`,`group_key`),
                      KEY `adkats_rolegroups_fk_role` (`role_id`),
                      KEY `adkats_rolegroups_fk_command` (`group_key`),
                      CONSTRAINT `adkats_rolegroups_fk_role` FOREIGN KEY (`role_id`) REFERENCES `adkats_roles` (`role_id`) ON DELETE CASCADE ON UPDATE CASCADE
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='AdKats - Connection of groups to roles'", true);
            }
            return  ConfirmTable("adkats_bans") && 
                    ConfirmTable("adkats_commands") && 
                    ConfirmTable("adkats_infractions_global") && 
                    ConfirmTable("adkats_infractions_server") && 
                    ConfirmTable("adkats_records_debug") && 
                    ConfirmTable("adkats_records_main") && 
                    ConfirmTable("adkats_rolecommands") && 
                    ConfirmTable("adkats_roles") && 
                    ConfirmTable("adkats_settings") && 
                    ConfirmTable("adkats_users") &&
                    ConfirmTable("adkats_usersoldiers") &&
                    ConfirmTable("adkats_specialplayers") &&
                    ConfirmTable("adkats_player_reputation") &&
                    ConfirmTable("adkats_orchestration") &&
                    ConfirmTable("adkats_statistics") && 
                    ConfirmTable("adkats_rolegroups") && 
                    ConfirmTable("tbl_extendedroundstats") &&
                    !SendQuery("SELECT `TABLE_NAME` AS `table_name` FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_SCHEMA` = '" + _mySqlSchemaName + "' AND `TABLE_NAME` LIKE 'adkats_%' AND ENGINE <> 'InnoDB'", false);
        }

        private Boolean ConfirmStatLoggerTables() {
            Boolean confirmed = true;
            //All versions of stat logger should have these tables
            if (ConfirmTable("tbl_playerdata") && ConfirmTable("tbl_server") && ConfirmTable("tbl_chatlog")) {
                //The universal version has a tbl_games table, detect that
                if (ConfirmTable("tbl_games")) {
                    _statLoggerVersion = "UNIVERSAL";
                    Boolean gameIDFound = false;
                    using (MySqlConnection connection = GetDatabaseConnection()) {
                        using (MySqlCommand command = connection.CreateCommand()) {
                            //Attempt to execute the query
                            command.CommandText = @"
                            SELECT 
                                `GameID` AS `game_id`, 
                                `Name` AS `game_name` 
                            FROM 
                                `tbl_games`";
                            using (MySqlDataReader reader = SafeExecuteReader(command)) {
                                lock (_gameIDDictionary) {
                                    _gameIDDictionary.Clear();
                                    while (reader.Read()) {
                                        String gameName = reader.GetString("game_name");
                                        Int32 gameID = reader.GetInt32("game_id");
                                        if (!_gameIDDictionary.ContainsKey(gameID)) {
                                            if (_gameVersion.ToString() == gameName) {
                                                _serverInfo.GameID = gameID;
                                                gameIDFound = true;
                                            }
                                            switch (gameName) {
                                                case "BF3":
                                                    _gameIDDictionary.Add(gameID, GameVersion.BF3);
                                                    break;
                                                case "BF4":
                                                    _gameIDDictionary.Add(gameID, GameVersion.BF4);
                                                    break;
                                                default:
                                                    ConsoleError("Game name " + gameName + " not recognized.");
                                                    break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        confirmed = gameIDFound;
                    }
                }
            }
            else {
                confirmed = false;
            }
            return confirmed;
        }

        private void UpdateDatabase37014000() {
            try {
                //Check if old database table exists
                if (!ConfirmTable("adkats_records")) {
                    DebugWrite("Not updating database, no old tables to pull from.", 1);
                    return;
                }
                //If the new main record table contains records return without handling
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT
	                        *
                        FROM
	                        `adkats_records_main`
                        LIMIT 1";
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                ConsoleInfo("Not updating database, new records already found.");
                                return;
                            }
                        }
                    }
                }
                ConsoleWarn("Updating database information from version 3.7 spec to 4.0 spec. DO NOT DISABLE AdKats!");
                ConsoleWrite("Updating Users.");
                //Add new users for every player in the access list
                var oldUsers = new List<AdKatsUser>();
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT
	                        `player_name`,
	                        `access_level`
                        FROM
	                        `adkats_accesslist`
                        ORDER BY
                            `access_level`
                        ASC";
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            while (reader.Read()) {
                                //Set all users to default guest role
                                oldUsers.Add(new AdKatsUser {
                                    user_name = reader.GetString("player_name"),
                                    user_role = _RoleKeyDictionary["guest_default"],
                                    user_expiration = UtcDbTime().AddYears(20),
                                    user_notes = "No Notes"
                                });
                            }
                        }
                    }
                }
                foreach (AdKatsUser aUser in oldUsers) {
                    ConsoleWrite("Processing user " + aUser.user_name);
                    //Attempt to add soldiers matching the user's names
                    TryAddUserSoldier(aUser, aUser.user_name);
                    UploadUser(aUser);
                }
                ConsoleSuccess(oldUsers.Count + " old users fetched and updated to new spec.");
                ConsoleInfo("Updating Records...");
                //Generate old->new command key dictionary
                var commandConversionDictionary = new Dictionary<string, AdKatsCommand>();
                commandConversionDictionary.Add("AdminSay", GetCommandByKey("admin_say"));
                commandConversionDictionary.Add("AdminTell", GetCommandByKey("admin_tell"));
                commandConversionDictionary.Add("AdminYell", GetCommandByKey("admin_yell"));
                commandConversionDictionary.Add("CallAdmin", GetCommandByKey("player_calladmin"));
                commandConversionDictionary.Add("ConfirmReport", GetCommandByKey("player_report_confirm"));
                commandConversionDictionary.Add("EndLevel", GetCommandByKey("round_end"));
                commandConversionDictionary.Add("EnforceBan", GetCommandByKey("banenforcer_enforce"));
                commandConversionDictionary.Add("Exception", GetCommandByKey("adkats_exception"));
                commandConversionDictionary.Add("ForceMove", GetCommandByKey("player_fmove"));
                commandConversionDictionary.Add("Forgive", GetCommandByKey("player_forgive"));
                commandConversionDictionary.Add("Join", GetCommandByKey("player_join"));
                commandConversionDictionary.Add("Kick", GetCommandByKey("player_kick"));
                commandConversionDictionary.Add("Kill", GetCommandByKey("player_kill"));
                commandConversionDictionary.Add("KickAll", GetCommandByKey("server_kickall"));
                commandConversionDictionary.Add("LowPopKill", GetCommandByKey("player_kill_lowpop"));
                commandConversionDictionary.Add("Move", GetCommandByKey("player_move"));
                commandConversionDictionary.Add("Mute", GetCommandByKey("player_mute"));
                commandConversionDictionary.Add("NextLevel", GetCommandByKey("round_next"));
                commandConversionDictionary.Add("Nuke", GetCommandByKey("server_nuke"));
                commandConversionDictionary.Add("PermaBan", GetCommandByKey("player_ban_perm"));
                commandConversionDictionary.Add("PlayerSay", GetCommandByKey("player_say"));
                commandConversionDictionary.Add("PlayerYell", GetCommandByKey("player_yell"));
                commandConversionDictionary.Add("PlayerTell", GetCommandByKey("player_tell"));
                commandConversionDictionary.Add("Punish", GetCommandByKey("player_punish"));
                commandConversionDictionary.Add("RepeatKill", GetCommandByKey("player_kill_repeat"));
                commandConversionDictionary.Add("Report", GetCommandByKey("player_report"));
                commandConversionDictionary.Add("RestartLevel", GetCommandByKey("round_restart"));
                commandConversionDictionary.Add("RequestRules", GetCommandByKey("self_rules"));
                commandConversionDictionary.Add("RoundWhitelist", GetCommandByKey("player_roundwhitelist"));
                commandConversionDictionary.Add("KillSelf", GetCommandByKey("self_kill"));
                commandConversionDictionary.Add("Teamswap", GetCommandByKey("self_teamswap"));
                commandConversionDictionary.Add("TempBan", GetCommandByKey("player_ban_temp"));
                ConsoleWrite("Updating Bans...");
                //Download all bans
                Double totalBans = 0;
                Double bansDownloaded = 0;
                Double bansUpdated = 0;
                DateTime startTime = UtcDbTime();
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            COUNT(*) AS `ban_count`
                        FROM 
	                        `adkats_banlist`";

                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                totalBans = reader.GetInt64("ban_count");
                            }
                        }
                    }
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
	                        `adkats_records`.`record_id`,
	                        `adkats_records`.`server_id`,
	                        `adkats_records`.`command_type`,
	                        `adkats_records`.`command_action`,
	                        `adkats_records`.`command_numeric`,
	                        `adkats_records`.`target_name`,
	                        `adkats_records`.`target_id`,
	                        `adkats_records`.`source_name`,
	                        `adkats_records`.`source_id`,
	                        `adkats_records`.`record_message`,
	                        `adkats_records`.`record_time`,
	                        `adkats_records`.`adkats_read`,
	                        `adkats_records`.`adkats_web`,
	                        `adkats_banlist`.`ban_id`, 
	                        `adkats_banlist`.`player_id`, 
	                        `adkats_banlist`.`latest_record_id`, 
	                        `adkats_banlist`.`ban_status`, 
	                        `adkats_banlist`.`ban_notes`, 
	                        `adkats_banlist`.`ban_sync`, 
	                        `adkats_banlist`.`ban_startTime`, 
	                        `adkats_banlist`.`ban_endTime`, 
	                        `adkats_banlist`.`ban_enforceName`, 
	                        `adkats_banlist`.`ban_enforceGUID`, 
	                        `adkats_banlist`.`ban_enforceIP`
                        FROM 
	                        `adkats_banlist`
                        INNER JOIN
	                        `adkats_records`
                        ON
	                        `adkats_banlist`.`latest_record_id` = `adkats_records`.`record_id`";

                        var importedBans = new List<AdKatsBan>();
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            //Loop through all incoming bans
                            while (reader.Read()) {
                                //Create the ban element
                                var aBan = new AdKatsBan {
                                    ban_id = reader.GetInt64("ban_id"),
                                    ban_status = reader.GetString("ban_status"),
                                    ban_notes = reader.GetString("ban_notes"),
                                    ban_sync = reader.GetString("ban_sync"),
                                    ban_startTime = reader.GetDateTime("ban_startTime"),
                                    ban_endTime = reader.GetDateTime("ban_endTime"),
                                    ban_enforceName = (reader.GetString("ban_enforceName") == "Y"),
                                    ban_enforceGUID = (reader.GetString("ban_enforceGUID") == "Y"),
                                    ban_enforceIP = (reader.GetString("ban_enforceIP") == "Y")
                                };
                                var aRecord = new AdKatsRecord();
                                aRecord.record_source = AdKatsRecord.Sources.InternalAutomated;
                                aRecord.server_id = reader.GetInt64("server_id");
                                AdKatsCommand aCommandType = null;
                                if (commandConversionDictionary.TryGetValue(reader.GetString("command_type"), out aCommandType)) {
                                    aRecord.command_type = aCommandType;
                                }
                                else {
                                    //Skip record
                                    //ConsoleError("Unable to parse '" + reader.GetString("command_type") + "' as a valid command type. Skipping ban record.");
                                    continue;
                                }
                                AdKatsCommand aCommandAction = null;
                                if (commandConversionDictionary.TryGetValue(reader.GetString("command_action"), out aCommandAction)) {
                                    aRecord.command_action = aCommandAction;
                                }
                                else {
                                    //Skip record
                                    //ConsoleError("Unable to parse '" + reader.GetString("command_action") + "' as a valid command action. Skipping ban record.");
                                    continue;
                                }
                                aRecord.command_numeric = reader.GetInt32("command_numeric");
                                aRecord.record_message = reader.GetString("record_message");
                                aRecord.target_name = reader.GetString("target_name");
                                if (!reader.IsDBNull(6)) {
                                    Int32 playerID = reader.GetInt32(6);
                                    aRecord.target_player = new AdKatsPlayer(this) {
                                        player_id = playerID
                                    };
                                }
                                aRecord.source_name = reader.GetString("source_name");
                                if (!reader.IsDBNull(8)) {
                                    Int32 playerID = reader.GetInt32(8);
                                    aRecord.source_player = new AdKatsPlayer(this) {
                                        player_id = playerID
                                    };
                                }
                                aRecord.record_time = reader.GetDateTime("record_time");
                                aBan.ban_record = aRecord;
                                importedBans.Add(aBan);

                                if (++bansDownloaded % 100 == 0) {
                                    ConsoleWrite(Math.Round(100 * bansDownloaded / totalBans, 2) + "% of bans downloaded. AVG " + Math.Round(bansDownloaded / ((UtcDbTime() - startTime).TotalSeconds), 2) + " downloads/sec.");
                                }
                            }
                        }
                        if (importedBans.Count > 0) {
                            ConsoleInfo(importedBans.Count + " bans downloaded, beginning update to 4.0 spec.");
                        }
                        startTime = UtcDbTime();
                        //Upload all of those bans to the new database
                        foreach (AdKatsBan aBan in importedBans) {
                            UploadBan(aBan);
                            if (++bansUpdated % 15 == 0) {
                                ConsoleWrite(Math.Round(100 * bansUpdated / totalBans, 2) + "% of bans updated. AVG " + Math.Round(bansUpdated / ((UtcDbTime() - startTime).TotalSeconds), 2) + " updates/sec.");
                            }
                        }
                        ConsoleSuccess("All AdKats Enforced bans updated to 4.0 spec.");
                    }
                }
                //Import all records that do not have command action TempBan or PermaBan
                Double recordsDownloaded = 0;
                Double recordsProcessed = 0;
                var oldRecords = new List<AdKatsRecord>();
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT
	                        `record_id`,
	                        `server_id`,
	                        `command_type`,
	                        `command_action`,
	                        `command_numeric`,
	                        `target_name`,
	                        `target_id`,
	                        `source_name`,
	                        `source_id`,
	                        `record_message`,
	                        `record_time`,
	                        `adkats_read`,
	                        `adkats_web`
                        FROM
	                        `adkats_records`
                        WHERE
                            `command_action` <> 'Exception'
                        ORDER BY
	                        `record_id`
                        ASC";
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            while (reader.Read()) {
                                var aRecord = new AdKatsRecord();
                                aRecord.record_source = AdKatsRecord.Sources.InternalAutomated;
                                aRecord.server_id = reader.GetInt64("server_id");
                                AdKatsCommand aCommandType = null;
                                if (commandConversionDictionary.TryGetValue(reader.GetString("command_type"), out aCommandType)) {
                                    aRecord.command_type = aCommandType;
                                }
                                else {
                                    //Skip record
                                    //ConsoleError("Unable to parse '" + reader.GetString("command_type") + "' as a valid command type. Skipping record.");
                                    continue;
                                }
                                AdKatsCommand aCommandAction = null;
                                if (commandConversionDictionary.TryGetValue(reader.GetString("command_action"), out aCommandAction)) {
                                    aRecord.command_action = aCommandAction;
                                }
                                else {
                                    //Skip record
                                    //ConsoleError("Unable to parse '" + reader.GetString("command_action") + "' as a valid command action. Cancelling database update.");
                                    return;
                                }
                                aRecord.command_numeric = reader.GetInt32("command_numeric");
                                aRecord.record_message = reader.GetString("record_message");
                                aRecord.target_name = reader.GetString("target_name");
                                if (!reader.IsDBNull(6)) {
                                    Int32 playerID = reader.GetInt32(6);
                                    aRecord.target_player = new AdKatsPlayer(this) {
                                        player_id = playerID
                                    };
                                }
                                aRecord.source_name = reader.GetString("source_name");
                                if (!reader.IsDBNull(8)) {
                                    Int32 playerID = reader.GetInt32(8);
                                    aRecord.source_player = new AdKatsPlayer(this) {
                                        player_id = playerID
                                    };
                                }
                                aRecord.record_time = reader.GetDateTime("record_time");
                                //Set all users to default guest role
                                oldRecords.Add(aRecord);
                                if (++recordsDownloaded % 5000 == 0) {
                                    ConsoleWrite(recordsDownloaded + " records downloaded for processing.");
                                }
                            }
                        }
                    }
                }
                ConsoleSuccess("All records prepared for update.");
                //Upload all of those records to the new database spec
                ConsoleInfo("Updating all prepared records...");
                foreach (AdKatsRecord aRecord in oldRecords) {
                    //Attempt to upload the record
                    UploadRecord(aRecord);
                    if (++recordsProcessed % 50 == 0) {
                        ConsoleWrite(Math.Round(100 * recordsProcessed / recordsDownloaded, 3) + "% of records updated into 4.0 spec.");
                    }
                }
                ConsoleSuccess("All records updated to 4.0 spec.");
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while updating database information from 3.7 spec to 4.0 spec.", e));
            }
        }

        private Boolean ConfirmTable(String tableName) {
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '" + _mySqlSchemaName + "' AND TABLE_NAME= '" + tableName + "'";
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            var confirmed = reader.Read();
                            return confirmed;
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while confirming table '" + tableName + "'", e));
                return false;
            }
        }

        private void UploadAllSettings() {
            if (!_pluginEnabled) {
                return;
            }
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                DebugWrite("uploadAllSettings starting!", 6);
                QueueSettingForUpload(new CPluginVariable(@"Auto-Enable/Keep-Alive", typeof(Boolean), _useKeepAlive));
                QueueSettingForUpload(new CPluginVariable(@"Override Timing Confirmation", typeof(Boolean), _timingValidOverride));
                QueueSettingForUpload(new CPluginVariable(@"Debug level", typeof (int), _debugLevel));
                QueueSettingForUpload(new CPluginVariable(@"Debug Soldier Name", typeof (String), _debugSoldierName));
                QueueSettingForUpload(new CPluginVariable(@"Server VOIP Address", typeof (String), _ServerVoipAddress));
                QueueSettingForUpload(new CPluginVariable(@"Rule Print Delay", typeof (Double), _ServerRulesDelay));
                QueueSettingForUpload(new CPluginVariable(@"Rule Print Interval", typeof (Double), _ServerRulesInterval));
                QueueSettingForUpload(new CPluginVariable(@"Server Rule List", typeof(String), CPluginVariable.EncodeStringArray(_ServerRulesList)));
                QueueSettingForUpload(new CPluginVariable(@"Server Rule Numbers", typeof(Boolean), _ServerRulesNumbers));
                QueueSettingForUpload(new CPluginVariable(@"Yell Server Rules", typeof(Boolean), _ServerRulesYell));
                QueueSettingForUpload(new CPluginVariable(@"Feed MULTIBalancer Whitelist", typeof (Boolean), _FeedMultiBalancerWhitelist));
                QueueSettingForUpload(new CPluginVariable(@"Feed MULTIBalancer Even Dispersion List", typeof(Boolean), _FeedMultiBalancerDisperseList)); 
                QueueSettingForUpload(new CPluginVariable(@"Automatic MULTIBalancer Whitelist for Admins", typeof(Boolean), _FeedMultiBalancerWhitelist_Admins));
                QueueSettingForUpload(new CPluginVariable(@"Automatic Reserved Slot for Admins", typeof(Boolean), _FeedServerReservedSlots_Admins));
                QueueSettingForUpload(new CPluginVariable(@"Automatic Spectator Slot for Admins", typeof(Boolean), _FeedServerSpectatorList_Admins));
                QueueSettingForUpload(new CPluginVariable(@"Feed Server Reserved Slots", typeof (Boolean), _FeedServerReservedSlots));
                QueueSettingForUpload(new CPluginVariable(@"Feed Server Spectator List", typeof (Boolean), _FeedServerSpectatorList));
                QueueSettingForUpload(new CPluginVariable(@"Feed Stat Logger Settings", typeof(Boolean), _FeedStatLoggerSettings));
                QueueSettingForUpload(new CPluginVariable(@"Post Stat Logger Chat Manually", typeof(Boolean), _PostStatLoggerChatManually));
                QueueSettingForUpload(new CPluginVariable(@"Post Server Chat Spam", typeof(Boolean), _PostStatLoggerChatManually_PostServerChatSpam));
                QueueSettingForUpload(new CPluginVariable(@"Exclude Commands from Chat Logs", typeof(Boolean), _PostStatLoggerChatManually_IgnoreCommands));
                QueueSettingForUpload(new CPluginVariable(@"Post Map Benefit/Detriment Statistics", typeof(Boolean), _PostMapBenefitStatistics));
                QueueSettingForUpload(new CPluginVariable(@"Round Timer: Enable", typeof (Boolean), _useRoundTimer));
                QueueSettingForUpload(new CPluginVariable(@"Round Timer: Round Duration Minutes", typeof (Double), _maxRoundTimeMinutes));
                QueueSettingForUpload(new CPluginVariable(@"Use NO EXPLOSIVES Limiter", typeof (Boolean), _UseWeaponLimiter));
                QueueSettingForUpload(new CPluginVariable(@"NO EXPLOSIVES Weapon String", typeof (String), _WeaponLimiterString));
                QueueSettingForUpload(new CPluginVariable(@"NO EXPLOSIVES Exception String", typeof(String), _WeaponLimiterExceptionString));
                QueueSettingForUpload(new CPluginVariable(@"Use AA Report Auto Handler", typeof(Boolean), _UseAAReportAutoHandler));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Report-Handler Strings", typeof (String), CPluginVariable.EncodeStringArray(_AutoReportHandleStrings)));
                QueueSettingForUpload(new CPluginVariable(@"Use Grenade Cook Catcher", typeof (Boolean), _UseGrenadeCookCatcher));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: Enable", typeof (Boolean), _UseHackerChecker));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: DPS Checker: Enable", typeof (Boolean), _UseDpsChecker));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: DPS Checker: Trigger Level", typeof (Double), _DpsTriggerLevel));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: DPS Checker: Ban Message", typeof (String), _HackerCheckerDPSBanMessage));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: HSK Checker: Enable", typeof (Boolean), _UseHskChecker));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: HSK Checker: Trigger Level", typeof (Double), _HskTriggerLevel));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: HSK Checker: Ban Message", typeof (String), _HackerCheckerHSKBanMessage));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: KPM Checker: Enable", typeof (Boolean), _UseKpmChecker));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: KPM Checker: Trigger Level", typeof (Double), _KpmTriggerLevel));
                QueueSettingForUpload(new CPluginVariable(@"HackerChecker: KPM Checker: Ban Message", typeof(String), _HackerCheckerKPMBanMessage));
                QueueSettingForUpload(new CPluginVariable(@"AdkatsLRT Extension Token", typeof(String), _AdKatsLRTExtensionToken));
                QueueSettingForUpload(new CPluginVariable(@"Fetch Actions from Database", typeof (Boolean), _fetchActionsFromDb));
                QueueSettingForUpload(new CPluginVariable(@"Use Additional Ban Message", typeof (Boolean), _UseBanAppend));
                QueueSettingForUpload(new CPluginVariable(@"Additional Ban Message", typeof (String), _BanAppend));
                QueueSettingForUpload(new CPluginVariable(@"Procon Ban Admin Name", typeof (String), _CBanAdminName));
                QueueSettingForUpload(new CPluginVariable(@"Use Ban Enforcer", typeof (Boolean), _UseBanEnforcer));
                QueueSettingForUpload(new CPluginVariable(@"Enforce New Bans by NAME", typeof (Boolean), _DefaultEnforceName));
                QueueSettingForUpload(new CPluginVariable(@"Enforce New Bans by GUID", typeof (Boolean), _DefaultEnforceGUID));
                QueueSettingForUpload(new CPluginVariable(@"Enforce New Bans by IP", typeof (Boolean), _DefaultEnforceIP));
                QueueSettingForUpload(new CPluginVariable(@"Minimum Required Reason Length", typeof(Int32), _RequiredReasonLength));
                QueueSettingForUpload(new CPluginVariable(@"Minimum Report Handle Seconds", typeof(Int32), _MinimumReportHandleSeconds));
                QueueSettingForUpload(new CPluginVariable(@"Punishment Hierarchy", typeof (String), CPluginVariable.EncodeStringArray(_PunishmentHierarchy)));
                QueueSettingForUpload(new CPluginVariable(@"Combine Server Punishments", typeof (Boolean), _CombineServerPunishments));
                QueueSettingForUpload(new CPluginVariable(@"Only Kill Players when Server in low population", typeof (Boolean), _OnlyKillOnLowPop));
                QueueSettingForUpload(new CPluginVariable(@"Low Population Value", typeof(Int32), _lowPopulationPlayerCount));
                QueueSettingForUpload(new CPluginVariable(@"High Population Value", typeof(Int32), _highPopulationPlayerCount));
                QueueSettingForUpload(new CPluginVariable(@"Use IRO Punishment", typeof (Boolean), _IROActive));
                QueueSettingForUpload(new CPluginVariable(@"IRO Punishment Overrides Low Pop", typeof (Boolean), _IROOverridesLowPop));
                QueueSettingForUpload(new CPluginVariable(@"IRO Timeout Minutes", typeof(Int32), _IROTimeout));
                QueueSettingForUpload(new CPluginVariable(@"Maximum Temp-Ban Duration Minutes", typeof(Double), _MaxTempBanDuration.TotalMinutes));
                QueueSettingForUpload(new CPluginVariable(@"Send Emails", typeof (Boolean), _UseEmail));
                QueueSettingForUpload(new CPluginVariable(@"Use SSL?", typeof (Boolean), _EmailHandler.UseSSL));
                QueueSettingForUpload(new CPluginVariable(@"SMTP-Server address", typeof (String), _EmailHandler.SMTPServer));
                QueueSettingForUpload(new CPluginVariable(@"SMTP-Server port", typeof (Int32), _EmailHandler.SMTPPort));
                QueueSettingForUpload(new CPluginVariable(@"Sender address", typeof (String), _EmailHandler.SenderEmail));
                QueueSettingForUpload(new CPluginVariable(@"SMTP-Server username", typeof (String), _EmailHandler.SMTPUser));
                QueueSettingForUpload(new CPluginVariable(@"SMTP-Server password", typeof (String), _EmailHandler.SMTPPassword));
                QueueSettingForUpload(new CPluginVariable(@"Custom HTML Addition", typeof (String), _EmailHandler.CustomHTMLAddition));
                QueueSettingForUpload(new CPluginVariable(@"Extra Recipient Email Addresses", typeof(String[]), _EmailHandler.RecipientEmails.ToArray()));
                QueueSettingForUpload(new CPluginVariable(@"Only Send Report Emails When Admins Offline", typeof(Boolean), _emailReportsOnlyWhenAdminless));
                QueueSettingForUpload(new CPluginVariable(@"Use Metabans?", typeof (Boolean), _useMetabans));
                QueueSettingForUpload(new CPluginVariable(@"Metabans API Key", typeof (String), _metabansAPIKey));
                QueueSettingForUpload(new CPluginVariable(@"Metabans Username", typeof (String), _metabansUsername));
                QueueSettingForUpload(new CPluginVariable(@"On-Player-Muted Message", typeof (String), _MutedPlayerMuteMessage));
                QueueSettingForUpload(new CPluginVariable(@"On-Player-Killed Message", typeof (String), _MutedPlayerKillMessage));
                QueueSettingForUpload(new CPluginVariable(@"On-Player-Kicked Message", typeof (String), _MutedPlayerKickMessage));
                QueueSettingForUpload(new CPluginVariable(@"# Chances to give player before kicking", typeof(Int32), _MutedPlayerChances));
                QueueSettingForUpload(new CPluginVariable(@"Ignore commands for mute enforcement", typeof(Boolean), _MutedPlayerIgnoreCommands));
                QueueSettingForUpload(new CPluginVariable(@"Ticket Window High", typeof (Int32), _TeamSwapTicketWindowHigh));
                QueueSettingForUpload(new CPluginVariable(@"Ticket Window Low", typeof(Int32), _TeamSwapTicketWindowLow));
                QueueSettingForUpload(new CPluginVariable(@"Enable Admin Assistants", typeof(Boolean), _EnableAdminAssistants));
                QueueSettingForUpload(new CPluginVariable(@"Enable Admin Assistant Perk", typeof (Boolean), _EnableAdminAssistantPerk));
                QueueSettingForUpload(new CPluginVariable(@"Minimum Confirmed Reports Per Month", typeof (Int32), _MinimumRequiredMonthlyReports));
                QueueSettingForUpload(new CPluginVariable(@"Yell display time seconds", typeof (Int32), _YellDuration));
                QueueSettingForUpload(new CPluginVariable(@"Pre-Message List", typeof (String), CPluginVariable.EncodeStringArray(_PreMessageList.ToArray())));
                QueueSettingForUpload(new CPluginVariable(@"Require Use of Pre-Messages", typeof(Boolean), _RequirePreMessageUse));
                QueueSettingForUpload(new CPluginVariable(@"Use first spawn message", typeof(Boolean), _UseFirstSpawnMessage));
                QueueSettingForUpload(new CPluginVariable(@"First spawn message text", typeof(String), _FirstSpawnMessage));
                QueueSettingForUpload(new CPluginVariable(@"Use First Spawn Reputation and Infraction Message", typeof(Boolean), _useFirstSpawnRepMessage));
                QueueSettingForUpload(new CPluginVariable(@"SpamBot Enable", typeof(Boolean), _spamBotEnabled));
                QueueSettingForUpload(new CPluginVariable(@"SpamBot Say List", typeof(String), CPluginVariable.EncodeStringArray(_spamBotSayList.ToArray())));
                QueueSettingForUpload(new CPluginVariable(@"SpamBot Say Delay Seconds", typeof(Int32), _spamBotSayDelaySeconds));
                QueueSettingForUpload(new CPluginVariable(@"SpamBot Yell List", typeof(String), CPluginVariable.EncodeStringArray(_spamBotYellList.ToArray())));
                QueueSettingForUpload(new CPluginVariable(@"SpamBot Yell Delay Seconds", typeof(Int32), _spamBotYellDelaySeconds));
                QueueSettingForUpload(new CPluginVariable(@"SpamBot Tell List", typeof(String), CPluginVariable.EncodeStringArray(_spamBotTellList.ToArray())));
                QueueSettingForUpload(new CPluginVariable(@"SpamBot Tell Delay Seconds", typeof(Int32), _spamBotTellDelaySeconds));
                QueueSettingForUpload(new CPluginVariable(@"Exclude Admins and Whitelist from Spam", typeof(Boolean), _spamBotExcludeAdminsAndWhitelist));
                QueueSettingForUpload(new CPluginVariable(@"Display Admin Name in Kick and Ban Announcement", typeof(Boolean), _ShowAdminNameInAnnouncement));
                QueueSettingForUpload(new CPluginVariable(@"Display New Player Announcement", typeof(Boolean), _ShowNewPlayerAnnouncement));
                QueueSettingForUpload(new CPluginVariable(@"Display Player Name Change Announcement", typeof(Boolean), _ShowPlayerNameChangeAnnouncement));
                QueueSettingForUpload(new CPluginVariable(@"Display Targeted Player Left Notification", typeof(Boolean), _ShowTargetedPlayerLeftNotification));
                QueueSettingForUpload(new CPluginVariable(@"Inform players of reports against them", typeof(Boolean), _InformReportedPlayers));
                QueueSettingForUpload(new CPluginVariable(@"Inform reputable players and admins of admin joins", typeof(Boolean), _InformReputablePlayersOfAdminJoins));
                QueueSettingForUpload(new CPluginVariable(@"Player Inform Exclusion Strings", typeof(String), CPluginVariable.EncodeStringArray(_PlayerInformExclusionStrings)));
                QueueSettingForUpload(new CPluginVariable(@"Disable Automatic Updates", typeof(Boolean), _automaticUpdatesDisabled));
                QueueSettingForUpload(new CPluginVariable(@"Disable Version Tracking - Required For TEST Builds", typeof(Boolean), _versionTrackingDisabled));
                QueueSettingForUpload(new CPluginVariable(@"AFK System Enable", typeof(Boolean), _AFKManagerEnable));
                QueueSettingForUpload(new CPluginVariable(@"AFK Ignore Chat", typeof(Boolean), _AFKIgnoreChat));
                QueueSettingForUpload(new CPluginVariable(@"AFK Auto-Kick Enable", typeof(Boolean), _AFKAutoKickEnable));
                QueueSettingForUpload(new CPluginVariable(@"AFK Trigger Minutes", typeof(Double), _AFKTriggerDurationMinutes));
                QueueSettingForUpload(new CPluginVariable(@"AFK Minimum Players", typeof(Int32), _AFKTriggerMinimumPlayers));
                QueueSettingForUpload(new CPluginVariable(@"AFK Ignore User List", typeof(Boolean), _AFKIgnoreUserList));
                QueueSettingForUpload(new CPluginVariable(@"AFK Ignore Roles", typeof(String), CPluginVariable.EncodeStringArray(_AFKIgnoreRoles))); 
                QueueSettingForUpload(new CPluginVariable(@"Ping Enforcer Enable", typeof(Boolean), _pingEnforcerSystemEnable));
                QueueSettingForUpload(new CPluginVariable(@"Ping Moving Average Duration sec", typeof(Double), _pingMovingAverageDurationSeconds));
                QueueSettingForUpload(new CPluginVariable(@"Ping Kick Low Population Trigger ms", typeof(Double), _pingEnforcerLowTriggerMS));
                QueueSettingForUpload(new CPluginVariable(@"Ping Kick Medium Population Trigger ms", typeof(Double), _pingEnforcerMedTriggerMS));
                QueueSettingForUpload(new CPluginVariable(@"Ping Kick High Population Trigger ms", typeof(Double), _pingEnforcerHighTriggerMS));
                QueueSettingForUpload(new CPluginVariable(@"Ping Kick Full Population Trigger ms", typeof(Double), _pingEnforcerFullTriggerMS));
                QueueSettingForUpload(new CPluginVariable(@"Ping Kick Minimum Players", typeof(Int32), _pingEnforcerTriggerMinimumPlayers));
                QueueSettingForUpload(new CPluginVariable(@"Kick Missing Pings", typeof(Boolean), _pingEnforcerKickMissingPings));
                QueueSettingForUpload(new CPluginVariable(@"Attempt Manual Ping when Missing", typeof(Boolean), _attemptManualPingWhenMissing));
                QueueSettingForUpload(new CPluginVariable(@"Ping Kick Ignore User List", typeof(Boolean), _pingEnforcerIgnoreUserList));
                QueueSettingForUpload(new CPluginVariable(@"Ping Kick Ignore Roles", typeof(String), CPluginVariable.EncodeStringArray(_pingEnforcerIgnoreRoles)));
                QueueSettingForUpload(new CPluginVariable(@"Ping Kick Message Prefix", typeof(String), _pingEnforcerMessagePrefix));
                QueueSettingForUpload(new CPluginVariable(@"Commander Manager Enable", typeof(Boolean), _CMDRManagerEnable));
                QueueSettingForUpload(new CPluginVariable(@"Minimum Players to Allow Commanders", typeof(Int32), _CMDRMinimumPlayers));
                QueueSettingForUpload(new CPluginVariable(@"Player Lock Manual Duration Minutes", typeof(Double), _playerLockingManualDuration));
                QueueSettingForUpload(new CPluginVariable(@"Automatically Lock Players on Admin Action", typeof(Boolean), _playerLockingAutomaticLock));
                QueueSettingForUpload(new CPluginVariable(@"Player Lock Automatic Duration Minutes", typeof(Double), _playerLockingAutomaticDuration));
                QueueSettingForUpload(new CPluginVariable(@"Display Ticket Rates in Procon Chat", typeof(Boolean), _DisplayTicketRatesInProconChat));
                QueueSettingForUpload(new CPluginVariable(@"Surrender Vote Enable", typeof(Boolean), _surrenderVoteEnable));
                QueueSettingForUpload(new CPluginVariable(@"Percentage Votes Needed for Surrender", typeof(Double), _surrenderVoteMinimumPlayerPercentage));
                QueueSettingForUpload(new CPluginVariable(@"Minimum Player Count to Enable Surrender", typeof(Int32), _surrenderVoteMinimumPlayerCount));
                QueueSettingForUpload(new CPluginVariable(@"Minimum Ticket Gap to Surrender", typeof(Int32), _surrenderVoteMinimumTicketGap));
                QueueSettingForUpload(new CPluginVariable(@"Enable Required Ticket Rate Gap to Surrender", typeof(Boolean), _surrenderVoteTicketRateGapEnable));
                QueueSettingForUpload(new CPluginVariable(@"Minimum Ticket Rate Gap to Surrender", typeof(Double), _surrenderVoteMinimumTicketRateGap));
                QueueSettingForUpload(new CPluginVariable(@"Surrender Vote Timeout Enable", typeof(Boolean), _surrenderVoteTimeoutEnable));
                QueueSettingForUpload(new CPluginVariable(@"Surrender Vote Timeout Minutes", typeof(Int32), _surrenderVoteTimeoutMinutes));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Enable", typeof(Boolean), _surrenderAutoEnable));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Use Optimal Values for Metro Conquest", typeof(Boolean), _surrenderAutoUseMetroValues));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Use Optimal Values for Locker Conquest", typeof(Boolean), _surrenderAutoUseLockerValues));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Use Adjusted Ticket Rates", typeof(Boolean), _surrenderAutoUseAdjustedTicketRates));
                QueueSettingForUpload(new CPluginVariable(@"Nuke Winning Team Instead of Surrendering Losing Team", typeof(Boolean), _surrenderAutoNukeWinning));
                QueueSettingForUpload(new CPluginVariable(@"Start Surrender Vote Instead of Surrendering Losing Team", typeof(Boolean), _surrenderAutoTriggerVote));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Minimum Ticket Gap", typeof(Int32), _surrenderAutoMinimumTicketGap));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Losing Team Rate Window Max", typeof(Double), _surrenderAutoLosingRateMax));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Losing Team Rate Window Min", typeof(Double), _surrenderAutoLosingRateMin));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Winning Team Rate Window Max", typeof(Double), _surrenderAutoWinningRateMax));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Winning Team Rate Window Min", typeof(Double), _surrenderAutoWinningRateMin));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Message", typeof(String), _surrenderAutoMessage));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Nuke Message", typeof(String), _surrenderAutoNukeMessage));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Trigger Count to Surrender", typeof(Int32), _surrenderAutoTriggerCountToSurrender));
                QueueSettingForUpload(new CPluginVariable(@"Auto-Surrender Minimum Players", typeof(Int32), _surrenderAutoMinimumPlayers));
                DebugWrite("uploadAllSettings finished!", 6);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing all settings for upload.", e));
            }
        }

        private void UploadSetting(CPluginVariable var) {
            DebugWrite("uploadSetting starting!", 7);
            //Make sure database connection active
            if (HandlePossibleDisconnect() || !_settingsFetched) {
                return;
            }
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        //Check for length too great
                        if (var.Value.Length > 2999) {
                            ConsoleError("Unable to upload setting, length of setting too great. Really dude? It's 3000+ chars. This is battlefield, not a book club.");
                            return;
                        }
                        DebugWrite(var.Value, 7);
                        //Set the insert command structure
                        command.CommandText = @"
                        INSERT INTO `" + _mySqlSchemaName + @"`.`adkats_settings` 
                        (
                            `server_id`, 
                            `setting_name`, 
                            `setting_type`, 
                            `setting_value`
                        ) 
                        VALUES 
                        ( 
                            @server_id,
                            @setting_name, 
                            @setting_type, 
                            @setting_value
                        ) 
                        ON DUPLICATE KEY 
                        UPDATE 
                            `setting_value` = @setting_value";
                        command.Parameters.AddWithValue("@server_id", _serverInfo.ServerID);
                        command.Parameters.AddWithValue("@setting_name", var.Name);
                        command.Parameters.AddWithValue("@setting_type", var.Type);
                        command.Parameters.AddWithValue("@setting_value", var.Value);
                        //Attempt to execute the query
                        if (SafeExecuteNonQuery(command) > 0) {
                            DebugWrite("Setting " + var.Name + " pushed to database", 7);
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while uploading setting to database.", e));
            }

            DebugWrite("uploadSetting finished!", 7);
        }

        private void FetchSettings(long serverID, Boolean verbose) {
            DebugWrite("fetchSettings starting!", 6);
            Boolean success = false;
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                //Success fetching settings
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        String sql = @"
                        SELECT  
                            `setting_name`, 
                            `setting_type`, 
                            `setting_value`
                        FROM 
                            `" + _mySqlSchemaName + @"`.`adkats_settings` 
                        WHERE 
                            `server_id` = " + serverID;
                        command.CommandText = sql;
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            //Grab the settings
                            while (reader.Read()) {
                                success = true;
                                //Create as variable in case needed later
                                var var = new CPluginVariable(reader.GetString("setting_name"), reader.GetString("setting_type"), reader.GetString("setting_value"));
                                SetPluginVariable(var.Name, var.Value);
                            }
                            if (success) {
                                _lastDbSettingFetch = UtcDbTime();
                                UpdateSettingPage();
                            }
                            else if (verbose) {
                                ConsoleError("Settings could not be loaded. Server " + serverID + " invalid.");
                            }
                            UploadAllSettings();
                            _settingsFetched = true;
                            _settingImportID = _serverInfo.ServerID;
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching settings from database.", e));
            }
            DebugWrite("fetchSettings finished!", 6);
        }

        private void UploadCommand(AdKatsCommand aCommand) {
            DebugWrite("uploadCommand starting!", 6);

            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        //Set the insert command structure
                        command.CommandText = @"
                        INSERT INTO 
                        `" + _mySqlSchemaName + @"`.`adkats_commands` 
                        (
	                        `command_id`,
	                        `command_active`,
	                        `command_key`,
	                        `command_logging`,
	                        `command_name`,
	                        `command_text`,
                            `command_playerInteraction`
                        ) 
                        VALUES 
                        (
	                        @command_id,
	                        @command_active,
	                        @command_key,
	                        @command_logging,
	                        @command_name,
	                        @command_text,
                            @command_playerInteraction
                        ) 
                        ON DUPLICATE KEY 
                        UPDATE 
	                        `command_active` = @command_active, 
	                        `command_logging` = @command_logging, 
	                        `command_name` = @command_name, 
	                        `command_text` = @command_text,
                            `command_playerInteraction` = @command_playerInteraction";

                        //Fill the command
                        command.Parameters.AddWithValue("@command_id", aCommand.command_id);
                        command.Parameters.AddWithValue("@command_active", aCommand.command_active.ToString());
                        command.Parameters.AddWithValue("@command_key", aCommand.command_key);
                        command.Parameters.AddWithValue("@command_logging", aCommand.command_logging.ToString());
                        command.Parameters.AddWithValue("@command_name", aCommand.command_name);
                        command.Parameters.AddWithValue("@command_text", aCommand.command_text);
                        command.Parameters.AddWithValue("@command_playerInteraction", aCommand.command_playerInteraction);

                        //Get reference to the command in case of error
                        //Attempt to execute the query
                        if (SafeExecuteNonQuery(command) > 0) {
                        }
                    }
                }

                DebugWrite("uploadCommand finished!", 6);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Unexpected error uploading command.", e));
            }
        }

        private List<AdKatsPlayer> FetchAdminSoldiers() {
            var adminSoldiers = new List<AdKatsPlayer>();
            //Loop over the user list
            lock (_userCache) {
                foreach (AdKatsUser user in _userCache.Values.Where(user => UserIsAdmin(user)))
                {
                    adminSoldiers.AddRange(user.soldierDictionary.Values);
                }
            }
            return adminSoldiers;
        }

        private List<AdKatsPlayer> FetchOnlineAdminSoldiers() {
            var onlineAdminSoldiers = new Dictionary<String, AdKatsPlayer>();
            foreach (AdKatsPlayer aPlayer in FetchAdminSoldiers()) {
                AdKatsPlayer adminSoldier;
                if (_PlayerDictionary.TryGetValue(aPlayer.player_name, out adminSoldier)) {
                    if (!onlineAdminSoldiers.ContainsKey(aPlayer.player_name)) {
                        onlineAdminSoldiers.Add(adminSoldier.player_name, adminSoldier);
                    }
                }
            }
            return onlineAdminSoldiers.Values.ToList();
        }

        private List<AdKatsPlayer> FetchOnlineNonAdminSoldiers() {
            List<AdKatsPlayer> nonAdminSoldiers = new List<AdKatsPlayer>();
            try {
                nonAdminSoldiers.AddRange(_PlayerDictionary.Values.Where(aPlayer => !PlayerIsAdmin(aPlayer)));
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching online non-admin soldiers", e));
            }

            return nonAdminSoldiers;
        } 

        private List<AdKatsPlayer> FetchElevatedSoldiers() {
            var elevatedSoldiers = new List<AdKatsPlayer>();
            //Loop over the user list
            lock (_userCache) {
                foreach (AdKatsUser aUser in _userCache.Values.Where(user => !UserIsAdmin(user) && user.user_role.role_key != "guest_default"))
                {
                    elevatedSoldiers.AddRange(aUser.soldierDictionary.Values);
                }
            }
            return elevatedSoldiers;
        }

        private List<AdKatsPlayer> FetchSoldiersOfRole(AdKatsRole aRole) {
            var roleSoldiers = new List<AdKatsPlayer>();
            //Loop over the user list
            lock (_userCache) {
                foreach (AdKatsUser user in _userCache.Values.Where(user => user.user_role.role_key == aRole.role_key)) {
                    roleSoldiers.AddRange(user.soldierDictionary.Values);
                }
            }
            return roleSoldiers;
        }

        private List<AdKatsPlayer> FetchAllUserSoldiers() {
            var userSoldiers = new List<AdKatsPlayer>();
            //Loop over the user list
            lock (_userCache) {
                foreach (AdKatsUser user in _userCache.Values.Where(aUser => aUser.user_role.role_key != "guest_default"))
                {
                    userSoldiers.AddRange(user.soldierDictionary.Values);
                }
            }
            return userSoldiers;
        }

        private Boolean HandleRecordUpload(AdKatsRecord record) {
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                record.record_exception = new AdKatsException("Database not connected.");
                return true;
            }
            try {
                DebugWrite("DBCOMM: Entering handle record upload", 5);
                if (record.record_id != -1 || record.record_action_executed) {
                    //Record already has a record ID, or action has already been taken, it can only be updated
                    if (record.command_type.command_logging != AdKatsCommand.CommandLogging.Ignore &&
                        record.command_type.command_logging != AdKatsCommand.CommandLogging.Unable && 
                        !record.record_orchestrate)
                    {
                        if (record.record_exception == null) {
                            //Only call update if the record contained no errors
                            DebugWrite("DBCOMM: UPDATING record for " + record.command_type, 5);
                            //Update Record
                            UpdateRecord(record);
                            return false;
                        }
                        DebugWrite("DBCOMM: " + record.command_type + " record contained errors, skipping UPDATE", 4);
                    }
                    else {
                        DebugWrite("DBCOMM: Skipping record UPDATE for " + record.command_type, 5);
                    }
                }
                else {
                    DebugWrite("DBCOMM: Record needs full upload, checking.", 5);
                    //No record ID. Perform full upload
                    switch (record.command_type.command_key) {
                        //TODO: Add ability for multiple targets
                        case "player_punish":
                            //Upload for punish is required
                            if (CanPunish(record, 20)) {
                                //Check if the punish will be Double counted
                                Boolean iroStatus = _IROActive && FetchIROStatus(record);
                                if (iroStatus) {
                                    record.isIRO = true;
                                    //Upload record twice
                                    DebugWrite("DBCOMM: UPLOADING IRO Punish", 5); //IRO - Immediate Repeat Offence
                                    UploadRecord(record);
                                    UploadRecord(record);
                                }
                                else {
                                    //Upload record once
                                    DebugWrite("DBCOMM: UPLOADING Punish", 5);
                                    UploadRecord(record);
                                }
                            }
                            else {
                                SendMessageToSource(record, record.GetTargetNames() + " already acted on in the last 20 seconds.");
                                return false;
                            }
                            break;
                        //TODO: Add ability for multiple targets
                        case "player_forgive":
                            //Upload for forgive is required
                            //No restriction on forgives/minute
                            DebugWrite("DBCOMM: UPLOADING Forgive", 5);
                            UploadRecord(record);
                            break;
                        default:
                            //Case for any other command
                            //Check logging setting for record command type
                            if (record.command_type.command_logging != AdKatsCommand.CommandLogging.Ignore && 
                                record.command_type.command_logging != AdKatsCommand.CommandLogging.Unable) {
                                DebugWrite("UPLOADING record for " + record.command_type, 5);
                                //Upload Record
                                UploadRecord(record);
                            }
                            else {
                                DebugWrite("Skipping record UPLOAD for " + record.command_type, 6);
                            }
                            break;
                    }
                }
            }
            catch (Exception e) {
                record.record_exception = HandleException(new AdKatsException("Error while handling record upload.", e));
            }
            return true;
        }

        private Boolean UploadRecord(AdKatsRecord record) {
            Boolean success = true;
            //If record has multiple targets, create a new record for each target
            if (record.TargetPlayersLocal.Any())
            {
                record.TargetInnerRecords.Clear();
                foreach (AdKatsPlayer aPlayer in record.TargetPlayersLocal)
                {
                    var aRecord = new AdKatsRecord
                    {
                        isAliveChecked = record.isAliveChecked,
                        isConfirmed = record.isConfirmed,
                        isContested = record.isContested,
                        isDebug = record.isDebug,
                        isIRO = record.isIRO,
                        record_source = record.record_source,
                        server_id = record.server_id,
                        command_type = record.command_type,
                        command_action = record.command_action,
                        command_numeric = record.command_numeric,
                        target_name = aPlayer.player_name,
                        target_player = aPlayer,
                        source_name = record.source_name,
                        source_player = record.source_player,
                        record_message = record.record_message,
                        record_action_executed = record.record_action_executed,
                        record_time = record.record_time
                    };
                    record.TargetInnerRecords.Add(aRecord);
                    if (!UploadInnerRecord(aRecord)) {
                        success = false;
                    }
                }
            }
            else
            {
                success = UploadInnerRecord(record);
            }
            return success;
        }

        private Boolean UploadInnerRecord(AdKatsRecord record)
        {
            DebugWrite("uploadRecord starting!", 6);

            Boolean success = false;
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                record.record_exception = new AdKatsException("Database not connected.");
                return false;
            }
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        //Decide which table the record should be added to
                        String tablename = (record.isDebug) ? ("`adkats_records_debug`") : ("`adkats_records_main`");
                        //Set the insert command structure
                        if (record.record_held)
                        {
                            command.CommandText = @"
                            INSERT INTO " + tablename + @"
                            (
                                `server_id`, 
                                `command_type`, 
                                `command_action`, 
                                `command_numeric`, 
                                `target_name`, 
                                `target_id`, 
                                `source_name`, 
                                `source_id`, 
                                `record_message`, 
                                `record_time`, 
                                `adkats_read`
                            ) 
                            VALUES 
                            ( 
                                @server_id, 
                                @command_type, 
                                @command_action,
                                @command_numeric,
                                @target_name, 
                                @target_id, 
                                @source_name, 
                                @source_id, 
                                @record_message, 
                                @record_time, 
                                @record_orchestrate
                            )";
                            command.Parameters.AddWithValue("@record_time", record.record_time);
                        }
                        else
                        {
                            command.CommandText = @"
                            INSERT INTO " + tablename + @"
                            (
                                `server_id`, 
                                `command_type`, 
                                `command_action`, 
                                `command_numeric`, 
                                `target_name`, 
                                `target_id`, 
                                `source_name`, 
                                `source_id`, 
                                `record_message`, 
                                `record_time`, 
                                `adkats_read`
                            ) 
                            VALUES 
                            ( 
                                @server_id, 
                                @command_type, 
                                @command_action,
                                @command_numeric,
                                @target_name, 
                                @target_id, 
                                @source_name, 
                                @source_id, 
                                @record_message, 
                                UTC_TIMESTAMP(), 
                                @adkats_read
                            )";
                        }

                        //Fill the command
                        if (record.server_id == 0)
                        {
                            ConsoleError("Record server ID was invalid, unable to continue.");
                            return false;
                        }
                        command.Parameters.AddWithValue("@server_id", record.server_id);
                        if (record.command_type == null)
                        {
                            ConsoleError("Command type was null in uploadRecord, unable to continue.");
                            return false;
                        }
                        command.Parameters.AddWithValue("@command_type", record.command_type.command_id);
                        if (record.command_action == null)
                        {
                            record.command_action = record.command_type;
                        }
                        command.Parameters.AddWithValue("@command_action", record.command_action.command_id);
                        command.Parameters.AddWithValue("@command_numeric", record.command_numeric);
                        String tName = "NoNameTarget";
                        if (!String.IsNullOrEmpty(record.target_name))
                        {
                            tName = record.target_name;
                        }
                        if (record.target_player != null)
                        {
                            if (!String.IsNullOrEmpty(record.target_player.player_name))
                            {
                                tName = record.target_player.player_name;
                            }
                            if (record.target_player.player_id <= 0)
                            {
                                ConsoleError("Target ID invalid when uploading record. Unable to complete.");
                                record.record_exception = new AdKatsException("Target ID invalid when uploading record. Unable to complete.");
                                SendMessageToSource(record, "Target ID invalid when uploading record. Unable to complete.");
                                FinalizeRecord(record);
                                return false;
                            }
                            command.Parameters.AddWithValue("@target_id", record.target_player.player_id);
                        }
                        else
                        {
                            command.Parameters.AddWithValue("@target_id", null);
                        }
                        command.Parameters.AddWithValue("@target_name", tName);
                        String sName = "NoNameSource";
                        if (!String.IsNullOrEmpty(record.source_name))
                        {
                            sName = record.source_name;
                        }
                        if (record.source_player != null)
                        {
                            if (!String.IsNullOrEmpty(record.source_player.player_name))
                            {
                                sName = record.source_player.player_name;
                            }
                            if (record.source_player.player_id <= 0)
                            {
                                ConsoleError("Source ID invalid when uploading record. Unable to complete.");
                                record.record_exception = new AdKatsException("Source ID invalid when uploading record. Unable to complete.");
                                SendMessageToSource(record, "Source ID invalid when uploading record. Unable to complete.");
                                FinalizeRecord(record);
                                return false;
                            }
                            command.Parameters.AddWithValue("@source_id", record.source_player.player_id);
                        }
                        else
                        {
                            command.Parameters.AddWithValue("@source_id", null);
                        }
                        command.Parameters.AddWithValue("@source_name", sName);

                        String messageIRO = record.record_message + ((record.isIRO) ? (" [IRO]") : (""));
                        //Trim to 500 characters (Should only hit this limit when processing error messages)
                        messageIRO = messageIRO.Length <= 500 ? messageIRO : messageIRO.Substring(0, 500);
                        command.Parameters.AddWithValue("@record_message", messageIRO);

                        //Orchestration of other AdKats instances
                        if (record.record_orchestrate)
                        {
                            command.Parameters.AddWithValue("@adkats_read", "N");
                        }
                        else
                        {
                            command.Parameters.AddWithValue("@adkats_read", "Y");
                        }

                        //Get reference to the command in case of error
                        //Attempt to execute the query
                        if (SafeExecuteNonQuery(command) > 0)
                        {
                            success = true;
                            record.record_id = command.LastInsertedId;
                        }
                    }
                }

                if (success)
                {
                    DebugWrite(record.command_action.command_key + " upload for " + record.GetTargetNames() + " by " + record.GetSourceName() + " SUCCESSFUL!", 3);
                }
                else
                {
                    record.record_exception = new AdKatsException("Unknown error uploading record.");
                    HandleException(record.record_exception);
                }

                DebugWrite("uploadRecord finished!", 6);
                return success;
            }
            catch (Exception e)
            {
                record.record_exception = new AdKatsException("Unexpected error uploading Record.", e);
                HandleException(record.record_exception);
                return false;
            }
        }

        private Boolean UploadStatistic(AdKatsStatistic aStat)
        {
            DebugWrite("UploadStatistic starting!", 6);

            Boolean success = false;
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                return false;
            }
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        //Set the insert command structure
                        command.CommandText = @"
                        INSERT INTO 
                            `adkats_statistics`
                        (
                            `server_id`, 
                            `round_id`, 
                            `stat_type`, 
                            `target_name`, 
                            `target_id`, 
                            `stat_value`, 
                            `stat_comment`, 
                            `stat_time` 
                        ) 
                        VALUES 
                        ( 
                            @server_id, 
                            @round_id, 
                            @stat_type, 
                            @target_name, 
                            @target_id, 
                            @stat_value, 
                            @stat_comment, 
                            @stat_time 
                        )";

                        //Fill the command
                        if (aStat.server_id == 0)
                        {
                            HandleException(new AdKatsException("Statistic server ID was invalid when uploading, unable to continue."));
                            return false;
                        }
                        command.Parameters.AddWithValue("@server_id", aStat.server_id);
                        if (aStat.round_id == 0)
                        {
                            HandleException(new AdKatsException("Statistic round ID was invalid when uploading, unable to continue."));
                            return false;
                        }
                        command.Parameters.AddWithValue("@round_id", aStat.round_id);
                        command.Parameters.AddWithValue("@stat_type", aStat.stat_type.ToString());
                        String tName = null;
                        if (aStat.target_player != null)
                        {
                            if (!String.IsNullOrEmpty(aStat.target_player.player_name))
                            {
                                tName = aStat.target_player.player_name;
                            }
                            command.Parameters.AddWithValue("@target_id", aStat.target_player.player_id);
                        }
                        else
                        {
                            command.Parameters.AddWithValue("@target_id", null);
                        }
                        if (!String.IsNullOrEmpty(tName)) 
                        {
                            command.Parameters.AddWithValue("@target_name", tName);
                        }
                        else
                        {
                            if (!String.IsNullOrEmpty(aStat.target_name))
                            {
                                command.Parameters.AddWithValue("@target_name", aStat.target_name);
                            }
                            else
                            {
                                HandleException(new AdKatsException("Statistic target name null or empty when uploading, unable to continue."));
                                return false;
                            }
                        }
                        command.Parameters.AddWithValue("@stat_value", aStat.stat_value);
                        command.Parameters.AddWithValue("@stat_comment", aStat.stat_comment);
                        command.Parameters.AddWithValue("@stat_time", aStat.stat_time);

                        //Get reference to the command in case of error
                        //Attempt to execute the query
                        if (SafeExecuteNonQuery(command) > 0)
                        {
                            success = true;
                            aStat.stat_id = command.LastInsertedId;
                        }
                    }
                }

                if (success)
                {
                    DebugWrite(aStat.stat_type + " stat upload for " + aStat.target_name + " SUCCESSFUL!", 3);
                }
                else
                {
                    HandleException(new AdKatsException("Unknown error uploading statistic."));
                }

                DebugWrite("UploadStatistic finished!", 6);
                return success;
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Unexpected error uploading statistic.", e));
                return false;
            }
        }

        private Boolean UploadChatLog(AdKatsChatMessage messageObject)
        {
            this.DebugWrite("UploadChatLog starting!", 6);
            Boolean success = false;
            if (!_threadsReady)
            {
                return success;
            }
            //comorose BF4 chat handle
            if (messageObject.OriginalMessage.Contains("ID_CHAT") ||
                messageObject.OriginalMessage.Contains("AdKatsInstanceCheck"))
            {
                success = true;
                return success;
            }
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                this.HandleException(new AdKatsException("Database not connected on chat upload."));
                return success;
            }
            //Server spam check
            if (!_PostStatLoggerChatManually_PostServerChatSpam && messageObject.Speaker == "Server") {
                success = true;
                return success;
            }
            //Ignore command check
            if (_PostStatLoggerChatManually_IgnoreCommands &&
                (messageObject.OriginalMessage.StartsWith("@") || 
                messageObject.OriginalMessage.StartsWith("!") || 
                messageObject.OriginalMessage.StartsWith(".") || 
                messageObject.OriginalMessage.StartsWith("/")))
            {
                success = true;
                return success;
            }

            MySqlCommand commandAttempt = null;
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        //Set the insert command structure
                        command.CommandText = @"INSERT INTO `tbl_chatlog` 
                        (
                            `logDate`, 
                            `ServerID`, 
                            `logSubset`, 
                            `logPlayerID`, 
                            `logSoldierName`, 
                            `logMessage`
                        ) 
                        VALUES 
                        (
                            UTC_TIMESTAMP(), 
                            @server_id, 
                            @log_subset, 
                            @log_player_id, 
                            @log_player_name, 
                            @log_message
                        )";

                        //Fetch the player from player dictionary
                        AdKatsPlayer player = null;
                        if (_PlayerDictionary.TryGetValue(messageObject.Speaker, out player))
                        {
                            this.DebugWrite("Player found for chat log upload.", 5);
                        }

                        //Fill the log
                        command.Parameters.AddWithValue("@server_id", _serverInfo.ServerID);
                        command.Parameters.AddWithValue("@log_subset", messageObject.Subset.ToString());
                        if (player != null && player.player_id > 0)
                        {
                            command.Parameters.AddWithValue("@log_player_id", player.player_id);
                        }
                        else
                        {
                            command.Parameters.AddWithValue("@log_player_id", null);
                        }
                        command.Parameters.AddWithValue("@log_player_name", messageObject.Speaker);
                        //Trim to 255 characters
                        String logMessage = messageObject.Message.Length <= 255 ? messageObject.OriginalMessage : messageObject.OriginalMessage.Substring(0, 255);
                        command.Parameters.AddWithValue("@log_message", logMessage);

                        //Get reference to the command in case of error
                        commandAttempt = command;
                        //Attempt to execute the query
                        if (SafeExecuteNonQuery(command) > 0)
                        {
                            success = true;
                        }
                    }
                }
                if (success)
                {
                    DebugWrite("Chat upload for " + messageObject.Speaker + " SUCCESSFUL!", 5);
                }
                else
                {
                    this.HandleException(new AdKatsException("Error uploading chat log. Success not reached."));
                    return success;
                }
                DebugWrite("UploadChatLog finished!", 6);
                return success;
            }
            catch (Exception e)
            {
                this.HandleException(new AdKatsException("Unexpected error uploading chat log.", e));
                return success;
            }
        }

        private void UpdateRecordEndPointReputations(AdKatsRecord aRecord) {
            if (aRecord.source_player != null && aRecord.source_player.player_id > 0) {
                UpdatePlayerReputation(aRecord.source_player, true);
            }
            if (aRecord.target_player != null && aRecord.target_player.player_id > 0) {
                UpdatePlayerReputation(aRecord.target_player, true);
            }
            if (aRecord.TargetPlayersLocal != null) {
                foreach (AdKatsPlayer aPlayer in aRecord.TargetPlayersLocal) {
                    UpdatePlayerReputation(aPlayer, true);
                }
            }
        }

        private void UpdatePlayerReputation(AdKatsPlayer aPlayer, Boolean informPlayer) {
            try {
                if (aPlayer == null) {
                    ConsoleError("Attempted to update reputation of invalid player.");
                    return;
                }
                if (_commandSourceReputationDictionary == null || 
                    !_commandSourceReputationDictionary.Any() ||
                    _commandTargetReputationDictionary == null || 
                    !_commandTargetReputationDictionary.Any()) {
                    DebugWrite("Reputation dictionaries not populated. Can't update reputation for " + aPlayer.GetVerboseName() + ".", 4);
                }
                double sourceReputation = 0.0;
                double targetReputation = 0.0;
                double pointReputation = 0;
                var recentPunishments = FetchRecentRecords(aPlayer.player_id, GetCommandByKey("player_punish").command_id, 1000, 1000, true, false);
                foreach (var punishment in recentPunishments) {
                    var timeSince = UtcDbTime() - punishment.record_time;
                    if (timeSince.TotalDays < 50) {
                        pointReputation -= 20 * ((50 - timeSince.TotalDays) / 50);
                    }
                }
                var recentForgives = FetchRecentRecords(aPlayer.player_id, GetCommandByKey("player_forgive").command_id, 1000, 1000, true, false);
                foreach (var forgive in recentForgives)
                {
                    var timeSince = UtcDbTime() - forgive.record_time;
                    if (timeSince.TotalDays < 50)
                    {
                        pointReputation += 20 * ((50 - timeSince.TotalDays) / 50);
                    }
                }
                if (pointReputation > 0) {
                    pointReputation = 0;
                }
                targetReputation = pointReputation;
                double totalReputation = 0;
                double totalReputationConstrained = 0;
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
	                        command_type,
	                        command_action,
	                        count(record_id) command_count
                        FROM
	                        adkats_records_main
                        WHERE
	                        source_id = @player_id
                        AND
	                        target_name <> source_name
                        GROUP BY command_type, command_action";

                        command.Parameters.AddWithValue("player_id", aPlayer.player_id);
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            while (reader.Read()) {
                                String typeAction = reader.GetInt32("command_type") + "|" + reader.GetInt32("command_action");
                                Double command_count = reader.GetDouble("command_count");
                                Double weight = 0;
                                if (_commandSourceReputationDictionary.TryGetValue(typeAction, out weight)) {
                                    sourceReputation += (weight * command_count);
                                }
                                else {
                                    ConsoleError("Unable to find source weight for type|action: " + typeAction);
                                }
                            }
                        }
                    }
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
	                        command_type,
	                        command_action,
	                        count(record_id) command_count
                        FROM
	                        adkats_records_main
                        WHERE
	                        target_id = @player_id
                        AND
	                        target_name <> source_name
                        GROUP BY command_type, command_action";
                        command.Parameters.AddWithValue("player_id", aPlayer.player_id);
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            while (reader.Read()) {
                                String typeAction = reader.GetInt32("command_type") + "|" + reader.GetInt32("command_action");
                                Double command_count = reader.GetDouble("command_count");
                                Double weight = 0;
                                if (_commandTargetReputationDictionary.TryGetValue(typeAction, out weight)) {
                                    targetReputation += (weight * command_count);
                                }
                                else {
                                    ConsoleError("Unable to find target weight for type|action: " + typeAction);
                                }
                            }
                        }
                    }
                    //Special case for certain commands with same source and target, but should still be counted
                    //Currently only the assist command is counted (Command ID 51)
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = @"
                        SELECT
	                        command_type,
	                        command_action,
	                        count(record_id) command_count
                        FROM
	                        adkats_records_main
                        WHERE
	                        source_id = @player_id
                        AND
	                        target_id = source_id
                        AND
	                        command_type = 51
                        AND 
                            command_action = 51
                        GROUP BY command_type, command_action";
                        command.Parameters.AddWithValue("player_id", aPlayer.player_id);
                        using (MySqlDataReader reader = SafeExecuteReader(command))
                        {
                            while (reader.Read())
                            {
                                String typeAction = reader.GetInt32("command_type") + "|" + reader.GetInt32("command_action");
                                Double command_count = reader.GetDouble("command_count");
                                Double weight = 0;
                                if (_commandSourceReputationDictionary.TryGetValue(typeAction, out weight))
                                {
                                    sourceReputation += (weight * command_count);
                                }
                                else
                                {
                                    ConsoleError("Unable to find source weight for type|action: " + typeAction);
                                }
                                if (_commandTargetReputationDictionary.TryGetValue(typeAction, out weight))
                                {
                                    targetReputation += (weight * command_count);
                                }
                                else
                                {
                                    ConsoleError("Unable to find target weight for type|action: " + typeAction);
                                }
                            }
                        }
                    }
                    totalReputation = sourceReputation + targetReputation;
                    if (totalReputation >= 0) {
                        totalReputationConstrained = (1000 * totalReputation) / (totalReputation + 1000);
                    }
                    else {
                        totalReputationConstrained = -(1000 * Math.Abs(totalReputation)) / (Math.Abs(totalReputation) + 1000);
                    }
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        REPLACE INTO
	                        adkats_player_reputation
                        VALUES 
                        (
	                        @player_id,
	                        @game_id,
	                        @target_rep,
	                        @source_rep,
	                        @total_rep,
                            @total_rep_co
                        )";
                        if (aPlayer.player_id <= 0)
                        {
                            ConsoleError("Player ID invalid when updating player reputation. Unable to complete.");
                            return;
                        }
                        command.Parameters.AddWithValue("player_id", aPlayer.player_id);
                        if (aPlayer.game_id <= 0) {
                            aPlayer.game_id = _serverInfo.GameID;
                        }
                        command.Parameters.AddWithValue("game_id", aPlayer.game_id);
                        command.Parameters.AddWithValue("target_rep", targetReputation);
                        command.Parameters.AddWithValue("source_rep", sourceReputation);
                        command.Parameters.AddWithValue("total_rep", totalReputation);
                        command.Parameters.AddWithValue("total_rep_co", totalReputationConstrained);
                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (_firstPlayerListComplete && Math.Abs(aPlayer.player_reputation - totalReputationConstrained) > .02) {
                            if (aPlayer.player_spawnedOnce || (aPlayer.frostbitePlayerInfo != null && aPlayer.frostbitePlayerInfo.TeamID == 0)){
                                DebugWrite(aPlayer.GetVerboseName() + "'s reputation updated from " + Math.Round(aPlayer.player_reputation, 2) + " to " + Math.Round(totalReputationConstrained, 2), 3);
                                if (!PlayerIsAdmin(aPlayer))
                                {
                                    String message = "Your reputation ";
                                    if (totalReputationConstrained > aPlayer.player_reputation) {
                                        if (totalReputationConstrained >= 0) {
                                            message += "increased from " + Math.Round(aPlayer.player_reputation, 2) + " to " + Math.Round(totalReputationConstrained, 2) + "! Thanks for your help!";
                                        }
                                        else {
                                            message += "increased from " + Math.Round(aPlayer.player_reputation, 2) + " to " + Math.Round(totalReputationConstrained, 2) + ", but is still negative.";
                                        }
                                    }
                                    else {
                                        if (aPlayer.player_reputation >= 0) {
                                            if (totalReputationConstrained < 0) {
                                                message += "has gone negative! Be careful, it's now " + Math.Round(totalReputationConstrained, 2);
                                            }
                                            else {
                                                message += "decreased from " + Math.Round(aPlayer.player_reputation, 2) + " to " + Math.Round(totalReputationConstrained, 2);
                                            }
                                        }
                                        else {
                                            message += "decreased further from " + Math.Round(aPlayer.player_reputation, 2) + " to " + Math.Round(totalReputationConstrained, 2);
                                        }
                                    }
                                    if(informPlayer)
                                        PlayerSayMessage(aPlayer.player_name, message);
                                }
                            }
                        }
                        aPlayer.player_reputation = totalReputationConstrained;
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while updating player reputation.", e));
            }
        }

        private Boolean SendQuery(String query, Boolean verbose) {
            if (String.IsNullOrEmpty(query)) {
                return false;
            }
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        //Attempt to execute the query
                        command.CommandText = query;
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                if (verbose) {
                                    ConsoleSuccess("Query returned values.");
                                }
                                return true;
                            }
                            if (verbose) {
                                ConsoleError("Query returned no results.");
                            }
                            return false;
                        }
                    }
                }
            }
            catch (Exception e) {
                if (verbose)
                {
                    HandleException(new AdKatsException("Verbose. Error while performing query.", e));
                }
                return false;
            }
        }

        private Boolean SendNonQuery(String desc, String nonQuery, Boolean verbose) {
            if (String.IsNullOrEmpty(nonQuery)) {
                return false;
            }
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = nonQuery;
                        //Attempt to execute the non query
                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (verbose) {
                            ConsoleSuccess("Non-Query success. " + rowsAffected + " rows affected. [" + desc + "]");
                        }
                        return true;
                    }
                }
            }
            catch (Exception e) {
                if (verbose) {
                    ConsoleError("Non-Query failed. [" + desc + "]: " + e);
                }
                return false;
            }
        }

        
        private void UpdateRecord(AdKatsRecord record) {
            //If record has multiple inner records, update those instead
            if (record.TargetInnerRecords.Any())
            {
                foreach (AdKatsRecord innerRecord in record.TargetInnerRecords)
                {
                    //Update the inner record with action, numeric, and message, before pushing
                    innerRecord.command_action = record.command_action;
                    innerRecord.command_numeric = record.command_numeric;
                    innerRecord.record_message = record.record_message;
                    //Call inner upload
                    UpdateInnerRecord(innerRecord);
                }
            }
            else
            {
                UpdateInnerRecord(record);
            }
        }

        
        private void UpdateInnerRecord(AdKatsRecord record) {
            DebugWrite("UpdateInnerRecord starting!", 6);

            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                record.record_exception = new AdKatsException("Database not connected.");
                return;
            }
            try {
                Int32 attempts = 0;
                Boolean success = false;
                do {
                    try {
                        using (MySqlConnection connection = GetDatabaseConnection()) {
                            using (MySqlCommand command = connection.CreateCommand()) {
                                String tablename = (record.isDebug) ? ("`adkats_records_debug`") : ("`adkats_records_main`");
                                //Set the insert command structure
                                command.CommandText = "UPDATE " + tablename + @" 
                                SET 
                                    `command_action` = @command_action, 
                                    `command_numeric` = @command_numeric, 
                                    `record_message` = @record_message, 
                                    `adkats_read` = 'Y' 
                                WHERE 
                                    `record_id` = @record_id";
                                //Fill the command
                                command.Parameters.AddWithValue("@record_id", record.record_id);
                                command.Parameters.AddWithValue("@command_numeric", record.command_numeric);
                                //Trim to 500 characters
                                record.record_message = record.record_message.Length <= 500 ? record.record_message : record.record_message.Substring(0, 500);
                                command.Parameters.AddWithValue("@record_message", record.record_message);
                                command.Parameters.AddWithValue("@command_action", record.command_action.command_id);
                                //Attempt to execute the query
                                Int32 rowsAffected = SafeExecuteNonQuery(command);
                                if (rowsAffected > 0) {
                                    success = true;
                                }
                            }
                        }
                    }
                    catch (Exception e) {
                        HandleException(new AdKatsException("Error while updating record.", e));
                        success = false;
                    }
                } while (!success && attempts++ < 5);

                UpdateRecordEndPointReputations(record);
                if (success)
                {
                    DebugWrite(record.command_action.command_key + " update for " + record.GetTargetNames() + " by " + record.GetSourceName() + " SUCCESSFUL!", 3);
                }
                else {
                    ConsoleError(record.command_action.command_key + " update for " + record.GetTargetNames() + " by " + record.GetSourceName() + " FAILED!");
                }

                DebugWrite("UpdateInnerRecord finished!", 6);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while updating record", e));
            }
        }

        
        private AdKatsRecord FetchRecordByID(Int64 recordID, Boolean debug)
        {
            DebugWrite("fetchRecordByID starting!", 6);
            AdKatsRecord record = null;
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                return null;
            }
            try
            {
                //Success fetching record
                Boolean success = false;
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        String tablename = (debug) ? ("`adkats_records_debug`") : ("`adkats_records_main`");
                        String sql = @"
                        SELECT 
                            `record_id`, 
                            `server_id`, 
                            `command_type`, 
                            `command_action`, 
                            `command_numeric`, 
                            `target_name`, 
                            `target_id`, 
                            `source_name`,
                            `source_id`, 
                            `record_message`, 
                            `record_time` 
                        FROM 
                            " + tablename + @" 
                        WHERE 
                            `record_id` = " + recordID;
                        command.CommandText = sql;
                        using (MySqlDataReader reader = SafeExecuteReader(command))
                        {
                            //Grab the record
                            if (reader.Read())
                            {
                                success = true;

                                record = new AdKatsRecord();
                                record.record_source = AdKatsRecord.Sources.Database;
                                record.record_id = reader.GetInt64("record_id");
                                record.server_id = reader.GetInt64("server_id");
                                Int32 commandTypeInt = reader.GetInt32("command_type");
                                if (!_CommandIDDictionary.TryGetValue(commandTypeInt, out record.command_type))
                                {
                                    ConsoleError("Unable to parse command type " + commandTypeInt + " when fetching record by ID.");
                                }
                                Int32 commandActionInt = reader.GetInt32("command_action");
                                if (!_CommandIDDictionary.TryGetValue(commandActionInt, out record.command_action))
                                {
                                    ConsoleError("Unable to parse command action " + commandActionInt + " when fetching record by ID.");
                                }
                                record.command_numeric = reader.GetInt32("command_numeric");
                                record.target_name = reader.GetString("target_name");
                                if (!reader.IsDBNull(6))
                                {
                                    record.target_player = new AdKatsPlayer(this)
                                    {
                                        player_id = reader.GetInt64(6)
                                    };
                                }
                                record.source_name = reader.GetString("source_name");
                                if (!reader.IsDBNull(8))
                                {
                                    record.source_player = new AdKatsPlayer(this)
                                    {
                                        player_id = reader.GetInt64(6)
                                    };
                                }
                                record.record_message = reader.GetString("record_message");
                                record.record_time = reader.GetDateTime("record_time");
                            }
                            if (success)
                            {
                                DebugWrite("Record found for ID " + recordID, 5);
                            }
                            else
                            {
                                DebugWrite("No record found for ID " + recordID, 5);
                            }
                        }
                        if (success && record.target_player != null)
                        {
                            long oldID = record.target_player.player_id;
                            record.target_player = FetchPlayer(false, true, false, null, oldID, null, null, null);
                            if (record.target_player == null)
                            {
                                ConsoleError("Unable to find player ID: " + oldID);
                                return null;
                            }
                            if (!String.IsNullOrEmpty(record.target_player.player_name))
                            {
                                record.target_name = record.target_player.player_name;
                            }
                            else
                            {
                                record.target_name = "NoNameTarget";
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching record by ID", e));
            }

            DebugWrite("fetchRecordByID finished!", 6);
            return record;
        }

        
        private List<AdKatsRecord> FetchRecentRecords(Int64? player_id, Int64? command_id, Int64 limit_days, Int64 limit_records, Boolean target_only, Boolean debug)
        {
            DebugWrite("FetchRecentRecords starting!", 6);
            var records = new List<AdKatsRecord>();
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                return null;
            }
            try
            {
                //Success fetching record
                Boolean success = false;
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        String tablename = (debug) ? ("`adkats_records_debug`") : ("`adkats_records_main`");
                        String sql = @"
                        (SELECT 
	                        `record_id`, 
	                        `server_id`, 
	                        `command_type`, 
	                        `command_action`, 
	                        `command_numeric`, 
	                        `target_name`, 
	                        `target_id`, 
	                        `source_name`, 
	                        `source_id`,
	                        `record_message`, 
	                        `record_time` 
                        FROM 
	                        " + tablename + @" 
                        WHERE
	                        `record_id` = `record_id`";
                        if (command_id != null && command_id > 0) {
                            sql += @" 
                            AND
                            (
	                            `command_type` = @command_id
	                            OR
	                            `command_action` = @command_id
                            )";
                            command.Parameters.AddWithValue("@command_id", command_id);
                        }
                        if (player_id != null && player_id > 0) {
                            sql += @" 
                            AND 
                            (
	                            `target_id` = @player_id
	                            " + ((target_only)?(""):(" OR `source_id` = @player_id ")) + @"
                            )";
                            command.Parameters.AddWithValue("@player_id", player_id);
                        }
                        sql += @" 
                        AND
                        (
	                        DATE_ADD(`record_time`, INTERVAL @limit_days DAY) > UTC_TIMESTAMP()
                        )
                        ORDER BY
	                        `record_id` DESC
                        LIMIT
	                        @limit_records)
                        ORDER BY `record_id` ASC";
                        command.Parameters.AddWithValue("@limit_days", limit_days);
                        command.Parameters.AddWithValue("@limit_records", limit_records);
                        command.CommandText = sql;
                        using (MySqlDataReader reader = SafeExecuteReader(command))
                        {
                            //Grab the records
                            while (reader.Read())
                            {
                                success = true;
                                var record = new AdKatsRecord();
                                record = new AdKatsRecord();
                                record.record_source = AdKatsRecord.Sources.Database;
                                record.record_id = reader.GetInt64("record_id");
                                record.server_id = reader.GetInt64("server_id");
                                Int32 commandTypeInt = reader.GetInt32("command_type");
                                if (!_CommandIDDictionary.TryGetValue(commandTypeInt, out record.command_type))
                                {
                                    ConsoleError("Unable to parse command type " + commandTypeInt + " when fetching record.");
                                }
                                Int32 commandActionInt = reader.GetInt32("command_action");
                                if (!_CommandIDDictionary.TryGetValue(commandActionInt, out record.command_action))
                                {
                                    ConsoleError("Unable to parse command action " + commandActionInt + " when fetching record.");
                                }
                                record.command_numeric = reader.GetInt32("command_numeric");
                                record.target_name = reader.GetString("target_name");
                                if (!reader.IsDBNull(6)) {
                                    Int64 targetID = reader.GetInt64(6);
                                    AdKatsPlayer tPlayer;
                                    if ((_PlayerDictionary.TryGetValue(record.target_name, out tPlayer) || _PlayerLeftDictionary.TryGetValue(record.target_name, out tPlayer)) && tPlayer.player_id == targetID) {
                                        DebugWrite("Target player fetched from memory.", 4);
                                    }
                                    else {
                                        tPlayer = FetchPlayer(false, true, false, null, targetID, null, null, null);
                                    }
                                    record.target_player = tPlayer;
                                }
                                record.source_name = reader.GetString("source_name");
                                if (!reader.IsDBNull(8))
                                {
                                    Int64 targetID = reader.GetInt64(8);
                                    AdKatsPlayer sPlayer;
                                    if ((_PlayerDictionary.TryGetValue(record.target_name, out sPlayer) || _PlayerLeftDictionary.TryGetValue(record.target_name, out sPlayer)) && sPlayer.player_id == targetID)
                                    {
                                        DebugWrite("Target player fetched from memory.", 4);
                                    }
                                    else
                                    {
                                        sPlayer = FetchPlayer(false, true, false, null, targetID, null, null, null);
                                    }
                                    record.source_player = sPlayer;
                                }
                                record.record_message = reader.GetString("record_message");
                                record.record_time = reader.GetDateTime("record_time");
                                records.Add(record);
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching recent records", e));
            }

            DebugWrite("FetchRecentRecords finished!", 6);
            return records;
        }

        
        private List<AdKatsRecord> FetchUnreadRecords()
        {
            DebugWrite("fetchUnreadRecords starting!", 6);
            //Create return list
            var records = new List<AdKatsRecord>();
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                return records;
            }
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        String sql = @"
                        SELECT 
                            `record_id`, 
                            `server_id`, 
                            `command_type`, 
                            `command_action`, 
                            `command_numeric`, 
                            `target_name`, 
                            `target_id`, 
                            `source_name`, 
                            `source_id`,
                            `record_message`, 
                            `record_time` 
                        FROM 
                            `" + _mySqlSchemaName + @"`.`adkats_records_main` 
                        WHERE 
                            `adkats_read` = 'N' 
                        AND 
                            `server_id` = " + _serverInfo.ServerID;
                        command.CommandText = sql;
                        using (MySqlDataReader reader = SafeExecuteReader(command))
                        {
                            //Grab the record
                            while (reader.Read())
                            {
                                var record = new AdKatsRecord();
                                record.record_source = AdKatsRecord.Sources.Database;
                                record.record_id = reader.GetInt64("record_id");
                                record.server_id = reader.GetInt64("server_id");
                                Int32 commandTypeInt = reader.GetInt32("command_type");
                                if (!_CommandIDDictionary.TryGetValue(commandTypeInt, out record.command_type))
                                {
                                    ConsoleError("Unable to parse command type " + commandTypeInt + " when fetching record by ID.");
                                }
                                Int32 commandActionInt = reader.GetInt32("command_action");
                                if (!_CommandIDDictionary.TryGetValue(commandActionInt, out record.command_action))
                                {
                                    ConsoleError("Unable to parse command action " + commandActionInt + " when fetching record by ID.");
                                }
                                record.command_numeric = reader.GetInt32("command_numeric");
                                record.target_name = reader.GetString("target_name");
                                object value = reader.GetValue(6);
                                Int64 targetIDParse = -1;
                                DebugWrite("id fetched!", 6);
                                if (Int64.TryParse(value.ToString(), out targetIDParse))
                                {
                                    DebugWrite("id parsed! " + targetIDParse, 6);
                                    //Check if the player needs to be imported, or if they are already in the server
                                    AdKatsPlayer importedPlayer = FetchPlayer(false, true, false, null, targetIDParse, null, null, null);
                                    if (importedPlayer == null)
                                    {
                                        continue;
                                    }
                                    AdKatsPlayer currentPlayer = null;
                                    if (!String.IsNullOrEmpty(importedPlayer.player_name) && _PlayerDictionary.TryGetValue(importedPlayer.player_name, out currentPlayer))
                                    {
                                        DebugWrite("External player is currently in the server, using existing data.", 5);
                                        record.target_player = currentPlayer;
                                    }
                                    else
                                    {
                                        DebugWrite("External player is not in the server, fetching from database.", 5);
                                        record.target_player = importedPlayer;
                                    }
                                    record.target_name = record.target_player.player_name;
                                }
                                else
                                {
                                    DebugWrite("id parse failed!", 6);
                                }
                                record.source_name = reader.GetString("source_name");
                                object sourceIDObj = reader.GetValue(8);
                                Int64 sourceIDParse = -1;
                                if (Int64.TryParse(sourceIDObj.ToString(), out sourceIDParse))
                                {
                                    DebugWrite("source id parsed! " + sourceIDParse, 6);
                                    //Check if the player needs to be imported, or if they are already in the server
                                    AdKatsPlayer importedPlayer = FetchPlayer(false, true, false, null, sourceIDParse, null, null, null);
                                    if (importedPlayer == null)
                                    {
                                        continue;
                                    }
                                    AdKatsPlayer currentPlayer = null;
                                    if (!String.IsNullOrEmpty(importedPlayer.player_name) && _PlayerDictionary.TryGetValue(importedPlayer.player_name, out currentPlayer))
                                    {
                                        DebugWrite("External player is currently in the server, using existing data.", 5);
                                        record.source_player = currentPlayer;
                                    }
                                    else
                                    {
                                        DebugWrite("External player is not in the server, fetching from database.", 5);
                                        record.source_player = importedPlayer;
                                    }
                                    record.target_name = record.target_player.player_name;
                                }
                                record.record_message = reader.GetString("record_message");
                                record.record_time = reader.GetDateTime("record_time");

                                records.Add(record);
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching unread records from database.", e));
            }

            DebugWrite("fetchUnreadRecords finished!", 6);
            return records;
        }


        private List<AdKatsPlayer> FetchExternalOnlinePlayers()
        {
            DebugWrite("FetchExternalOnlinePlayers starting!", 6);
            //Create return list
            var onlinePlayers = new List<AdKatsPlayer>();
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                return onlinePlayers;
            }
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        String sql = @"
                        SELECT 
	                        `tbl_server`.`ServerID` AS `server_id`,
	                        `tbl_server`.`ServerName` AS `server_name`,
	                        `tbl_playerdata`.`PlayerID` AS `player_id`,
	                        `tbl_playerdata`.`SoldierName` AS `player_name`,
	                        `tbl_playerdata`.`EAGUID` AS `player_guid`
                        FROM 
	                        `tbl_currentplayers`
                        INNER JOIN
	                        `tbl_server`
                        ON
	                        `tbl_server`.`ServerID` = `tbl_currentplayers`.`ServerID`
                        INNER JOIN
	                        `tbl_playerdata`
                        ON
	                        `tbl_currentplayers`.`EA_GUID` = `tbl_playerdata`.`EAGUID`
	                        AND
	                        `tbl_server`.`GameID` = `tbl_playerdata`.`GameID`
                        WHERE
	                        `tbl_currentplayers`.`ServerID` != @current_server_id 
                        GROUP BY
	                        `tbl_playerdata`.`PlayerID`";
                        command.CommandText = sql;
                        command.Parameters.AddWithValue("@current_server_id", _serverInfo.ServerID);
                        using (MySqlDataReader reader = SafeExecuteReader(command))
                        {
                            //Grab the record
                            while (reader.Read())
                            {
                                var ePlayer = FetchPlayer(false, false, false, null, reader.GetInt64("player_id"), null, null, null);
                                if (ePlayer != null)
                                {
                                    ePlayer.player_server = new AdKatsServer(this)
                                    {
                                        ServerID = reader.GetInt64("server_id"),
                                        ServerName = reader.GetString("server_name")
                                    };
                                    onlinePlayers.Add(ePlayer);
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching external online players.", e));
            }
            DebugWrite("FetchExternalOnlinePlayers finished!", 6);
            return onlinePlayers;
        }

        private AdKatsPlayer FetchMatchingExternalOnlinePlayer(String searchName)
        {
            DebugWrite("FetchMatchingExternalOnlinePlayer starting!", 6);
            AdKatsPlayer aPlayer = null;
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                return null;
            }
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        String sql = @"
                        SELECT 
	                        `tbl_server`.`ServerID` AS `server_id`,
	                        `tbl_server`.`ServerName` AS `server_name`,
	                        `tbl_playerdata`.`PlayerID` AS `player_id`,
	                        `tbl_playerdata`.`SoldierName` AS `player_name`,
	                        `tbl_playerdata`.`EAGUID` AS `player_guid`
                        FROM 
	                        `tbl_currentplayers`
                        INNER JOIN
	                        `tbl_server`
                        ON
	                        `tbl_server`.`ServerID` = `tbl_currentplayers`.`ServerID`
                        INNER JOIN
	                        `tbl_playerdata`
                        ON
	                        `tbl_currentplayers`.`EA_GUID` = `tbl_playerdata`.`EAGUID`
	                        AND
	                        `tbl_server`.`GameID` = `tbl_playerdata`.`GameID`
                        WHERE
	                        `tbl_currentplayers`.`ServerID` != @current_server_id 
                        GROUP BY
	                        `tbl_playerdata`.`PlayerID`";
                        command.CommandText = sql;
                        command.Parameters.AddWithValue("@current_server_id", _serverInfo.ServerID);
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            while (reader.Read()) {
                                if (Regex.Match(reader.GetString("player_name"), searchName, RegexOptions.IgnoreCase).Success) {
                                    aPlayer = FetchPlayer(false, true, false, null, reader.GetInt64("player_id"), null, null, null);
                                    if (aPlayer == null)
                                    {
                                        return null;
                                    }
                                    aPlayer.player_server = new AdKatsServer(this)
                                    {
                                        ServerID = reader.GetInt64("server_id"),
                                        ServerName = reader.GetString("server_name")
                                    };
                                    return aPlayer;
                                }
                            }
                            return null;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching matching external online from database.", e));
            }
            DebugWrite("FetchMatchingExternalOnlinePlayer finished!", 6);
            return aPlayer;
        }
        
        private void RunPluginOrchestration() {
            DebugWrite("RunPluginOrchestration starting!", 6);
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                DebugWrite("Running plugin orchestration", 5);
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT
	                        `setting_plugin`,
	                        `setting_name`,
	                        `setting_value`
                        FROM
	                        `adkats_orchestration`
                        WHERE
	                        `setting_server` = @server_id";
                        command.Parameters.AddWithValue("server_id", _serverInfo.ServerID);
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            while (reader.Read()) {
                                SetExternalPluginSetting(reader.GetString("setting_plugin"), reader.GetString("setting_name"), reader.GetString("setting_value"));
                                _threadMasterWaitHandle.WaitOne(10);
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while running plugin orchestration.", e));
            }

            DebugWrite("RunPluginOrchestration finished!", 6);
        }

        
        private Int64 FetchNameBanCount() {
            DebugWrite("fetchNameBanCount starting!", 7);
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return 0;
            }
            if (_NameBanCount >= 0 && (UtcDbTime() - _lastNameBanCountFetch).TotalSeconds < 30) {
                return _NameBanCount;
            }
            _lastNameBanCountFetch = UtcDbTime();
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            COUNT(ban_id) AS `ban_count`
                        FROM 
	                        `adkats_bans` 
                        WHERE 
                            `adkats_bans`.`ban_enforceName` = 'Y' 
                        AND 
                            `ban_status` = 'Active'";

                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                _NameBanCount = reader.GetInt64("ban_count");
                                return _NameBanCount;
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching number of id bans.", e));
            }

            DebugWrite("fetchNameBanCount finished!", 7);
            return -1;
        }

        
        private Int64 FetchGUIDBanCount() {
            DebugWrite("fetchGUIDBanCount starting!", 7);
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return 0;
            }
            if (_GUIDBanCount >= 0 && (UtcDbTime() - _lastGUIDBanCountFetch).TotalSeconds < 30) {
                return _GUIDBanCount;
            }
            _lastGUIDBanCountFetch = UtcDbTime();
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            COUNT(ban_id) AS `ban_count`
                        FROM 
	                        `adkats_bans` 
                        WHERE 
                            `adkats_bans`.`ban_enforceGUID` = 'Y' 
                        AND 
                            `ban_status` = 'Active'";

                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                _GUIDBanCount = reader.GetInt64("ban_count");
                                return _GUIDBanCount;
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching number of GUID bans.", e));
            }

            DebugWrite("fetchGUIDBanCount finished!", 7);
            return -1;
        }

        
        private Int64 FetchIPBanCount() {
            DebugWrite("fetchIPBanCount starting!", 7);
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return 0;
            }
            if (_IPBanCount >= 0 && (UtcDbTime() - _lastIPBanCountFetch).TotalSeconds < 30) {
                return _IPBanCount;
            }
            _lastIPBanCountFetch = UtcDbTime();
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            COUNT(ban_id) AS `ban_count` 
                        FROM 
	                        `adkats_bans` 
                        WHERE 
                            `adkats_bans`.`ban_enforceIP` = 'Y' 
                        AND 
                            `ban_status` = 'Active'";

                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                _IPBanCount = reader.GetInt64("ban_count");
                                return _IPBanCount;
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching number of IP bans.", e));
            }

            DebugWrite("fetchIPBanCount finished!", 7);
            return -1;
        }

        private void RemoveUser(AdKatsUser user) {
            DebugWrite("removeUser starting!", 6);
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = "DELETE FROM `" + _mySqlSchemaName + "`.`adkats_users` WHERE `user_id` = @user_id";
                        command.Parameters.AddWithValue("@user_id", user.user_id);
                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while removing user.", e));
            }
            DebugWrite("removeUser finished!", 6);
        }

        private void RemoveRole(AdKatsRole aRole) {
            DebugWrite("removeRole starting!", 6);
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                //Assign "Default Guest" to all users currently on this role
                AdKatsRole guestRole = null;
                if (_RoleKeyDictionary.TryGetValue("guest_default", out guestRole)) {
                    foreach (AdKatsUser aUser in _userCache.Values) {
                        if (aUser.user_role.role_key == aRole.role_key) {
                            aUser.user_role = guestRole;
                        }
                        UploadUser(aUser);
                    }
                }
                else {
                    ConsoleError("Could not fetch default guest user role. Unsafe to remove requested user role.");
                    return;
                }
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = "DELETE FROM `" + _mySqlSchemaName + "`.`adkats_rolecommands` WHERE `role_id` = @role_id";
                        command.Parameters.AddWithValue("@role_id", aRole.role_id);
                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                    }
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = "DELETE FROM `" + _mySqlSchemaName + "`.`adkats_roles` WHERE `role_id` = @role_id";
                        command.Parameters.AddWithValue("@role_id", aRole.role_id);
                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while removing user.", e));
            }
            DebugWrite("removeRole finished!", 6);
        }

        private void UploadUser(AdKatsUser aUser) {
            DebugWrite("uploadUser starting!", 6);
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                DebugWrite("Uploading user: " + aUser.user_name, 5);

                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        if (aUser.user_role == null) {
                            AdKatsRole aRole = null;
                            if (_RoleKeyDictionary.TryGetValue("guest_default", out aRole)) {
                                aUser.user_role = aRole;
                            }
                            else {
                                ConsoleError("Unable to assign default guest role to user " + aUser.user_name + ". Unable to upload user.");
                                return;
                            }
                        }
                        command.CommandText = @"
                        INSERT INTO 
	                        `adkats_users`
                        (
	                        " + ((aUser.user_id > 0) ? ("`user_id`,") : ("")) + @"
	                        `user_name`,
	                        `user_email`,
	                        `user_phone`,
	                        `user_role`,
                            `user_expiration`,
                            `user_notes`
                        )
                        VALUES
                        (
	                        " + ((aUser.user_id > 0) ? ("@user_id,") : ("")) + @"
	                        @user_name,
	                        @user_email,
	                        @user_phone,
	                        @user_role,
                            @user_expiration,
                            @user_notes
                        )
                        ON DUPLICATE KEY UPDATE
	                        `user_name` = @user_name,
	                        `user_email` = @user_email,
	                        `user_phone` = @user_phone,
	                        `user_role` = @user_role,
                            `user_expiration` = @user_expiration,
                            `user_notes` = @user_notes";
                        if (aUser.user_id > 0) {
                            command.Parameters.AddWithValue("@user_id", aUser.user_id);
                        }
                        command.Parameters.AddWithValue("@user_name", aUser.user_name);
                        command.Parameters.AddWithValue("@user_email", aUser.user_email);
                        command.Parameters.AddWithValue("@user_phone", aUser.user_phone);
                        command.Parameters.AddWithValue("@user_role", aUser.user_role.role_id);
                        command.Parameters.AddWithValue("@user_expiration", aUser.user_expiration);
                        command.Parameters.AddWithValue("@user_notes", aUser.user_notes);

                        //Attempt to execute the query
                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                        if (rowsAffected > 0) {
                            //Set the user's new ID if new
                            if (aUser.user_id < 0) {
                                aUser.user_id = command.LastInsertedId;
                            }
                            DebugWrite("User uploaded to database SUCCESSFULY.", 5);
                        }
                        else {
                            ConsoleError("Unable to upload user " + aUser.user_name + " to database.");
                            return;
                        }
                    }
                    //Run command to delete all current soldiers
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"DELETE FROM `adkats_usersoldiers` where `user_id` = " + aUser.user_id;
                        //Attempt to execute the query
                        Int32 rowsAffected = SafeExecuteNonQuery(command);
                    }
                    //Upload/Update the user's soldier list
                    if (aUser.soldierDictionary.Count > 0) {
                        //Refill user with current soldiers
                        foreach (AdKatsPlayer aPlayer in aUser.soldierDictionary.Values) {
                            using (MySqlCommand command = connection.CreateCommand()) {
                                //Set the insert command structure
                                command.CommandText = @"
                                INSERT INTO
	                                `adkats_usersoldiers`
                                (
	                                `user_id`,
	                                `player_id`
                                )
                                VALUES
                                (
	                                @user_id,
	                                @player_id
                                )
                                ON DUPLICATE KEY UPDATE
	                                `player_id` = @player_id";
                                //Set values
                                command.Parameters.AddWithValue("@user_id", aUser.user_id);
                                command.Parameters.AddWithValue("@player_id", aPlayer.player_id);

                                //Attempt to execute the query
                                Int32 rowsAffected = SafeExecuteNonQuery(command);
                                if (rowsAffected > 0) {
                                    DebugWrite("Soldier link " + aUser.user_id + "->" + aPlayer.player_id + " uploaded to database SUCCESSFULY.", 5);
                                }
                                else {
                                    ConsoleError("Unable to upload soldier link for " + aUser.user_name + " to database.");
                                    return;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while updating player access.", e));
            }

            DebugWrite("uploadUser finished!", 6);
        }

        private void TryAddUserSoldier(AdKatsUser aUser, String soldierName) {
            try {
                //Attempt to fetch the soldier
                if (!String.IsNullOrEmpty(soldierName) && SoldierNameValid(soldierName)) {
                    List<AdKatsPlayer> matchingPlayers;
                    if (FetchMatchingPlayers(soldierName, out matchingPlayers, false)) {
                        if (matchingPlayers.Count > 0) {
                            if (matchingPlayers.Count > 10) {
                                ConsoleError("Too many players matched the query, unable to add.");
                                return;
                            }
                            foreach (AdKatsPlayer matchingPlayer in matchingPlayers) {
                                bool playerDuplicate = false;
                                //Make sure the player is not already assigned to another user
                                lock (_userCache) {
                                    if (_userCache.Values.Any(innerUser => innerUser.soldierDictionary.ContainsKey(matchingPlayer.player_id))) {
                                        playerDuplicate = true;
                                    }
                                }
                                if (!playerDuplicate) {
                                    if (aUser.soldierDictionary.ContainsKey(matchingPlayer.player_id)) {
                                        aUser.soldierDictionary.Remove(matchingPlayer.player_id);
                                    }
                                    aUser.soldierDictionary.Add(matchingPlayer.player_id, matchingPlayer);
                                }
                                else {
                                    ConsoleError("Player " + matchingPlayer.GetVerboseName() + "(" + _gameIDDictionary[matchingPlayer.game_id] + ") already assigned to a user.");
                                }
                            }
                            return;
                        }
                        ConsoleError("Players matching '" + soldierName + "' not found in database. Unable to assign to user.");
                    }
                }
                else {
                    ConsoleError("'" + soldierName + "' was an invalid soldier name. Unable to assign to user.");
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while attempting to add user soldier.", e));
            }
        }

        
        private void UploadRole(AdKatsRole aRole) {
            DebugWrite("uploadRole starting!", 6);
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                lock (aRole) {
                    lock (aRole.RoleAllowedCommands) {
                        DebugWrite("Uploading role: " + aRole.role_name, 5);

                        //Open db connection
                        using (MySqlConnection connection = GetDatabaseConnection()) {
                            //Upload/Update the main role object
                            using (MySqlCommand command = connection.CreateCommand()) {
                                //Set the insert command structure
                                command.CommandText = @"
                                INSERT INTO 
	                                `adkats_roles`
                                (
	                                `role_key`,
	                                `role_name`
                                )
                                VALUES
                                (
	                                @role_key,
	                                @role_name
                                )
                                ON DUPLICATE KEY UPDATE
	                                `role_key` = @role_key,
	                                `role_name` = @role_name";
                                //Set values
                                command.Parameters.AddWithValue("@role_key", aRole.role_key);
                                command.Parameters.AddWithValue("@role_name", aRole.role_name);

                                //Attempt to execute the query
                                Int32 rowsAffected = SafeExecuteNonQuery(command);
                                if (rowsAffected > 0) {
                                    //Set the user's new ID if new
                                    if (aRole.role_id < 0) {
                                        aRole.role_id = command.LastInsertedId;
                                    }
                                    DebugWrite("Role uploaded to database SUCCESSFULY.", 5);
                                }
                                else {
                                    ConsoleError("Unable to upload role " + aRole.role_name + " to database.");
                                    return;
                                }
                            }
                            //Delete all current allowed commands
                            using (MySqlCommand command = connection.CreateCommand())
                            {
                                command.CommandText = @"DELETE FROM `adkats_rolecommands` where `role_id` = " + aRole.role_id;
                                //Attempt to execute the query
                                Int32 rowsAffected = SafeExecuteNonQuery(command);
                            }
                            foreach (AdKatsCommand aCommand in aRole.RoleAllowedCommands.Values)
                            {
                                //Upload the role's allowed commands
                                using (MySqlCommand command = connection.CreateCommand())
                                {
                                    //Set the insert command structure
                                    command.CommandText = @"
                                    INSERT INTO 
	                                    `adkats_rolecommands`
                                    (
	                                    `role_id`,
	                                    `command_id`
                                    )
                                    VALUES
                                    (
	                                    @role_id,
	                                    @command_id
                                    )
                                    ON DUPLICATE KEY UPDATE
	                                    `role_id` = @role_id,
	                                    `command_id` = @command_id";
                                    //Set values
                                    command.Parameters.AddWithValue("@role_id", aRole.role_id);
                                    command.Parameters.AddWithValue("@command_id", aCommand.command_id);

                                    //Attempt to execute the query
                                    Int32 rowsAffected = SafeExecuteNonQuery(command);
                                    if (rowsAffected > 0)
                                    {
                                        DebugWrite("Role-command uploaded to database SUCCESSFULY.", 5);
                                    }
                                    else
                                    {
                                        ConsoleError("Unable to upload role-command for " + aRole.role_name + ".");
                                        return;
                                    }
                                }
                            }
                            //Delete all current role groups
                            using (MySqlCommand command = connection.CreateCommand())
                            {
                                command.CommandText = @"DELETE FROM `adkats_rolegroups` where `role_id` = " + aRole.role_id;
                                //Attempt to execute the query
                                Int32 rowsAffected = SafeExecuteNonQuery(command);
                            }
                            foreach (AdKatsSpecialGroup aGroup in aRole.RoleSetGroups.Values)
                            {
                                //Upload the role's set groups
                                using (MySqlCommand command = connection.CreateCommand())
                                {
                                    command.CommandText = @"
                                    INSERT INTO 
	                                    `adkats_rolegroups`
                                    (
	                                    `role_id`,
	                                    `group_key`
                                    )
                                    VALUES
                                    (
	                                    @role_id,
	                                    @group_key
                                    )
                                    ON DUPLICATE KEY UPDATE
	                                    `role_id` = @role_id,
	                                    `group_key` = @group_key";
                                    //Set values
                                    command.Parameters.AddWithValue("@role_id", aRole.role_id);
                                    command.Parameters.AddWithValue("@group_key", aGroup.group_key);

                                    //Attempt to execute the query
                                    Int32 rowsAffected = SafeExecuteNonQuery(command);
                                    if (rowsAffected > 0)
                                    {
                                        DebugWrite("Role-groups uploaded to database SUCCESSFULY.", 5);
                                    }
                                    else
                                    {
                                        ConsoleError("Unable to upload role-group " + aGroup.group_key + " for " + aRole.role_name + ".");
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while uploading role.", e));
            }
            DebugWrite("uploadRole finished!", 6);
        }

        
        private void UploadBan(AdKatsBan aBan) {
            DebugWrite("uploadBan starting!", 6);

            Boolean success = false;
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return;
            }
            if (aBan == null) {
                ConsoleError("Ban invalid in uploadBan.");
            }
            else {
                try {
                    //Upload the inner record if needed
                    if (aBan.ban_record.record_id < 0) {
                        if (!UploadRecord(aBan.ban_record)) {
                            return;
                        }
                    }

                    using (MySqlConnection connection = GetDatabaseConnection()) {
                        using (MySqlCommand command = connection.CreateCommand()) {
                            command.CommandText = @"
                            INSERT INTO 
                            `" + _mySqlSchemaName + @"`.`adkats_bans` 
                            (
	                            `player_id`, 
	                            `latest_record_id`, 
	                            `ban_status`, 
	                            `ban_notes`, 
	                            `ban_startTime`, 
	                            `ban_endTime`, 
	                            `ban_enforceName`, 
	                            `ban_enforceGUID`, 
	                            `ban_enforceIP`, 
	                            `ban_sync`
                            ) 
                            VALUES 
                            (
	                            @player_id, 
	                            @latest_record_id, 
	                            @ban_status, 
	                            @ban_notes, 
	                            @ban_startTime, 
	                            DATE_ADD(@ban_startTime, INTERVAL @ban_durationMinutes MINUTE), 
	                            @ban_enforceName, 
	                            @ban_enforceGUID, 
	                            @ban_enforceIP, 
	                            @ban_sync
                            ) 
                            ON DUPLICATE KEY 
                            UPDATE 
	                            `latest_record_id` = @latest_record_id, 
	                            `ban_status` = @ban_status, 
	                            `ban_notes` = @ban_notes, 
	                            `ban_startTime` = @ban_startTime, 
	                            `ban_endTime` = DATE_ADD(@ban_startTime, INTERVAL @ban_durationMinutes MINUTE), 
	                            `ban_enforceName` = @ban_enforceName, 
	                            `ban_enforceGUID` = @ban_enforceGUID, 
	                            `ban_enforceIP` = @ban_enforceIP, 
	                            `ban_sync` = @ban_sync";

                            command.Parameters.AddWithValue("@player_id", aBan.ban_record.target_player.player_id);
                            command.Parameters.AddWithValue("@latest_record_id", aBan.ban_record.record_id);
                            if (String.IsNullOrEmpty(aBan.ban_status)) {
                                aBan.ban_exception = new AdKatsException("Ban status was null or empty when posting.");
                                HandleException(aBan.ban_exception);
                                return;
                            }
                            if (aBan.ban_status != "Active" && aBan.ban_status != "Disabled" && aBan.ban_status != "Expired") {
                                aBan.ban_exception = new AdKatsException("Ban status of '" + aBan.ban_status + "' was invalid when posting.");
                                HandleException(aBan.ban_exception);
                                return;
                            }
                            command.Parameters.AddWithValue("@ban_status", aBan.ban_status);
                            if (String.IsNullOrEmpty(aBan.ban_notes))
                                aBan.ban_notes = "NoNotes";
                            command.Parameters.AddWithValue("@ban_notes", aBan.ban_notes);
                            command.Parameters.AddWithValue("@ban_enforceName", aBan.ban_enforceName ? ('Y') : ('N'));
                            command.Parameters.AddWithValue("@ban_enforceGUID", aBan.ban_enforceGUID ? ('Y') : ('N'));
                            command.Parameters.AddWithValue("@ban_enforceIP", aBan.ban_enforceIP ? ('Y') : ('N'));
                            command.Parameters.AddWithValue("@ban_sync", "*" + _serverInfo.ServerID + "*");
                            //Handle permaban case
                            if (aBan.ban_record.command_action.command_key.Contains("player_ban_perm")) {
                                command.Parameters.AddWithValue("@ban_durationMinutes", (Int32) _PermaBanEndTime.Subtract(UtcDbTime()).TotalMinutes);
                            }
                            else {
                                command.Parameters.AddWithValue("@ban_durationMinutes", aBan.ban_record.command_numeric);
                            }
                            if (aBan.ban_record.command_action.command_key == "player_ban_perm_future") {
                                command.Parameters.AddWithValue("@ban_startTime", aBan.ban_record.record_time + TimeSpan.FromMinutes(aBan.ban_record.command_numeric));
                            }
                            else {
                                command.Parameters.AddWithValue("@ban_startTime", aBan.ban_record.record_time);
                            }
                            //Attempt to execute the query
                            if (SafeExecuteNonQuery(command) >= 0) {
                                //Rows affected should be > 0
                                DebugWrite("Success Uploading Ban on player " + aBan.ban_record.target_player.player_id, 5);
                                success = true;
                            }
                        }
                        if (success) {
                            using (MySqlCommand command = connection.CreateCommand()) {
                                command.CommandText = @"
                                SELECT 
                                    `ban_id`,
                                    `ban_startTime`, 
                                    `ban_endTime`,
                                    `ban_status`
                                FROM 
                                    `adkats_bans` 
                                WHERE 
                                    `player_id` = @player_id";

                                command.Parameters.AddWithValue("@player_id", aBan.ban_record.target_player.player_id);
                                //Attempt to execute the query
                                using (MySqlDataReader reader = SafeExecuteReader(command)) {
                                    //Grab the ban ID
                                    if (reader.Read()) {
                                        aBan.ban_id = reader.GetInt64("ban_id");
                                        aBan.ban_startTime = reader.GetDateTime("ban_startTime");
                                        aBan.ban_endTime = reader.GetDateTime("ban_endTime");
                                        String status = reader.GetString("ban_status");
                                        if (status != aBan.ban_status) {
                                            aBan.ban_exception = new AdKatsException("Ban status was invalid when confirming ban post. Your database is not in strict mode.");
                                            HandleException(aBan.ban_exception);
                                            return;
                                        }
                                        //Update setting page to reflect the ban count
                                        UpdateSettingPage();
                                        DebugWrite("Ban ID: " + aBan.ban_id, 5);
                                    }
                                    else {
                                        ConsoleError("Could not fetch ban information after upload");
                                    }
                                }
                            }
                        }
                    }

                    //Submit ban to metabans
                    if (aBan.ban_record.command_type.command_key != "banenforcer_enforce" && _useMetabans && !String.IsNullOrEmpty(_metabansUsername) && !String.IsNullOrEmpty(_metabansAPIKey))
                    {
                        SubmitToMetabans(aBan, AssessmentTypes.black);
                    }
                }
                catch (Exception e) {
                    HandleException(new AdKatsException("Error while uploading new ban.", e));
                }
            }
            DebugWrite("uploadBan finished!", 6);
        }

        private Boolean FetchMatchingPlayers(String playerName, out List<AdKatsPlayer> resultPlayers, Boolean verbose) {
            DebugWrite("FetchMatchingPlayers starting!", 6);
            resultPlayers = new List<AdKatsPlayer>();
            if (String.IsNullOrEmpty(playerName)) {
                if (verbose) {
                    ConsoleError("Player id was blank when fetching players.");
                }
                return false;
            }
            using (MySqlConnection connection = GetDatabaseConnection()) {
                using (MySqlCommand command = connection.CreateCommand()) {
                    command.CommandText = @"
                    SELECT 
	                    `PlayerID` AS `player_id`
                    FROM 
	                    `tbl_playerdata`
                    WHERE
	                    `SoldierName` LIKE '%" + playerName + "%'";
                    //Attempt to execute the query
                    using (MySqlDataReader reader = SafeExecuteReader(command)) {
                        //Grab the matching players
                        while (reader.Read()) {
                            AdKatsPlayer aPlayer = FetchPlayer(false, true, false, null, reader.GetInt64("player_id"), null, null, null);
                            if (aPlayer != null) {
                                resultPlayers.Add(aPlayer);
                            }
                        }
                        if (resultPlayers.Count == 0) {
                            if (verbose) {
                                ConsoleError("No players found matching '" + playerName + "'");
                            }
                            return false;
                        }
                    }
                }
            }
            DebugWrite("FetchMatchingPlayers finished!", 6);
            return true;
        }

        
        private AdKatsPlayer FetchPlayer(Boolean allowUpdate, Boolean allowOtherGames, Boolean allowNameSubstringSearch, Int32? gameID, Int64 playerID, String playerName, String playerGUID, String playerIP) {
            DebugWrite("fetchPlayer starting!", 6);
            //Create return list
            AdKatsPlayer aPlayer = null;
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                //If AdKats is disconnected from the database, return the player as-is
                aPlayer = new AdKatsPlayer(this) {
                    game_id = _serverInfo.GameID,
                    player_name = playerName,
                    player_guid = playerGUID,
                    player_ip = playerIP
                };
                AssignPlayerRole(aPlayer);
                return aPlayer;
            }
            if (playerID < 0 && String.IsNullOrEmpty(playerName) && String.IsNullOrEmpty(playerGUID) && String.IsNullOrEmpty(playerIP)) {
                ConsoleError("Attempted to fetch player with no information.");
            }
            else {
                try {
                    if (playerID > 0) {
                        if (_FetchedPlayers.ContainsKey(playerID)) {
                            DebugWrite("Attempting to fetch player " + playerID + " from pre-fetch list.", 6);
                            if (_FetchedPlayers.TryGetValue(playerID, out aPlayer)) {
                                DebugWrite("Player " + playerID + " successfully fetched from pre-fetch list.", 6);
                                return aPlayer;
                            }
                        }
                    }
                    using (MySqlConnection connection = GetDatabaseConnection()) {
                        using (MySqlCommand command = connection.CreateCommand())
                        {
                            String sql = @"
                            SELECT 
                                `PlayerID` as `player_id`, 
                                `SoldierName` as `player_name`, 
                                `EAGUID` as `player_guid`, 
                                `PBGUID` as `player_pbguid`, 
                                `IP_Address` as `player_ip`";
                            if (_serverInfo.GameID > 0)
                            {
                                sql += ",`GameID` as `game_id` ";
                            }
                            sql += "FROM `" + _mySqlSchemaName + @"`.`tbl_playerdata` ";
                            bool sqlEnder = true;
                            if (playerID >= 0)
                            {
                                sql += " WHERE ( ";
                                sqlEnder = false;
                                sql += " `PlayerID` = " + playerID + " ";
                            }
                            if (!String.IsNullOrEmpty(playerGUID))
                            {
                                if (sqlEnder)
                                {
                                    sql += " WHERE ( ";
                                    sqlEnder = false;
                                }
                                else
                                {
                                    sql += " OR ";
                                }
                                sql += " `EAGUID` = '" + playerGUID + "' ";
                            }
                            if (String.IsNullOrEmpty(playerGUID) && !String.IsNullOrEmpty(playerName))
                            {
                                if (sqlEnder)
                                {
                                    sql += " WHERE ( ";
                                    sqlEnder = false;
                                }
                                else
                                {
                                    sql += " OR ";
                                }
                                sql += " `SoldierName` LIKE '" + ((allowNameSubstringSearch) ? ("%" + playerName + "%") : (playerName)) + "' ";
                            }
                            if (String.IsNullOrEmpty(playerGUID) && !String.IsNullOrEmpty(playerIP))
                            {
                                if (sqlEnder)
                                {
                                    sql += " WHERE ( ";
                                    sqlEnder = false;
                                }
                                else
                                {
                                    sql += " OR ";
                                }
                                sql += " `IP_Address` = '" + playerIP + "' ";
                            }
                            if (!sqlEnder)
                            {
                                sql += " ) ";
                            }
                            if ((_serverInfo.GameID > 0 && !allowOtherGames) || gameID != null)
                            {
                                if (gameID != null)
                                {
                                    sql += " AND `GameID` = " + gameID + " ";
                                }
                                else
                                {
                                    sql += " AND `GameID` = " + _serverInfo.GameID + " ";
                                }
                            }
                            sql += @"
                            LIMIT 1";
                            command.CommandText = sql;
                            using (MySqlDataReader reader = SafeExecuteReader(command))
                            {
                                if (reader.Read())
                                {
                                    aPlayer = new AdKatsPlayer(this);
                                    //Player ID will never be null
                                    aPlayer.player_id = reader.GetInt64("player_id");
                                    if (_serverInfo.GameID > 0)
                                    {
                                        aPlayer.game_id = reader.GetInt32("game_id");
                                    }
                                    if (!reader.IsDBNull(1))
                                        aPlayer.player_name = reader.GetString("player_name");
                                    if (!reader.IsDBNull(2))
                                        aPlayer.player_guid = reader.GetString("player_guid");
                                    if (!reader.IsDBNull(3))
                                        aPlayer.player_pbguid = reader.GetString("player_pbguid");
                                    if (!reader.IsDBNull(4))
                                        aPlayer.player_ip = reader.GetString("player_ip");
                                }
                                else
                                {
                                    DebugWrite("No player matching search information. " + 
                                        allowUpdate + ", " + 
                                        allowOtherGames + ", " + 
                                        ((gameID != null) ? (gameID + "") : ("No game ID")) + ", " + 
                                        playerID + ", " + 
                                        ((!String.IsNullOrEmpty(playerName)) ? (playerName) : ("No name search")) + ", " + 
                                        ((!String.IsNullOrEmpty(playerGUID)) ? (playerGUID) : ("No GUID search")) + ", " + 
                                        ((!String.IsNullOrEmpty(playerIP)) ? (playerIP) : ("No IP search")), 4);
                                }
                            }
                        }
                        if (allowUpdate) {
                            if (aPlayer == null) {
                                DebugWrite("Adding player to database.", 5);
                                using (MySqlCommand command = connection.CreateCommand()) {
                                    Int32? useableGameID = null;
                                    if (gameID != null) {
                                        useableGameID = gameID;
                                    }
                                    else if (_serverInfo.GameID > 0)
                                    {
                                        useableGameID = (Int32?)_serverInfo.GameID;
                                    }
                                    //Set the insert command structure
                                    //The on duplicate key clause should never be hit, but is placed there to avoid exceptions in rare edge cases
                                    Boolean hasPrevious = (_serverInfo.GameID > 0) || !String.IsNullOrEmpty(playerName) || !String.IsNullOrEmpty(playerGUID) || !String.IsNullOrEmpty(playerIP);
                                    command.CommandText = @"
                                    INSERT INTO `" + _mySqlSchemaName + @"`.`tbl_playerdata` 
                                    (
                                        " + ((useableGameID != null) ? ("`GameID`") : ("")) + @"
                                        " + ((!String.IsNullOrEmpty(playerName)) ? (((useableGameID != null) ? (",") : ("")) + "`SoldierName`") : ("")) + @"
                                        " + ((!String.IsNullOrEmpty(playerGUID)) ? ((hasPrevious ? (",") : ("")) + "`EAGUID`") : ("")) + @"
                                        " + ((!String.IsNullOrEmpty(playerIP)) ? ((hasPrevious ? (",") : ("")) + "`IP_Address`") : ("")) + @"
                                    ) 
                                    VALUES 
                                    (
                                        " + ((useableGameID != null) ? (useableGameID + "") : ("")) + @"
                                        " + ((!String.IsNullOrEmpty(playerName)) ? (((useableGameID != null) ? (",") : ("")) + "'" + playerName + "'") : ("")) + @"
                                        " + ((!String.IsNullOrEmpty(playerGUID)) ? ((hasPrevious ? (",") : ("")) + "'" + playerGUID + "'") : ("")) + @"
                                        " + ((!String.IsNullOrEmpty(playerIP)) ? ((hasPrevious ? (",") : ("")) + "'" + playerIP + "'") : ("")) + @"
                                    )
                                    ON DUPLICATE KEY 
                                    UPDATE 
                                        `PlayerID` = LAST_INSERT_ID(`PlayerID`)
                                        " + ((!String.IsNullOrEmpty(playerName)) ? (@",`SoldierName` = '" + playerName + "'") : ("")) + @"
                                        " + ((!String.IsNullOrEmpty(playerGUID)) ? (@",`EAGUID` = '" + playerGUID + "'") : ("")) + @"
                                        " + ((!String.IsNullOrEmpty(playerIP)) ? (@",`IP_Address` = '" + playerIP + "'") : (""));
                                    //Attempt to execute the query
                                    if (SafeExecuteNonQuery(command) > 0) {
                                        //Rows affected should be > 0
                                        aPlayer = new AdKatsPlayer(this) {
                                            player_id = command.LastInsertedId,
                                            player_name = playerName,
                                            player_guid = playerGUID,
                                            player_ip = playerIP
                                        };
                                        if (useableGameID != null) {
                                            aPlayer.game_id = (long) useableGameID;
                                        }
                                        else {
                                            aPlayer.game_id = _serverInfo.GameID;
                                        }
                                        aPlayer.player_new = true;
                                    }
                                    else {
                                        ConsoleError("Unable to add player to database.");
                                        return null;
                                    }
                                }
                            }
                            //check for name changes
                            if (!String.IsNullOrEmpty(playerName) && !String.IsNullOrEmpty(aPlayer.player_guid) && playerName != aPlayer.player_name) {
                                aPlayer.player_name_previous = aPlayer.player_name;
                                aPlayer.player_name = playerName;
                                var record = new AdKatsRecord {
                                    record_source = AdKatsRecord.Sources.InternalAutomated,
                                    server_id = _serverInfo.ServerID,
                                    command_type = GetCommandByKey("player_changename"),
                                    command_numeric = 0,
                                    target_name = aPlayer.player_name,
                                    target_player = aPlayer,
                                    source_name = "AdKats",
                                    record_message = aPlayer.player_name_previous
                                };
                                QueueRecordForProcessing(record);
                                DebugWrite(aPlayer.player_name_previous + " changed their name to " + playerName + ". Updating the database.", 2);
                                if (_ShowPlayerNameChangeAnnouncement)
                                {
                                    OnlineAdminSayMessage(aPlayer.player_name_previous + " changed their name to " + playerName);
                                }
                                UpdatePlayer(aPlayer);
                            }
                        }

                        if (aPlayer == null) {
                            return null;
                        }

                        //Assign player role
                        AssignPlayerRole(aPlayer);

                        //Pull player first seen
                        if (aPlayer.player_id > 0)
                        {
                            using (MySqlCommand command = connection.CreateCommand())
                            {
                                command.CommandText = @"
                                SELECT
                                    FirstSeenOnServer
                                FROM
                                    tbl_server_player
                                        INNER JOIN
                                    tbl_playerstats ON tbl_playerstats.StatsID = tbl_server_player.StatsID
                                WHERE
                                    tbl_server_player.PlayerID = @player_id
                                ORDER BY 
	                                tbl_playerstats.FirstSeenOnServer
                                LIMIT 1";
                                command.Parameters.AddWithValue("@player_id", aPlayer.player_id);
                                using (MySqlDataReader reader = SafeExecuteReader(command))
                                {
                                    if (reader.Read())
                                    {
                                        aPlayer.player_firstseen = reader.GetDateTime("FirstSeenOnServer");
                                    }
                                    else
                                    {
                                        aPlayer.player_firstseen = UtcDbTime();
                                        DebugWrite("No stats found to fetch first seen time.", 5);
                                    }
                                }
                            }

                            using (MySqlCommand command = connection.CreateCommand())
                            {
                                command.CommandText = @"
                                SELECT
                                    (Playtime/60) as playtime_minutes
                                FROM
                                    tbl_server_player
                                        INNER JOIN
                                    tbl_playerstats ON tbl_playerstats.StatsID = tbl_server_player.StatsID
                                WHERE
                                    tbl_server_player.PlayerID = @player_id
                                AND
	                                tbl_server_player.Serverid = @server_id
                                ORDER BY
	                                Serverid ASC";
                                command.Parameters.AddWithValue("@player_id", aPlayer.player_id);
                                command.Parameters.AddWithValue("@server_id", _serverInfo.ServerID);
                                using (MySqlDataReader reader = SafeExecuteReader(command))
                                {
                                    if (reader.Read())
                                    {
                                        aPlayer.player_serverplaytime = TimeSpan.FromMinutes(reader.GetDouble("playtime_minutes"));
                                    }
                                    else
                                    {
                                        DebugWrite("No stats found to fetch time on server.", 5);
                                    }
                                }
                            }
                        }
                    }
                    if (aPlayer != null && aPlayer.player_id > 0)
                    {
                        _FetchedPlayers[aPlayer.player_id] = aPlayer;
                    }
                }
                catch (Exception e) {
                    HandleException(new AdKatsException("Error while fetching player.", e));
                }
            }
            DebugWrite("fetchPlayer finished!", 6);
            return aPlayer;
        }

        private AdKatsPlayer UpdatePlayer(AdKatsPlayer aPlayer) {
            DebugWrite("updatePlayer starting!", 6);
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return aPlayer;
            }
            if (aPlayer == null || aPlayer.player_id < 0 || (String.IsNullOrEmpty(aPlayer.player_name) && String.IsNullOrEmpty(aPlayer.player_guid) & String.IsNullOrEmpty(aPlayer.player_ip))) {
                ConsoleError("Attempted to update player without required information.");
            }
            else {
                try {
                    using (MySqlConnection connection = GetDatabaseConnection()) {
                        using (MySqlCommand command = connection.CreateCommand()) {
                            //Set the insert command structure
                            command.CommandText = @"
                            UPDATE IGNORE 
                                `tbl_playerdata` 
                            SET
                                `SoldierName` = @player_name,
                                `EAGUID` = @player_guid,
                                `ClanTag` = @player_clanTag,
                                `IP_Address` = @player_ip
                            WHERE
                                `PlayerID` = @player_id";
                            command.Parameters.AddWithValue("@player_id", aPlayer.player_id);
                            command.Parameters.AddWithValue("@player_name", aPlayer.player_name);
                            command.Parameters.AddWithValue("@player_guid", aPlayer.player_guid);
                            command.Parameters.AddWithValue("@player_clanTag", aPlayer.player_clanTag);
                            command.Parameters.AddWithValue("@player_ip", aPlayer.player_ip);
                            //Attempt to execute the query
                            if (SafeExecuteNonQuery(command) > 0) {
                                DebugWrite("Update player info success.", 5);
                            }
                        }
                    }
                }
                catch (Exception e) {
                    HandleException(new AdKatsException("Error while updating player.", e));
                }
            }
            DebugWrite("updatePlayer finished!", 6);
            return aPlayer;
        }

        private AdKatsBan FetchBanByID(Int64 ban_id)
        {
            DebugWrite("FetchBanByID starting!", 6);
            AdKatsBan aBan = null;
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                return null;
            }
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        //Build the query
                        command.CommandText = @"
                        SELECT 
                            `ban_id`, 
                            `player_id`, 
                            `latest_record_id`, 
                            `ban_status`, 
                            `ban_notes`, 
                            `ban_startTime`, 
                            `ban_endTime`, 
                            `ban_enforceName`, 
                            `ban_enforceGUID`, 
                            `ban_enforceIP`, 
                            `ban_sync`
                        FROM 
                            `adkats_bans` 
                        WHERE 
                            `ban_id` = @ban_id";
                        command.Parameters.AddWithValue("@ban_id", ban_id);
                        using (MySqlDataReader reader = SafeExecuteReader(command))
                        {
                            if (reader.Read())
                            {
                                //Create the ban object
                                aBan = new AdKatsBan
                                {
                                    ban_id = reader.GetInt64("ban_id"),
                                    ban_status = reader.GetString("ban_status"),
                                    ban_notes = reader.GetString("ban_notes"),
                                    ban_sync = reader.GetString("ban_sync"),
                                    ban_startTime = reader.GetDateTime("ban_startTime"),
                                    ban_endTime = reader.GetDateTime("ban_endTime"),
                                    ban_enforceName = (reader.GetString("ban_enforceName") == "Y"),
                                    ban_enforceGUID = (reader.GetString("ban_enforceGUID") == "Y"),
                                    ban_enforceIP = (reader.GetString("ban_enforceIP") == "Y"),
                                    ban_record = FetchRecordByID(reader.GetInt64("latest_record_id"), false)
                                };
                                if (aBan.ban_endTime.Subtract(UtcDbTime()).TotalSeconds < 0)
                                {
                                    aBan.ban_status = "Expired";
                                    UpdateBanStatus(aBan);
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching ban.", e));
            }
            DebugWrite("FetchBanByID finished!", 6);
            return aBan;
        }

        
        private List<AdKatsBan> FetchPlayerBans(AdKatsPlayer player)
        {
            DebugWrite("FetchPlayerBans starting!", 6);
            var aBanList = new List<AdKatsBan>();
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                return null;
            }
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        //Build the query
                        String query = @"
                        SELECT 
                            `adkats_bans`.`ban_id`,
                            `adkats_bans`.`player_id`, 
                            `adkats_bans`.`latest_record_id`, 
                            `adkats_bans`.`ban_status`, 
                            `adkats_bans`.`ban_notes`, 
                            `adkats_bans`.`ban_startTime`, 
                            `adkats_bans`.`ban_endTime`, 
                            `adkats_bans`.`ban_enforceName`, 
                            `adkats_bans`.`ban_enforceGUID`, 
                            `adkats_bans`.`ban_enforceIP`, 
                            `adkats_bans`.`ban_sync`
                        FROM 
                            `adkats_bans` 
                        INNER JOIN 
                            `tbl_playerdata` 
                        ON 
                            `tbl_playerdata`.`PlayerID` = `adkats_bans`.`player_id` 
                        WHERE 
                            `adkats_bans`.`ban_status` = 'Active' ";
                        if (_serverInfo.GameID > 0 && player.game_id < 0)
                        {
                            query += " AND `tbl_playerdata`.`GameID` = " + _serverInfo.GameID;
                        }
                        else if (player.game_id > 0) {
                            query += " AND `tbl_playerdata`.`GameID` = " + player.game_id;
                        }
                        else {
                            ConsoleError("Unusable game IDs when fetching player bans for " + player.player_name + ".");
                            return aBanList;
                        }
                        query += " AND (";
                        Boolean started = false;
                        if (!String.IsNullOrEmpty(player.player_name))
                        {
                            started = true;
                            query += "(`tbl_playerdata`.`SoldierName` = '" + player.player_name + @"' AND `adkats_bans`.`ban_enforceName` = 'Y')";
                        }
                        if (!String.IsNullOrEmpty(player.player_guid))
                        {
                            if (started)
                            {
                                query += " OR ";
                            }
                            started = true;
                            query += "(`tbl_playerdata`.`EAGUID` = '" + player.player_guid + "' AND `adkats_bans`.`ban_enforceGUID` = 'Y')";
                        }
                        if (!String.IsNullOrEmpty(player.player_ip))
                        {
                            if (started)
                            {
                                query += " OR ";
                            }
                            started = true;
                            query += "(`tbl_playerdata`.`IP_Address` = '" + player.player_ip + "' AND `adkats_bans`.`ban_enforceIP` = 'Y')";
                        }
                        if (!started)
                        {
                            HandleException(new AdKatsException("No data to fetch ban with. This should never happen."));
                            return aBanList;
                        }
                        query += ")";

                        //Assign the query
                        command.CommandText = query;

                        using (MySqlDataReader reader = SafeExecuteReader(command))
                        {
                            while (reader.Read())
                            {
                                //Create the ban element
                                var aBan = new AdKatsBan
                                {
                                    ban_id = reader.GetInt64("ban_id"),
                                    ban_status = reader.GetString("ban_status"),
                                    ban_notes = reader.GetString("ban_notes"),
                                    ban_sync = reader.GetString("ban_sync"),
                                    ban_startTime = reader.GetDateTime("ban_startTime"),
                                    ban_endTime = reader.GetDateTime("ban_endTime"),
                                    ban_enforceName = (reader.GetString("ban_enforceName") == "Y"),
                                    ban_enforceGUID = (reader.GetString("ban_enforceGUID") == "Y"),
                                    ban_enforceIP = (reader.GetString("ban_enforceIP") == "Y"),
                                    ban_record = FetchRecordByID(reader.GetInt64("latest_record_id"), false)
                                };
                                if (aBan.ban_endTime.Subtract(UtcDbTime()).TotalSeconds < 0)
                                {
                                    aBan.ban_status = "Expired";
                                    UpdateBanStatus(aBan);
                                }
                                else if (!String.IsNullOrEmpty(player.player_name_previous) && aBan.ban_enforceName && !aBan.ban_enforceGUID && !aBan.ban_enforceIP)
                                {
                                    var record = new AdKatsRecord
                                    {
                                        record_source = AdKatsRecord.Sources.InternalAutomated,
                                        server_id = _serverInfo.ServerID,
                                        command_type = GetCommandByKey("player_unban"),
                                        command_numeric = 0,
                                        target_name = player.player_name,
                                        target_player = player,
                                        source_name = "BanEnforcer",
                                        record_message = "Name-Banned player has changed their name. (" + player.player_name_previous + " -> " + player.player_name + ")"
                                    };
                                    QueueRecordForProcessing(record);
                                }
                                else if (_serverInfo.ServerGroup == FetchServerGroup(aBan.ban_record.server_id) && aBan.ban_startTime < UtcDbTime())
                                {
                                    aBanList.Add(aBan);
                                }
                            }
                            if (aBanList.Count > 1)
                            {
                                ConsoleWarn("Multiple bans matched player information, linked accounts detected.");
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching player ban.", e));
            }
            DebugWrite("FetchPlayerBans finished!", 6);
            return aBanList;
        }

        
        private List<AdKatsBan> FetchMatchingBans(String playerSubstring, Int64 searchLimit)
        {
            DebugWrite("FetchMatchingBans starting!", 6);
            var aBanList = new List<AdKatsBan>();
            //Make sure database connection active
            if (HandlePossibleDisconnect())
            {
                return null;
            }
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        //Build the query
                        command.CommandText = @"
                        SELECT
	                        `ban_id`
                        FROM
	                        `tbl_playerdata`
                        INNER JOIN
	                        `adkats_bans`
                        ON
	                        `PlayerID` = `player_id`
                        INNER JOIN
	                        `adkats_records_main`
                        ON
	                        `latest_record_id` = `record_id`
                        WHERE 
	                        `ban_status` = 'Active'
                        AND
                        (
	                        `SoldierName` LIKE @PlayerSubstring
                            OR
                            `target_name` LIKE @PlayerSubstring
                        )
                        ORDER BY
                            `record_time` DESC 
                        LIMIT
                            @searchLimit";
                        //Add the search value
                        command.Parameters.Add("@PlayerSubstring", "%" + playerSubstring + "%");
                        command.Parameters.Add("@searchLimit", searchLimit);
                        using (MySqlDataReader reader = SafeExecuteReader(command))
                        {
                            while (reader.Read())
                            {
                                aBanList.Add(FetchBanByID(reader.GetInt64("ban_id")));
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching player ban.", e));
            }
            return aBanList;
        }

        
        private void RepopulateProconBanList() {
            DebugWrite("repopulateProconBanList starting!", 6);
            ConsoleInfo("Downloading bans from database, please wait. This might take several minutes depending on your ban count!");

            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return;
            }
            Double totalBans = 0;
            Double bansDownloaded = 0;
            Double bansRepopulated = 0;
            Boolean earlyExit = false;
            DateTime startTime = UtcDbTime();

            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            COUNT(*) AS `ban_count`
                        FROM 
	                        `adkats_bans`";

                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                totalBans = reader.GetInt64("ban_count");
                            }
                        }
                    }
                    if (totalBans < 1) {
                        return;
                    }
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            `ban_id`, 
                            `player_id`, 
                            `latest_record_id`, 
	                        `ban_status`, 
                            `ban_notes`, 
	                        `ban_sync`, 
	                        `ban_startTime`, 
	                        `ban_endTime`, 
	                        `ban_enforceName`, 
	                        `ban_enforceGUID`, 
	                        `ban_enforceIP` 
                        FROM 
	                        `adkats_bans`";

                        var importedBans = new List<AdKatsBan>();
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            //Loop through all incoming bans
                            while (reader.Read()) {
                                //Break from the loop if the plugin is disabled or the setting is reverted.
                                if (!_pluginEnabled || _UseBanEnforcer) {
                                    ConsoleWarn("You exited the ban download process early, the process was not completed.");
                                    earlyExit = true;
                                    break;
                                }
                                //Create the ban element
                                var aBan = new AdKatsBan {
                                    ban_id = reader.GetInt64("ban_id"),
                                    player_id = reader.GetInt64("player_id"),
                                    ban_status = reader.GetString("ban_status"),
                                    ban_notes = reader.GetString("ban_notes"),
                                    ban_sync = reader.GetString("ban_sync"),
                                    ban_startTime = reader.GetDateTime("ban_startTime"),
                                    ban_endTime = reader.GetDateTime("ban_endTime"),
                                    ban_record = FetchRecordByID(reader.GetInt64("latest_record_id"), false),
                                    ban_enforceName = (reader.GetString("ban_enforceName") == "Y"),
                                    ban_enforceGUID = (reader.GetString("ban_enforceGUID") == "Y"),
                                    ban_enforceIP = (reader.GetString("ban_enforceIP") == "Y")
                                };
                                if (aBan.ban_record == null) {
                                    aBan.ban_record = new AdKatsRecord {
                                        record_source = AdKatsRecord.Sources.InternalAutomated,
                                        isDebug = false,
                                        target_player = FetchPlayer(false, true, false, null, aBan.player_id, null, null, null),
                                        source_name = "AdKats",
                                        record_message = "Ban Reason Expunged"
                                    };
                                    aBan.ban_record.target_name = aBan.ban_record.target_player.player_name;
                                }
                                if (aBan.ban_record.target_player == null) {
                                    aBan.ban_record.target_player = FetchPlayer(false, true, false, null, aBan.player_id, null, null, null);
                                }
                                if (aBan.ban_record.target_player != null) {
                                    importedBans.Add(aBan);
                                    if (++bansDownloaded % 15 == 0) {
                                        ConsoleWrite(Math.Round(100 * bansDownloaded / totalBans, 2) + "% of bans downloaded. AVG " + Math.Round(bansDownloaded / ((UtcDbTime() - startTime).TotalSeconds), 2) + " downloads/sec.");
                                    }
                                }
                            }
                        }
                        if (importedBans.Count > 0) {
                            ConsoleInfo(importedBans.Count + " bans downloaded, beginning repopulation to ban list.");
                        }
                        startTime = UtcDbTime();
                        foreach (AdKatsBan aBan in importedBans) {
                            //Get the record information
                            var totalBanSeconds = (long) aBan.ban_endTime.Subtract(UtcDbTime()).TotalSeconds;
                            if (totalBanSeconds > 0) {
                                DebugWrite("Re-ProconBanning: " + aBan.ban_record.GetTargetNames() + " for " + totalBanSeconds + "sec for " + aBan.ban_record.record_message, 4);

                                //Push the id ban
                                if (aBan.ban_enforceName) {
                                    _threadMasterWaitHandle.WaitOne(75);
                                    //Permabans and Temp bans longer than 1 year will be defaulted to permaban
                                    if (totalBanSeconds > 0 && totalBanSeconds < 31536000) {
                                        ExecuteCommand("procon.protected.send", "banList.add", "id", aBan.ban_record.target_player.player_name, "seconds", totalBanSeconds + "", aBan.ban_record.record_message);
                                    }
                                    else {
                                        ExecuteCommand("procon.protected.send", "banList.add", "id", aBan.ban_record.target_player.player_name, "perm", aBan.ban_record.record_message);
                                    }
                                }

                                //Push the guid ban
                                if (aBan.ban_enforceGUID) {
                                    _threadMasterWaitHandle.WaitOne(75);
                                    //Permabans and Temp bans longer than 1 year will be defaulted to permaban
                                    if (totalBanSeconds > 0 && totalBanSeconds < 31536000) {
                                        ExecuteCommand("procon.protected.send", "banList.add", "guid", aBan.ban_record.target_player.player_guid, "seconds", totalBanSeconds + "", aBan.ban_record.record_message);
                                    }
                                    else {
                                        ExecuteCommand("procon.protected.send", "banList.add", "guid", aBan.ban_record.target_player.player_guid, "perm", aBan.ban_record.record_message);
                                    }
                                }

                                //Push the IP ban
                                if (aBan.ban_enforceIP) {
                                    _threadMasterWaitHandle.WaitOne(75);
                                    //Permabans and Temp bans longer than 1 year will be defaulted to permaban
                                    if (totalBanSeconds > 0 && totalBanSeconds < 31536000) {
                                        ExecuteCommand("procon.protected.send", "banList.add", "ip", aBan.ban_record.target_player.player_ip, "seconds", totalBanSeconds + "", aBan.ban_record.record_message);
                                    }
                                    else {
                                        ExecuteCommand("procon.protected.send", "banList.add", "ip", aBan.ban_record.target_player.player_ip, "perm", aBan.ban_record.record_message);
                                    }
                                }
                            }

                            if (++bansRepopulated % 15 == 0) {
                                ConsoleWrite(Math.Round(100 * bansRepopulated / totalBans, 2) + "% of bans repopulated. AVG " + Math.Round(bansRepopulated / ((UtcDbTime() - startTime).TotalSeconds), 2) + " downloads/sec.");
                            }
                        }
                        ExecuteCommand("procon.protected.send", "banList.save");
                        ExecuteCommand("procon.protected.send", "banList.list");
                        if (!earlyExit) {
                            ConsoleSuccess("All AdKats Enforced bans repopulated to procon's ban list.");
                        }

                        //Update the last db ban fetch time
                        _lastDbBanFetch = UtcDbTime();
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while repopulating procon banlist.", e));
            }
        }

        
        private Boolean UpdateBanStatus(AdKatsBan aBan) {
            DebugWrite("updateBanStatus starting!", 6);
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return false;
            }

            Boolean success = false;
            if (aBan == null) {
                ConsoleError("Ban invalid in updateBanStatus.");
            }
            else {
                try {
                    //Conditionally modify the ban_sync for this server
                    if (!aBan.ban_sync.Contains("*" + _serverInfo.ServerID + "*")) {
                        aBan.ban_sync += ("*" + _serverInfo.ServerID + "*");
                    }

                    using (MySqlConnection connection = GetDatabaseConnection()) {
                        using (MySqlCommand command = connection.CreateCommand()) {
                            String query = @"
                            UPDATE 
                            `" + _mySqlSchemaName + @"`.`adkats_bans` 
                            SET 
                            `ban_sync` = '" + aBan.ban_sync + @"', 
                            `ban_status` = '" + aBan.ban_status + @"'
                            WHERE 
                            `ban_id` = " + aBan.ban_id;
                            command.CommandText = query;
                            //Attempt to execute the query
                            if (SafeExecuteNonQuery(command) > 0) {
                                success = true;
                            }
                        }
                    }
                }
                catch (Exception e) {
                    HandleException(new AdKatsException("Error while updating status of ban.", e));
                }
            }

            DebugWrite("updateBanStatus finished!", 6);
            return success;
        }

        
        private void ImportBansFromBBM5108() {
            //Check if tables exist from BF3 Ban Manager
            if (!ConfirmTable("bm_banlist")) {
                return;
            }
            ConsoleInfo("BF3 Ban Manager tables detected. Checking validity.");

            //Check if any BBM5108 bans exist in the AdKats Banlist
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            * 
                        FROM 
                            `" + _mySqlSchemaName + @"`.`adkats_bans` 
                        WHERE 
                            `adkats_bans`.`ban_notes` = 'BBM5108' 
                        LIMIT 1";

                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                ConsoleInfo("BF3 Ban Manager bans already imported, canceling import.");
                                return;
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while checking for BBM Bans.", e));
                return;
            }

            ConsoleSuccess("Validity confirmed.");
            ConsoleInfo("Preparing to fetch all BF3 Ban Manager Bans...");
            Double totalBans = 0;
            Double bansImported = 0;
            var inboundBBMBans = new Queue<BBM5108Ban>();
            DateTime startTime = UtcDbTime();
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        DebugWrite("Creating query to import BBM5108", 3);
                        command.CommandText = @"
                        SELECT 
                            soldiername, eaguid, ban_length, ban_duration, ban_reason 
                        FROM 
                            bm_banlist 
                        INNER JOIN 
                            bm_soldiers 
                        ON 
                            bm_banlist.soldierID = bm_soldiers.soldierID";

                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            Boolean told = false;
                            while (reader.Read()) {
                                if (!told) {
                                    DebugWrite("BBM5108 bans found, grabbing.", 3);
                                    told = true;
                                }
                                var bbmBan = new BBM5108Ban {
                                    soldiername = reader.IsDBNull(reader.GetOrdinal("soldiername")) ? null : reader.GetString("soldiername"),
                                    eaguid = reader.IsDBNull(reader.GetOrdinal("eaguid")) ? null : reader.GetString("eaguid"),
                                    ban_length = reader.GetString("ban_length"),
                                    ban_duration = reader.GetDateTime("ban_duration"),
                                    ban_reason = reader.IsDBNull(reader.GetOrdinal("ban_reason")) ? null : reader.GetString("ban_reason")
                                };
                                inboundBBMBans.Enqueue(bbmBan);
                                totalBans++;
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching BBM Bans.", e));
                return;
            }
            ConsoleInfo(totalBans + " Ban Manager bans fetched, starting import to AdKats Ban Enforcer...");

            try {
                //Loop through all BBMBans in order that they came in
                while (inboundBBMBans.Count > 0) {
                    //Break from the loop if the plugin is disabled or the setting is reverted.
                    if (!_pluginEnabled || !_UseBanEnforcer) {
                        ConsoleError("You exited the ban import process process early, the process was not completed and cannot recover without manual override. Talk to ColColonCleaner.");
                        break;
                    }

                    BBM5108Ban bbmBan = inboundBBMBans.Dequeue();

                    //Create the record
                    var record = new AdKatsRecord();
                    //Fetch the player
                    record.target_player = FetchPlayer(true, true, false, null, -1, bbmBan.soldiername, bbmBan.eaguid, null);

                    record.record_source = AdKatsRecord.Sources.InternalAutomated;
                    if (bbmBan.ban_length == "permanent") {
                        DebugWrite("Ban is permanent", 4);
                        record.command_type = GetCommandByKey("player_ban_perm");
                        record.command_action = GetCommandByKey("player_ban_perm");
                        record.command_numeric = 0;
                    }
                    else if (bbmBan.ban_length == "seconds") {
                        DebugWrite("Ban is temporary", 4);
                        record.command_type = GetCommandByKey("player_ban_temp");
                        record.command_action = GetCommandByKey("player_ban_temp");
                        record.command_numeric = (Int32) (bbmBan.ban_duration - UtcDbTime()).TotalMinutes;
                    }
                    else {
                        //Ignore all other cases e.g. round bans
                        DebugWrite("Ban type '" + bbmBan.ban_length + "' not usable", 3);
                        continue;
                    }

                    record.source_name = "BanEnforcer";
                    record.server_id = _serverInfo.ServerID;
                    if (!String.IsNullOrEmpty(record.target_player.player_name)) {
                        record.target_name = record.target_player.player_name;
                    }
                    record.isIRO = false;
                    record.record_message = bbmBan.ban_reason;

                    //Update the ban enforcement depending on available information
                    Boolean nameAvailable = !String.IsNullOrEmpty(record.target_player.player_name);
                    Boolean guidAvailable = !String.IsNullOrEmpty(record.target_player.player_guid);
                    Boolean ipAvailable = !String.IsNullOrEmpty(record.target_player.player_ip);

                    //Create the ban
                    var aBan = new AdKatsBan {
                        ban_record = record,
                        ban_notes = "BBM5108",
                        ban_enforceName = nameAvailable && (_DefaultEnforceName || (!guidAvailable && !ipAvailable) || !String.IsNullOrEmpty(bbmBan.soldiername)),
                        ban_enforceGUID = guidAvailable && (_DefaultEnforceGUID || (!nameAvailable && !ipAvailable) || !String.IsNullOrEmpty(bbmBan.eaguid)),
                        ban_enforceIP = ipAvailable && _DefaultEnforceIP
                    };
                    if (!aBan.ban_enforceName && !aBan.ban_enforceGUID && !aBan.ban_enforceIP) {
                        ConsoleError("Unable to create ban, no proper player information");
                        continue;
                    }

                    //Upload the ban
                    DebugWrite("Uploading Ban Manager ban.", 5);
                    UploadBan(aBan);

                    if (++bansImported % 25 == 0) {
                        ConsoleWrite(Math.Round(100 * bansImported / totalBans, 2) + "% of Ban Manager bans uploaded. AVG " + Math.Round(bansImported / ((UtcDbTime() - startTime).TotalSeconds), 2) + " uploads/sec.");
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while processing imported BBM Bans to AdKats banlist.", e));
                return;
            }
            if (inboundBBMBans.Count == 0) {
                ConsoleSuccess("All Ban Manager bans imported into AdKats Ban Enforcer!");
            }
        }

        
        private Boolean CanPunish(AdKatsRecord record, Int32 duration) {
            DebugWrite("canPunish starting!", 6);
            if (duration < 1) {
                ConsoleError("CanPunish duration must be positive.");
                return false;
            }
            //TODO: Add check for multiple targets
            if (record.target_player != null && 
                record.target_player.TargetedRecords.Any(
                    aRecord => 
                        aRecord.command_type.command_key == "player_punish" && 
                        (UtcDbTime() - aRecord.record_time).TotalSeconds < duration)) {
                return false;
            }
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                record.record_exception = new AdKatsException("Database not connected.");
                return false;
            }
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            `record_time` AS `latest_time` 
                        FROM 
                            `adkats_records_main` 
                        WHERE 
                            `adkats_records_main`.`command_type` = " + GetCommandByKey("player_punish").command_id + @" 
                        AND 
                            `adkats_records_main`.`target_id` = " + record.target_player.player_id + @" 
                        AND 
                            DATE_ADD(`record_time`, INTERVAL " + duration + @" SECOND) > UTC_TIMESTAMP() 
                        ORDER BY 
                            `record_time` 
                        DESC LIMIT 1";

                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                DebugWrite("can't upload punish", 6);
                                return false;
                            }
                            return true;
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while checking if player can be punished.", e));
                //Assume false if any errors
                return false;
            }
        }

        
        private Boolean FetchIROStatus(AdKatsRecord record) {
            DebugWrite("FetchIROStatus starting!", 6);
            try
            {
                //TODO: Add check for multiple targets
                if (record.target_player != null &&
                    record.target_player.TargetedRecords.Any(
                        aRecord =>
                            aRecord.command_type.command_key == "player_punish" &&
                            (UtcDbTime() - aRecord.record_time).TotalSeconds < _IROTimeout))
                {
                    return true;
                }
                //Make sure database connection active
                if (HandlePossibleDisconnect())
                {
                    record.record_exception = new AdKatsException("Database not connected.");
                    return false;
                }
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
	                        `record_time` AS `latest_time` 
                        FROM 
	                        `adkats_records_main`
                        INNER JOIN
	                        `adkats_commands`
                        ON
	                        `adkats_records_main`.`command_type` = `adkats_commands`.`command_id`
                        WHERE 
	                        `adkats_commands`.`command_key` = 'player_punish' 
                        AND 
                            `adkats_records_main`.`target_id` = " + record.target_player.player_id + @" 
                        AND 
                            DATE_ADD(`record_time`, INTERVAL " + _IROTimeout + @" MINUTE) > UTC_TIMESTAMP() 
                        ORDER BY 
                            `record_time` 
                        DESC LIMIT 1";
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                DebugWrite("Punish is Double counted", 6);
                                return true;
                            }
                            return false;
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while checking if punish will be IRO.", e));
                //Assume false if any errors
                return false;
            }
        }

        
        private void RunActionsFromDB() {
            DebugWrite("runActionsFromDB starting!", 7);
            //Make sure database connection active
            if (HandlePossibleDisconnect() || !_firstPlayerListComplete) {
                return;
            }
            try {
                foreach (AdKatsRecord record in FetchUnreadRecords()) {
                    QueueRecordForActionHandling(record);
                }
                //Update the last time this was fetched
                _lastDbActionFetch = UtcDbTime();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while queueing unread records for action handling.", e));
            }
        }

        
        private Int32 FetchPoints(AdKatsPlayer player, Boolean combineOverride) {
            DebugWrite("fetchPoints starting!", 6);

            Int32 returnVal = -1;
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return returnVal;
            }

            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        if (_CombineServerPunishments || combineOverride) {
                            command.CommandText = @"SELECT `total_points` FROM `" + _mySqlSchemaName + @"`.`adkats_infractions_global` WHERE `player_id` = @player_id";
                            command.Parameters.AddWithValue("@player_id", player.player_id);
                        }
                        else {
                            command.CommandText = @"SELECT `total_points` FROM `" + _mySqlSchemaName + @"`.`adkats_infractions_server` WHERE `player_id` = @player_id and `server_id` = @server_id";
                            command.Parameters.AddWithValue("@player_id", player.player_id);
                            command.Parameters.AddWithValue("@server_id", _serverInfo.ServerID);
                        }
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            returnVal = reader.Read() ? reader.GetInt32("total_points") : 0;
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while getting infraction points for player.", e));
            }
            DebugWrite("fetchPoints finished!", 6);
            return (returnVal > 0) ? (returnVal) : (0);
        }

        
        private List<KeyValuePair<DateTime, KeyValuePair<String, String>>> FetchConversation(Int64 player1_id, Int64 player2_id, Int64 limit_lines, Int64 limit_days) {
            DebugWrite("FetchConversation starting!", 6);

            var pchat = new List<KeyValuePair<DateTime, KeyValuePair<String, String>>>();
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return pchat;
            }

            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        (SELECT
	                        `tbl_chatlog`.`logDate` as `chat_time`,
	                        `tbl_chatlog`.`logSoldierName` as `chat_player`,
	                        `tbl_chatlog`.`logMessage` as `chat_message`
                        FROM 
	                        `tbl_chatlog` 
                        WHERE 
                        (
	                        `tbl_chatlog`.`logPlayerID` = @player1_id
                        OR
	                        `tbl_chatlog`.`logPlayerID` = @player2_id
                        )
                        AND
	                        `tbl_chatlog`.`ServerID` = @server_id
                        AND 
	                        DATE_ADD(`tbl_chatlog`.`logDate`, INTERVAL @limit_days DAY) > UTC_TIMESTAMP()
                        ORDER BY 
	                        `ID` DESC
                        LIMIT
	                        @limit_lines)
                        ORDER BY `chat_time` ASC";
                        command.Parameters.AddWithValue("@player1_id", player1_id);
                        command.Parameters.AddWithValue("@player2_id", player2_id);
                        command.Parameters.AddWithValue("@limit_lines", limit_lines);
                        command.Parameters.AddWithValue("@limit_days", limit_days);
                        command.Parameters.AddWithValue("@server_id", _serverInfo.ServerID);
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            while (reader.Read()) {
                                pchat.Add(new KeyValuePair<DateTime, KeyValuePair<string, string>>(reader.GetDateTime("chat_time"), new KeyValuePair<String, String>(reader.GetString("chat_player"), reader.GetString("chat_message"))));
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while getting conversation for player.", e));
            }
            DebugWrite("FetchConversation finished!", 6);
            return pchat;
        }

        
        private List<KeyValuePair<DateTime, String>> FetchChat(Int64 player_id, Int64 limit_lines, Int64 limit_days) {
            DebugWrite("FetchChat starting!", 6);

            var pchat = new List<KeyValuePair<DateTime, String>>();
            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return pchat;
            }

            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        (SELECT
	                        `tbl_chatlog`.`logDate` as `chat_time`,
	                        `tbl_chatlog`.`logMessage` as `chat_message`
                        FROM 
	                        `tbl_chatlog` 
                        WHERE 
                            `tbl_chatlog`.`logPlayerID` = @player_id
                        AND
	                        `tbl_chatlog`.`ServerID` = @server_id
                        AND 
	                        DATE_ADD(`tbl_chatlog`.`logDate`, INTERVAL @limit_days DAY) > UTC_TIMESTAMP()
                        ORDER BY 
	                        `ID` DESC
                        LIMIT
	                        @limit_lines)
                        ORDER BY `chat_time` ASC";
                        command.Parameters.AddWithValue("@player_id", player_id);
                        command.Parameters.AddWithValue("@limit_lines", limit_lines);
                        command.Parameters.AddWithValue("@limit_days", limit_days);
                        command.Parameters.AddWithValue("@server_id", _serverInfo.ServerID);
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            while (reader.Read()) {
                                pchat.Add(new KeyValuePair<DateTime, String>(reader.GetDateTime("chat_time"), reader.GetString("chat_message")));
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while getting conversation for player.", e));
            }
            DebugWrite("FetchChat finished!", 6);
            return pchat;
        }

        private void FetchCommands() {
            DebugWrite("fetchCommands starting!", 6);
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                lock (_CommandIDDictionary) {
                    using (MySqlConnection connection = GetDatabaseConnection()) {
                        using (MySqlCommand sqlcommand = connection.CreateCommand()) {
                            const string sql = @"
                            SELECT 
	                            `command_id`,
	                            `command_active`,
	                            `command_key`,
	                            `command_logging`,
	                            `command_name`,
	                            `command_text`,
                                `command_playerInteraction`
                            FROM 
	                            `adkats_commands`";
                            sqlcommand.CommandText = sql;
                            var validIDs = new HashSet<Int64>();
                            using (MySqlDataReader reader = SafeExecuteReader(sqlcommand)) {
                                _CommandKeyDictionary.Clear();
                                _CommandNameDictionary.Clear();
                                _CommandTextDictionary.Clear();
                                while (reader.Read()) {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    //ID is the immutable element
                                    int commandID = reader.GetInt32("command_id");
                                    var commandActive = (AdKatsCommand.CommandActive) Enum.Parse(typeof (AdKatsCommand.CommandActive), reader.GetString("command_active"));
                                    string commandKey = reader.GetString("command_key");
                                    var commandLogging = (AdKatsCommand.CommandLogging) Enum.Parse(typeof (AdKatsCommand.CommandLogging), reader.GetString("command_logging"));
                                    string commandName = reader.GetString("command_name");
                                    string commandText = reader.GetString("command_text");
                                    bool commandPlayerInteraction = reader.GetBoolean("command_playerInteraction");

                                    validIDs.Add(commandID);
                                    AdKatsCommand currentCommand;
                                    if (_CommandIDDictionary.TryGetValue(commandID, out currentCommand)) {
                                        if (!currentCommand.command_active.Equals(commandActive)) {
                                            ConsoleInfo(currentCommand.command_key + " active state being changed from " + currentCommand.command_active + " to " + commandActive);
                                            currentCommand.command_active = commandActive;
                                        }
                                        if (currentCommand.command_key != commandKey) {
                                            ConsoleInfo(currentCommand.command_key + " command key being changed from " + currentCommand.command_key + " to " + commandKey);
                                            currentCommand.command_key = commandKey;
                                        }
                                        if (!currentCommand.command_logging.Equals((commandLogging))) {
                                            ConsoleInfo(currentCommand.command_key + " logging state being changed from " + currentCommand.command_logging + " to " + commandLogging);
                                            currentCommand.command_logging = commandLogging;
                                        }
                                        if (currentCommand.command_name != commandName) {
                                            ConsoleInfo(currentCommand.command_key + " command name being changed from " + currentCommand.command_name + " to " + commandName);
                                            currentCommand.command_name = commandName;
                                        }
                                        if (currentCommand.command_text != commandText) {
                                            ConsoleInfo(currentCommand.command_key + " command text being changed from " + currentCommand.command_text + " to " + commandText);
                                            currentCommand.command_text = commandText;
                                        }
                                        if (currentCommand.command_playerInteraction != commandPlayerInteraction) {
                                            ConsoleInfo(currentCommand.command_key + " player interaction state being changed from " + currentCommand.command_playerInteraction + " to " + commandPlayerInteraction);
                                            currentCommand.command_playerInteraction = commandPlayerInteraction;
                                        }
                                    }
                                    else {
                                        currentCommand = new AdKatsCommand {
                                            command_id = commandID,
                                            command_active = commandActive,
                                            command_key = commandKey,
                                            command_logging = commandLogging,
                                            command_name = commandName,
                                            command_text = commandText,
                                            command_playerInteraction = commandPlayerInteraction
                                        };

                                        _CommandIDDictionary.Add(currentCommand.command_id, currentCommand);
                                    }
                                    _CommandKeyDictionary.Add(currentCommand.command_key, currentCommand);
                                    _CommandNameDictionary.Add(currentCommand.command_name, currentCommand);
                                    _CommandTextDictionary.Add(currentCommand.command_text, currentCommand);
                                    if (!_commandUsageTimes.ContainsKey(currentCommand.command_key))
                                    {
                                        _commandUsageTimes[currentCommand.command_key] = UtcDbTime();
                                    }
                                }
                            }
                            if (_CommandIDDictionary.Count > 0) {
                                foreach (AdKatsCommand remCommand in _CommandIDDictionary.Values.Where(aRole => !validIDs.Contains(aRole.command_id)).ToList()) {
                                    ConsoleInfo("Removing command " + remCommand.command_key);
                                    _CommandIDDictionary.Remove(remCommand.command_id);
                                }
                                Boolean changed = false;
                                if (!_CommandIDDictionary.ContainsKey(1)) {
                                    SendNonQuery("Adding command 1", "REPLACE INTO `adkats_commands` VALUES(1, 'Active', 'command_confirm', 'Unable', 'Confirm Command', 'yes', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(2)) {
                                    SendNonQuery("Adding command 2", "REPLACE INTO `adkats_commands` VALUES(2, 'Active', 'command_cancel', 'Unable', 'Cancel Command', 'no', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(3)) {
                                    SendNonQuery("Adding command 3", "REPLACE INTO `adkats_commands` VALUES(3, 'Active', 'player_kill', 'Log', 'Kill Player', 'kill', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(4)) {
                                    SendNonQuery("Adding command 4", "REPLACE INTO `adkats_commands` VALUES(4, 'Invisible', 'player_kill_lowpop', 'Log', 'Kill Player (Low Population)', 'lowpopkill', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(5)) {
                                    SendNonQuery("Adding command 5", "REPLACE INTO `adkats_commands` VALUES(5, 'Invisible', 'player_kill_repeat', 'Log', 'Kill Player (Repeat Kill)', 'repeatkill', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(6)) {
                                    SendNonQuery("Adding command 6", "REPLACE INTO `adkats_commands` VALUES(6, 'Active', 'player_kick', 'Log', 'Kick Player', 'kick', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(7)) {
                                    SendNonQuery("Adding command 7", "REPLACE INTO `adkats_commands` VALUES(7, 'Active', 'player_ban_temp', 'Log', 'Temp-Ban Player', 'tban', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(8)) {
                                    SendNonQuery("Adding command 8", "REPLACE INTO `adkats_commands` VALUES(8, 'Active', 'player_ban_perm', 'Log', 'Permaban Player', 'ban', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(9)) {
                                    SendNonQuery("Adding command 9", "REPLACE INTO `adkats_commands` VALUES(9, 'Active', 'player_punish', 'Mandatory', 'Punish Player', 'punish', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(10)) {
                                    SendNonQuery("Adding command 10", "REPLACE INTO `adkats_commands` VALUES(10, 'Active', 'player_forgive', 'Mandatory', 'Forgive Player', 'forgive', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(11)) {
                                    SendNonQuery("Adding command 11", "REPLACE INTO `adkats_commands` VALUES(11, 'Active', 'player_mute', 'Log', 'Mute Player', 'mute', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(12)) {
                                    SendNonQuery("Adding command 12", "REPLACE INTO `adkats_commands` VALUES(12, 'Active', 'player_join', 'Log', 'Join Player', 'join', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(14)) {
                                    SendNonQuery("Adding command 14", "REPLACE INTO `adkats_commands` VALUES(14, 'Active', 'player_move', 'Log', 'On-Death Move Player', 'move', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(15)) {
                                    SendNonQuery("Adding command 15", "REPLACE INTO `adkats_commands` VALUES(15, 'Active', 'player_fmove', 'Log', 'Force Move Player', 'fmove', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(16)) {
                                    SendNonQuery("Adding command 16", "REPLACE INTO `adkats_commands` VALUES(16, 'Active', 'self_teamswap', 'Log', 'Teamswap Self', 'moveme', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(17)) {
                                    SendNonQuery("Adding command 17", "REPLACE INTO `adkats_commands` VALUES(17, 'Active', 'self_kill', 'Log', 'Kill Self', 'killme', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(18)) {
                                    SendNonQuery("Adding command 18", "REPLACE INTO `adkats_commands` VALUES(18, 'Active', 'player_report', 'Log', 'Report Player', 'report', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(19)) {
                                    SendNonQuery("Adding command 19", "REPLACE INTO `adkats_commands` VALUES(19, 'Invisible', 'player_report_confirm', 'Log', 'Report Player (Confirmed)', 'confirmreport', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(20)) {
                                    SendNonQuery("Adding command 20", "REPLACE INTO `adkats_commands` VALUES(20, 'Active', 'player_calladmin', 'Log', 'Call Admin on Player', 'admin', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(21)) {
                                    SendNonQuery("Adding command 21", "REPLACE INTO `adkats_commands` VALUES(21, 'Active', 'admin_say', 'Log', 'Admin Say', 'say', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(22)) {
                                    SendNonQuery("Adding command 22", "REPLACE INTO `adkats_commands` VALUES(22, 'Active', 'player_say', 'Log', 'Player Say', 'psay', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(23)) {
                                    SendNonQuery("Adding command 23", "REPLACE INTO `adkats_commands` VALUES(23, 'Active', 'admin_yell', 'Log', 'Admin Yell', 'yell', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(24)) {
                                    SendNonQuery("Adding command 24", "REPLACE INTO `adkats_commands` VALUES(24, 'Active', 'player_yell', 'Log', 'Player Yell', 'pyell', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(25)) {
                                    SendNonQuery("Adding command 25", "REPLACE INTO `adkats_commands` VALUES(25, 'Active', 'admin_tell', 'Log', 'Admin Tell', 'tell', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(26)) {
                                    SendNonQuery("Adding command 26", "REPLACE INTO `adkats_commands` VALUES(26, 'Active', 'player_tell', 'Log', 'Player Tell', 'ptell', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(27)) {
                                    SendNonQuery("Adding command 27", "REPLACE INTO `adkats_commands` VALUES(27, 'Active', 'self_whatis', 'Unable', 'What Is', 'whatis', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(28)) {
                                    SendNonQuery("Adding command 28", "REPLACE INTO `adkats_commands` VALUES(28, 'Active', 'self_voip', 'Unable', 'VOIP', 'voip', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(29)) {
                                    SendNonQuery("Adding command 29", "REPLACE INTO `adkats_commands` VALUES(29, 'Active', 'self_rules', 'Log', 'Request Rules', 'rules', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(30)) {
                                    SendNonQuery("Adding command 30", "REPLACE INTO `adkats_commands` VALUES(30, 'Active', 'round_restart', 'Log', 'Restart Current Round', 'restart', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(31)) {
                                    SendNonQuery("Adding command 31", "REPLACE INTO `adkats_commands` VALUES(31, 'Active', 'round_next', 'Log', 'Run Next Round', 'nextlevel', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(32)) {
                                    SendNonQuery("Adding command 32", "REPLACE INTO `adkats_commands` VALUES(32, 'Active', 'round_end', 'Log', 'End Current Round', 'endround', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(33)) {
                                    SendNonQuery("Adding command 33", "REPLACE INTO `adkats_commands` VALUES(33, 'Active', 'server_nuke', 'Log', 'Server Nuke', 'nuke', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(34)) {
                                    SendNonQuery("Adding command 34", "REPLACE INTO `adkats_commands` VALUES(34, 'Active', 'server_kickall', 'Log', 'Kick All Guests', 'kickall', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(35)) {
                                    SendNonQuery("Adding command 35", "REPLACE INTO `adkats_commands` VALUES(35, 'Invisible', 'adkats_exception', 'Mandatory', 'Logged Exception', 'logexception', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(36)) {
                                    SendNonQuery("Adding command 36", "REPLACE INTO `adkats_commands` VALUES(36, 'Invisible', 'banenforcer_enforce', 'Mandatory', 'Enforce Active Ban', 'enforceban', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(37)) {
                                    SendNonQuery("Adding command 37", "REPLACE INTO `adkats_commands` VALUES(37, 'Active', 'player_unban', 'Log', 'Unban Player', 'unban', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(38)) {
                                    SendNonQuery("Adding command 38", "REPLACE INTO `adkats_commands` VALUES(38, 'Active', 'self_admins', 'Log', 'Request Online Admins', 'admins', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(39)) {
                                    SendNonQuery("Adding command 39", "REPLACE INTO `adkats_commands` VALUES(39, 'Active', 'self_lead', 'Log', 'Lead Current Squad', 'lead', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(40)) {
                                    SendNonQuery("Adding command 40", "REPLACE INTO `adkats_commands` VALUES(40, 'Active', 'admin_accept', 'Log', 'Accept Round Report', 'accept', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(41)) {
                                    SendNonQuery("Adding command 41", "REPLACE INTO `adkats_commands` VALUES(41, 'Active', 'admin_deny', 'Log', 'Deny Round Report', 'deny', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(42)) {
                                    SendNonQuery("Adding command 42", "REPLACE INTO `adkats_commands` VALUES(42, 'Invisible', 'player_report_deny', 'Log', 'Report Player (Denied)', 'denyreport', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(43)) {
                                    SendNonQuery("Adding command 43", "REPLACE INTO `adkats_commands` VALUES(43, 'Active', 'server_swapnuke', 'Log', 'SwapNuke Server', 'swapnuke', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(44)) {
                                    SendNonQuery("Adding command 44", "REPLACE INTO `adkats_commands` VALUES(44, 'Active', 'player_blacklistdisperse', 'Log', 'Blacklist Disperse Player', 'disperse', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(45)) {
                                    SendNonQuery("Adding command 45", "REPLACE INTO `adkats_commands` VALUES(45, 'Active', 'player_whitelistbalance', 'Log', 'Autobalance Whitelist Player', 'mbwhitelist', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(46)) {
                                    SendNonQuery("Adding command 46", "REPLACE INTO `adkats_commands` VALUES(46, 'Active', 'player_slotreserved', 'Log', 'Reserved Slot Player', 'reserved', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(47)) {
                                    SendNonQuery("Adding command 47", "REPLACE INTO `adkats_commands` VALUES(47, 'Active', 'player_slotspectator', 'Log', 'Spectator Slot Player', 'spectator', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(48)) {
                                    SendNonQuery("Adding command 48", "REPLACE INTO `adkats_commands` VALUES(48, 'Invisible', 'player_changename', 'Log', 'Player Changed Name', 'changename', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(49)) {
                                    SendNonQuery("Adding command 49", "REPLACE INTO `adkats_commands` VALUES(49, 'Invisible', 'player_changeip', 'Log', 'Player Changed IP', 'changeip', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(50)) {
                                    SendNonQuery("Adding command 50", "REPLACE INTO `adkats_commands` VALUES(50, 'Active', 'player_ban_perm_future', 'Log', 'Future Permaban Player', 'fban', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(51)) {
                                    SendNonQuery("Adding command 51", "REPLACE INTO `adkats_commands` VALUES(51, 'Active', 'self_assist', 'Log', 'Assist Losing Team', 'assist', FALSE)", true);
                                    changed = true;
                                }
                                SendNonQuery("Updating command 51 player interaction", "UPDATE `adkats_commands` SET `command_playerInteraction`=0 WHERE `command_id`=51", false);
                                if (!_CommandIDDictionary.ContainsKey(52)) {
                                    SendNonQuery("Adding command 52", "REPLACE INTO `adkats_commands` VALUES(52, 'Active', 'self_uptime', 'Log', 'Request Uptimes', 'uptime', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(53)) {
                                    SendNonQuery("Adding command 53", "REPLACE INTO `adkats_commands` VALUES(53, 'Active', 'self_contest', 'Log', 'Contest Report', 'contest', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(54)) {
                                    SendNonQuery("Adding command 54", "REPLACE INTO `adkats_commands` VALUES(54, 'Active', 'player_kill_force', 'Log', 'Kill Player (Force)', 'fkill', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(55))
                                {
                                    SendNonQuery("Adding command 55", "REPLACE INTO `adkats_commands` VALUES(55, 'Active', 'player_info', 'Log', 'Fetch Player Info', 'pinfo', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(56))
                                {
                                    SendNonQuery("Adding command 56", "REPLACE INTO `adkats_commands` VALUES(56, 'Active', 'player_dequeue', 'Log', 'Dequeue Player Action', 'deq', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(57)) {
                                    SendNonQuery("Adding command 57", "REPLACE INTO `adkats_commands` VALUES(57, 'Active', 'self_help', 'Log', 'Request Server Commands', 'help', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(58))
                                {
                                    SendNonQuery("Adding command 58", "REPLACE INTO `adkats_commands` VALUES(58, 'Active', 'player_find', 'Log', 'Find Player', 'find', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(59))
                                {
                                    SendNonQuery("Adding command 59", "REPLACE INTO `adkats_commands` VALUES(59, 'Active', 'server_afk', 'Log', 'Manage AFK Players', 'afk', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(60))
                                {
                                    SendNonQuery("Adding command 60", "REPLACE INTO `adkats_commands` VALUES(60, 'Active', 'player_pull', 'Log', 'Pull Player', 'pull', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(61))
                                {
                                    SendNonQuery("Adding command 61", "REPLACE INTO `adkats_commands` VALUES(61, 'Active', 'admin_ignore', 'Log', 'Ignore Round Report', 'ignore', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(62))
                                {
                                    SendNonQuery("Adding command 62", "REPLACE INTO `adkats_commands` VALUES(62, 'Invisible', 'player_report_ignore', 'Log', 'Report Player (Ignored)', 'ignorereport', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(63))
                                {
                                    SendNonQuery("Adding command 63", "REPLACE INTO `adkats_commands` VALUES(63, 'Active', 'player_mark', 'Unable', 'Mark Player', 'mark', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(64))
                                {
                                    SendNonQuery("Adding command 64", "REPLACE INTO `adkats_commands` VALUES(64, 'Active', 'player_chat', 'Log', 'Fetch Player Chat', 'pchat', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(65))
                                {
                                    SendNonQuery("Adding command 65", "REPLACE INTO `adkats_commands` VALUES(65, 'Active', 'player_whitelisthackerchecker', 'Log', 'Hacker-Checker Whitelist Player', 'hcwhitelist', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(66))
                                {
                                    SendNonQuery("Adding command 66", "REPLACE INTO `adkats_commands` VALUES(66, 'Active', 'player_lock', 'Log', 'Lock Player Commands', 'lock', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(67))
                                {
                                    SendNonQuery("Adding command 67", "REPLACE INTO `adkats_commands` VALUES(67, 'Active', 'player_unlock', 'Log', 'Unlock Player Commands', 'unlock', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(68))
                                {
                                    SendNonQuery("Adding command 68", "REPLACE INTO `adkats_commands` VALUES(68, 'Active', 'self_rep', 'Log', 'Request Server Reputation', 'rep', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(69))
                                {
                                    SendNonQuery("Adding command 69", "REPLACE INTO `adkats_commands` VALUES(69, 'Invisible', 'player_repboost', 'Log', 'Boost Player Reputation', 'rboost', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(70))
                                {
                                    SendNonQuery("Adding command 70", "REPLACE INTO `adkats_commands` VALUES(70, 'Active', 'player_log', 'Log', 'Log Player Information', 'log', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(71))
                                {
                                    SendNonQuery("Adding command 71", "REPLACE INTO `adkats_commands` VALUES(71, 'Active', 'player_whitelistping', 'Log', 'Ping Whitelist Player', 'pwhitelist', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(72))
                                {
                                    SendNonQuery("Adding command 72", "REPLACE INTO `adkats_commands` VALUES(72, 'Invisible', 'player_ban_temp_old', 'Log', 'Previous Temp Ban', 'pretban', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(73))
                                {
                                    SendNonQuery("Adding command 73", "REPLACE INTO `adkats_commands` VALUES(73, 'Invisible', 'player_ban_perm_old', 'Log', 'Previous Perm Ban', 'preban', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(74))
                                {
                                    SendNonQuery("Adding command 74", "REPLACE INTO `adkats_commands` VALUES(74, 'Active', 'player_pm_send', 'Unable', 'Player Private Message', 'msg', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(75))
                                {
                                    SendNonQuery("Adding command 75", "REPLACE INTO `adkats_commands` VALUES(75, 'Active', 'player_pm_reply', 'Unable', 'Player Private Reply', 'r', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(76))
                                {
                                    SendNonQuery("Adding command 76", "REPLACE INTO `adkats_commands` VALUES(76, 'Active', 'admin_pm_send', 'Unable', 'Admin Private Message', 'adminmsg', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(77))
                                {
                                    SendNonQuery("Adding command 77", "REPLACE INTO `adkats_commands` VALUES(77, 'Active', 'player_whitelistaa', 'Log', 'AA Whitelist Player', 'aawhitelist', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(78))
                                {
                                    SendNonQuery("Adding command 78", "REPLACE INTO `adkats_commands` VALUES(78, 'Active', 'self_surrender', 'Log', 'Vote Surrender', 'surrender', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(79))
                                {
                                    SendNonQuery("Adding command 79", "REPLACE INTO `adkats_commands` VALUES(79, 'Active', 'self_votenext', 'Log', 'Vote Next Round', 'votenext', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(80))
                                {
                                    SendNonQuery("Adding command 80", "REPLACE INTO `adkats_commands` VALUES(80, 'Active', 'self_reportlist', 'Log', 'List Round Reports', 'reportlist', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(81))
                                {
                                    SendNonQuery("Adding command 81", "REPLACE INTO `adkats_commands` VALUES(81, 'Active', 'plugin_restart', 'Log', 'Restart AdKats', 'prestart', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(82))
                                {
                                    SendNonQuery("Adding command 82", "REPLACE INTO `adkats_commands` VALUES(82, 'Active', 'server_shutdown', 'Log', 'Shutdown Server', 'shutdown', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(83))
                                {
                                    SendNonQuery("Adding command 83", "REPLACE INTO `adkats_commands` VALUES(83, 'Active', 'self_nosurrender', 'Log', 'Vote Against Surrender', 'nosurrender', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(84))
                                {
                                    SendNonQuery("Adding command 84", "REPLACE INTO `adkats_commands` VALUES(84, 'Active', 'player_whitelistspambot', 'Log', 'SpamBot Whitelist Player', 'spamwhitelist', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(85))
                                {
                                    SendNonQuery("Adding command 85", "REPLACE INTO `adkats_commands` VALUES(85, 'Invisible', 'player_pm_start', 'Log', 'Player Private Message Start', 'pmstart', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(86))
                                {
                                    SendNonQuery("Adding command 86", "REPLACE INTO `adkats_commands` VALUES(86, 'Invisible', 'player_pm_transmit', 'Log', 'Player Private Message Transmit', 'pmtransmit', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(87))
                                {
                                    SendNonQuery("Adding command 87", "REPLACE INTO `adkats_commands` VALUES(87, 'Invisible', 'player_pm_cancel', 'Log', 'Player Private Message Cancel', 'pmcancel', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(88))
                                {
                                    SendNonQuery("Adding command 88", "REPLACE INTO `adkats_commands` VALUES(88, 'Invisible', 'player_population_success', 'Log', 'Player Successfully Populated Server', 'popsuccess', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(89))
                                {
                                    SendNonQuery("Adding command 89", "REPLACE INTO `adkats_commands` VALUES(89, 'Invisible', 'server_map_detriment', 'Log', 'Map Detriment Log', 'mapdetriment', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(90))
                                {
                                    SendNonQuery("Adding command 90", "REPLACE INTO `adkats_commands` VALUES(90, 'Invisible', 'server_map_benefit', 'Log', 'Map Benefit Log', 'mapbenefit', FALSE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(91))
                                {
                                    SendNonQuery("Adding command 91", "REPLACE INTO `adkats_commands` VALUES(91, 'Active', 'plugin_update', 'Unable', 'Update AdKats', 'pupdate', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(92))
                                {
                                    SendNonQuery("Adding command 92", "REPLACE INTO `adkats_commands` VALUES(92, 'Active', 'player_warn', 'Log', 'Warn Player', 'warn', TRUE)", true);
                                    changed = true;
                                }
                                if (!_CommandIDDictionary.ContainsKey(93))
                                {
                                    SendNonQuery("Adding command 93", "REPLACE INTO `adkats_commands` VALUES(93, 'Active', 'server_countdown', 'Log', 'Run Countdown', 'cdown', FALSE)", true);
                                    changed = true;
                                }
                                if (changed) {
                                    FetchCommands();
                                    return;
                                }
                            }
                            else {
                                ConsoleError("Commands could not be fetched.");
                            }
                            //Update functions for command timeouts
                            UpdateCommandTimeouts();
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching commands from database.", e));
            }
            UpdateSettingPage();
            DebugWrite("fetchCommands finished!", 6);
        }

        private void FillCommandDescDictionary() {
            _CommandDescriptionDictionary["command_confirm"] = "Command used to confirm actions. No parameters.";
            _CommandDescriptionDictionary["command_cancel"] = "Command used to cancel actions. No parameters.";
            _CommandDescriptionDictionary["player_kill"] = "Kills a player, queues for kill on spawn if dead. Requires a reason.";
            _CommandDescriptionDictionary["player_kill_lowpop"] = "Invisible command. Assigned when a player_punish is issued during low population.";
            _CommandDescriptionDictionary["player_kill_repeat"] = "Invisible command. Assigned when a player_kill is issued and player is dead.";
            _CommandDescriptionDictionary["player_kick"] = "Kicks a player from the server. Requires a reason.";
            _CommandDescriptionDictionary["player_ban_temp"] = "Temporarily bans a player from the server for the given time. Requires a reason.";
            _CommandDescriptionDictionary["player_ban_perm"] = "Permanently bans a player from the server. Requires a reason.";
            _CommandDescriptionDictionary["player_punish"] = "Increases infraction points, then punishes the player. Requires a reason.";
            _CommandDescriptionDictionary["player_forgive"] = "Decreases infraction points and informs the player. Requires a reason.";
            _CommandDescriptionDictionary["player_mute"] = "Mutes a player for the current round. Talking will cause punishment. Requires a reason.";
            _CommandDescriptionDictionary["player_join"] = "Switches you to a players squad if there is room.";
            _CommandDescriptionDictionary["player_roundwhitelist"] = "DISABLED COMMAND";
            _CommandDescriptionDictionary["player_move"] = "When the player dies it queues them to switch teams when a slot is available.";
            _CommandDescriptionDictionary["player_fmove"] = "Immediately queues the player to switch teams when a slot is available.";
            _CommandDescriptionDictionary["self_teamswap"] = "Immediately queues you to switch teams when a slot is available.";
            _CommandDescriptionDictionary["self_kill"] = "Makes you commit suicide and regret your existence.";
            _CommandDescriptionDictionary["player_report"] = "Reports a player to admins. Requires a reason.";
            _CommandDescriptionDictionary["player_report_confirm"] = "Invisible command. Assigned when an admin confirms a report.";
            _CommandDescriptionDictionary["player_calladmin"] = "Calls admin on a player. Requires a reason.";
            _CommandDescriptionDictionary["admin_say"] = "Sends a chat message to the whole server.";
            _CommandDescriptionDictionary["player_say"] = "Sends a chat message to a particular player.";
            _CommandDescriptionDictionary["admin_yell"] = "Sends a yell message to the whole server.";
            _CommandDescriptionDictionary["player_yell"] = "Sends a yell message to a particular player.";
            _CommandDescriptionDictionary["admin_tell"] = "Sends both a chat message and yell message to the whole server.";
            _CommandDescriptionDictionary["player_tell"] = "Sends both a chat message and yell message to a particular player.";
            _CommandDescriptionDictionary["self_whatis"] = "Tells you what a command or pre-message ID means.";
            _CommandDescriptionDictionary["self_voip"] = "Tells you what the VOIP address for this server is.";
            _CommandDescriptionDictionary["self_rules"] = "Tells you what the server rules are.";
            _CommandDescriptionDictionary["round_restart"] = "Restarts the current round. All players keep their points.";
            _CommandDescriptionDictionary["round_next"] = "Runs the next round/map in line. All players keep their points.";
            _CommandDescriptionDictionary["round_end"] = "Ends the current round with a decided winner.";
            _CommandDescriptionDictionary["server_nuke"] = "Kills all players in the decided subset.";
            _CommandDescriptionDictionary["server_kickall"] = "Kicks all non-admins from the server.";
            _CommandDescriptionDictionary["adkats_exception"] = "Invisible command. Issued by AdKats to log exceptions.";
            _CommandDescriptionDictionary["banenforcer_enforce"] = "Invisible command. Issued by BanEnforcer when a player's ban is enforced.";
            _CommandDescriptionDictionary["player_unban"] = "Searches for banned players with the given name, and gives the option to unban.";
            _CommandDescriptionDictionary["self_admins"] = "Tells you the list of online admins.";
            _CommandDescriptionDictionary["self_lead"] = "Gives the target leader of their current squad. No parameters to target yourself.";
            _CommandDescriptionDictionary["admin_accept"] = "Accepts the given report ID. Takes no action against the target player.";
            _CommandDescriptionDictionary["admin_deny"] = "Denys the given report ID. Reduces the reporter's reputation.";
            _CommandDescriptionDictionary["player_report_deny"] = "Invisible command. Assigned when an admin denies a report.";
            _CommandDescriptionDictionary["server_swapnuke"] = "Queues all players to switch teams immediately.";
            _CommandDescriptionDictionary["player_blacklistdisperse"] = "Adds the target player to even dispersion for the server.";
            _CommandDescriptionDictionary["player_whitelistbalance"] = "Adds the target player to autobalance whitelist for the server.";
            _CommandDescriptionDictionary["player_slotreserved"] = "Adds the target player to reserved slots for the server.";
            _CommandDescriptionDictionary["player_slotspectator"] = "Adds the target player to spectator slots for the server.";
            _CommandDescriptionDictionary["player_changename"] = "Invisible command. Assigned when a player changes their name.";
            _CommandDescriptionDictionary["player_changeip"] = "Invisible command. Assigned when a player changes location/IP.";
            _CommandDescriptionDictionary["player_ban_perm_future"] = "Future-permaban, inverse of a temp-ban. Requires a reason.";
            _CommandDescriptionDictionary["self_assist"] = "Queues you to assist the losing team.";
            _CommandDescriptionDictionary["self_uptime"] = "Tells you the uptime/population information for the server.";
            _CommandDescriptionDictionary["self_contest"] = "Contests any current report against you. Admins must act manually on the report afterward.";
            _CommandDescriptionDictionary["player_kill_force"] = "Immediately kills the target player, avoids all other player_kill logic.";
            _CommandDescriptionDictionary["player_info"] = "Returns all known information about the player.";
            _CommandDescriptionDictionary["player_dequeue"] = "Cancels any queued action on a player.";
            _CommandDescriptionDictionary["self_help"] = "Tells you all commands your user role can access.";
            _CommandDescriptionDictionary["self_rep"] = "Tells you your server reputation.";
            _CommandDescriptionDictionary["player_find"] = "Target a player to fetch their team, position, and current score.";
            _CommandDescriptionDictionary["server_afk"] = "Calls the AFK Manager logic to remove AFK players from the server.";
            _CommandDescriptionDictionary["player_pull"] = "Pulls a player to your squad, killing them in the process.";
            _CommandDescriptionDictionary["admin_ignore"] = "Ignores the given report ID. Takes no action against the target or source player.";
            _CommandDescriptionDictionary["player_mark"] = "Marks a player for notification if they leave the server.";
            _CommandDescriptionDictionary["player_chat"] = "Fetches player or conversation chat history.";
            _CommandDescriptionDictionary["player_whitelisthackerchecker"] = "Whitelists the target player from Hacker-Checker, and unbans them if necessary.";
            _CommandDescriptionDictionary["player_lock"] = "Temporarily locks a player from admin commands.";
            _CommandDescriptionDictionary["player_unlock"] = "Removes command lock from a player.";
            _CommandDescriptionDictionary["self_rep"] = "Returns your current server reputation.";
            _CommandDescriptionDictionary["player_repboost"] = "Invisible command. Boosts player rep for a given reason.";
            _CommandDescriptionDictionary["player_log"] = "Logs the given information to the player's record.";
            _CommandDescriptionDictionary["player_whitelistping"] = "Whitelists a player from ping kick (ADK only).";
            _CommandDescriptionDictionary["player_ban_temp_old"] = "Invisible command. Set to all disabled temp-bans.";
            _CommandDescriptionDictionary["player_ban_perm_old"] = "Invisible command. Set to all disabled permabans.";
            _CommandDescriptionDictionary["player_pm_send"] = "Sends a private message to the targeted player.";
            _CommandDescriptionDictionary["player_pm_reply"] = "Replies to the current private message.";
            _CommandDescriptionDictionary["admin_pm_send"] = "Sends a private message to all online admins.";
            _CommandDescriptionDictionary["player_whitelistaa"] = "Whitelists a player for Admin Assistant status.";
            _CommandDescriptionDictionary["self_surrender"] = "Votes to end the round with current winning team as winner, then start the next.";
            _CommandDescriptionDictionary["self_votenext"] = "Votes to end the round with current winning team as winner, then start the next.";
            _CommandDescriptionDictionary["self_reportlist"] = "Lists the latest unused round reports.";
            _CommandDescriptionDictionary["plugin_restart"] = "Reboots AdKats.";
            _CommandDescriptionDictionary["self_nosurrender"] = "Votes against ending the round with surrender.";
            _CommandDescriptionDictionary["player_whitelistspambot"] = "Whitelists a player for SpamBot avoidance. They will not get any messages from the SpamBot.";
            _CommandDescriptionDictionary["plugin_update"] = "Updates AdKats.";
            _CommandDescriptionDictionary["player_warn"] = "Warns a player. Requires a reason.";
            _CommandDescriptionDictionary["server_countdown"] = "Sends a visible countdown to all players in the given subset.";
        }

        private void UpdateCommandTimeouts() {
            //Add rules timeout
            _commandTimeoutDictionary["self_rules"] = (plugin => (plugin._ServerRulesList.Count() * plugin._ServerRulesInterval));
            _commandTimeoutDictionary["player_punish"] = (plugin => (18));
            _commandTimeoutDictionary["player_kick"] = (plugin => (30));
            _commandTimeoutDictionary["player_blacklistdisperse"] = (plugin => (30));
            _commandTimeoutDictionary["player_ban_temp"] = (plugin => (30));
            _commandTimeoutDictionary["player_ban_perm"] = (plugin => (30));
            _commandTimeoutDictionary["player_ban_perm_future"] = (plugin => (30));
        }

        private void FetchRoles() {
            DebugWrite("fetchRoles starting!", 6);
            if (HandlePossibleDisconnect()) {
                return;
            }
            try {
                lock (_RoleIDDictionary) {
                    using (MySqlConnection connection = GetDatabaseConnection()) {
                        using (MySqlCommand command = connection.CreateCommand()) {
                            const string sql = @"
                            SELECT 
	                            `role_id`,
	                            `role_key`,
	                            `role_name`
                            FROM 
	                            `adkats_roles`";
                            command.CommandText = sql;
                            var validIDs = new HashSet<Int64>();
                            using (MySqlDataReader reader = SafeExecuteReader(command)) {
                                _RoleKeyDictionary.Clear();
                                _RoleNameDictionary.Clear();
                                while (reader.Read())
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    long roleID = reader.GetInt64("role_id");
                                    string roleKey = reader.GetString("role_key");
                                    string roleName = reader.GetString("role_name");
                                    validIDs.Add(roleID);
                                    AdKatsRole currentRole;
                                    if (_RoleIDDictionary.TryGetValue(roleID, out currentRole)) {
                                        if (currentRole.role_key != roleKey) {
                                            ConsoleInfo(currentRole.role_key + " role key being changed from " + currentRole.role_key + " to " + roleKey);
                                            currentRole.role_key = roleKey;
                                        }
                                        if (currentRole.role_name != roleName) {
                                            ConsoleInfo(currentRole.role_key + " role name being changed from " + currentRole.role_name + " to " + roleName);
                                            currentRole.role_name = roleName;
                                        }
                                    }
                                    else {
                                        currentRole = new AdKatsRole {
                                            role_id = roleID,
                                            role_key = roleKey,
                                            role_name = roleName
                                        };
                                        _RoleIDDictionary.Add(currentRole.role_id, currentRole);
                                    }
                                    _RoleKeyDictionary.Add(currentRole.role_key, currentRole);
                                    _RoleNameDictionary.Add(currentRole.role_name, currentRole);
                                }
                                foreach (AdKatsRole remRole in _RoleIDDictionary.Values.Where(aRole => !validIDs.Contains(aRole.role_id)).ToList())
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    ConsoleInfo("Removing role " + remRole.role_key);
                                    _RoleIDDictionary.Remove(remRole.role_id);
                                }
                            }
                        }
                        using (MySqlCommand command = connection.CreateCommand())
                        {
                            const string sql = @"
                            SELECT 
	                            `role_id`,
	                            `command_id`
                            FROM 
	                            `adkats_rolecommands`
                            ORDER BY
                                `role_id`
                            ASC";
                            command.CommandText = sql;
                            using (MySqlDataReader reader = SafeExecuteReader(command))
                            {
                                var rIDcIDDictionary = new Dictionary<Int64, HashSet<Int64>>();
                                while (reader.Read())
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    int roleID = reader.GetInt32("role_id");
                                    long commandID = reader.GetInt64("command_id");
                                    HashSet<Int64> allowedCommandIDs;
                                    if (!rIDcIDDictionary.TryGetValue(roleID, out allowedCommandIDs))
                                    {
                                        allowedCommandIDs = new HashSet<Int64>();
                                        rIDcIDDictionary.Add(roleID, allowedCommandIDs);
                                    }
                                    allowedCommandIDs.Add(commandID);
                                }
                                foreach (var currentRoleElement in rIDcIDDictionary)
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    AdKatsRole aRole;
                                    Boolean uploadRequired = false;
                                    if (!_RoleIDDictionary.TryGetValue(currentRoleElement.Key, out aRole))
                                    {
                                        ConsoleWarn("Role for ID " + currentRoleElement.Key + " not found in role dictionary when assigning commands.");
                                        continue;
                                    }
                                    foreach (long curCommandID in currentRoleElement.Value)
                                    {
                                        if (!_pluginEnabled)
                                        {
                                            return;
                                        }
                                        AdKatsCommand aCommand;
                                        if (!_CommandIDDictionary.TryGetValue(curCommandID, out aCommand))
                                        {
                                            ConsoleWarn("Command for ID " + curCommandID + " not found in command dictionary when assigning commands.");
                                            uploadRequired = true;
                                            continue;
                                        }
                                        if (!aRole.RoleAllowedCommands.ContainsKey(aCommand.command_key) &&
                                            aCommand.command_active == AdKatsCommand.CommandActive.Active)
                                        {
                                            //Conditional check for default guest admin commands
                                            if (aRole.role_key == "guest_default" && aCommand.command_playerInteraction)
                                            {
                                                ConsoleWarn("The guest role cannot have access to admin commands.");
                                                uploadRequired = true;
                                                continue;
                                            }
                                            aRole.RoleAllowedCommands.Add(aCommand.command_key, aCommand);
                                        }
                                    }
                                    KeyValuePair<Int64, HashSet<Int64>> element = currentRoleElement;
                                    foreach (AdKatsCommand remCommand in aRole.RoleAllowedCommands.Values.ToList().Where(remCommand => !element.Value.Contains(remCommand.command_id)))
                                    {
                                        if (!_pluginEnabled)
                                        {
                                            return;
                                        }
                                        ConsoleInfo("Removing command " + remCommand.command_key + " from role " + aRole.role_key);
                                        aRole.RoleAllowedCommands.Remove(remCommand.command_key);
                                        uploadRequired = true;
                                    }
                                    FillConditionalAllowedCommands(aRole);
                                    //Calculate role power level
                                    aRole.role_powerLevel = aRole.RoleAllowedCommands.Values.Count(aCommand => !aCommand.command_playerInteraction) + (2 * aRole.RoleAllowedCommands.Values.Count(aCommand => aCommand.command_playerInteraction));
                                    if (_CommandIDDictionary.Any() && uploadRequired)
                                    {
                                        QueueRoleForUpload(aRole);
                                    }
                                }
                            }
                        }
                        if (_RoleIDDictionary.Count == 0)
                        {
                            ConsoleError("Roles could not be fetched.");
                        }
                        //Fetch role groups
                        using (MySqlCommand command = connection.CreateCommand())
                        {
                            const string sql = @"
                            SELECT 
	                            `role_id`,
	                            `group_key`
                            FROM 
	                            `adkats_rolegroups`
                            ORDER BY
                                `role_id`
                            ASC";
                            command.CommandText = sql;
                            using (MySqlDataReader reader = SafeExecuteReader(command))
                            {
                                var rIDgKeyDictionary = new Dictionary<Int64, HashSet<String>>();
                                while (reader.Read())
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    int roleID = reader.GetInt32("role_id");
                                    String groupKey = reader.GetString("group_key");
                                    HashSet<String> setGroups;
                                    if (!rIDgKeyDictionary.TryGetValue(roleID, out setGroups))
                                    {
                                        setGroups = new HashSet<String>();
                                        rIDgKeyDictionary.Add(roleID, setGroups);
                                    }
                                    setGroups.Add(groupKey);
                                }
                                foreach (var currentRoleElement in rIDgKeyDictionary)
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    AdKatsRole aRole;
                                    Boolean uploadRequired = false;
                                    if (!_RoleIDDictionary.TryGetValue(currentRoleElement.Key, out aRole))
                                    {
                                        ConsoleWarn("Role for ID " + currentRoleElement.Key + " not found in role dictionary when assigning groups.");
                                        continue;
                                    }
                                    foreach (String groupKey in currentRoleElement.Value)
                                    {
                                        if (!_pluginEnabled)
                                        {
                                            return;
                                        }
                                        AdKatsSpecialGroup aGroup;
                                        if (!_specialPlayerGroupKeyDictionary.TryGetValue(groupKey, out aGroup))
                                        {
                                            ConsoleWarn("Group for key " + groupKey + " not found in group cache when assigning groups.");
                                            uploadRequired = true;
                                            continue;
                                        }
                                        if (!aRole.RoleSetGroups.ContainsKey(aGroup.group_key))
                                        {
                                            aRole.RoleSetGroups.Add(aGroup.group_key, aGroup);
                                        }
                                    }
                                    KeyValuePair<Int64, HashSet<String>> element = currentRoleElement;
                                    foreach (AdKatsSpecialGroup remGroup in aRole.RoleSetGroups.Values.ToList().Where(remGroup => !element.Value.Contains(remGroup.group_key)))
                                    {
                                        if (!_pluginEnabled)
                                        {
                                            return;
                                        }
                                        ConsoleInfo("Removing group " + remGroup.group_key + " from role " + aRole.role_key);
                                        aRole.RoleAllowedCommands.Remove(remGroup.group_key);
                                        uploadRequired = true;
                                    }
                                    FillConditionalAllowedCommands(aRole);
                                    if (uploadRequired)
                                    {
                                        QueueRoleForUpload(aRole);
                                    }
                                }
                            }
                        }
                        //Done with users
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching roles from database.", e));
            }
            UpdateSettingPage();
            DebugWrite("fetchRoles finished!", 6);
        }

        private void FillConditionalAllowedCommands(AdKatsRole aRole) {
            //Teamswap Command
            AdKatsCommand teamswapCommand;
            if (_CommandKeyDictionary.TryGetValue("self_teamswap", out teamswapCommand)) {
                if (!aRole.ConditionalAllowedCommands.ContainsKey(teamswapCommand.command_key))
                    aRole.ConditionalAllowedCommands.Add(teamswapCommand.command_key, new KeyValuePair<Func<AdKats, AdKatsPlayer, Boolean>, AdKatsCommand>(TeamSwapFunc, teamswapCommand));
            }
            else {
                ConsoleError("Unable to find teamswap command when assigning conditional commands.");
            }
            //Admins Command
            AdKatsCommand adminsCommand;
            if (_CommandKeyDictionary.TryGetValue("self_admins", out adminsCommand)) {
                if (!aRole.ConditionalAllowedCommands.ContainsKey(adminsCommand.command_key))
                    aRole.ConditionalAllowedCommands.Add(adminsCommand.command_key, new KeyValuePair<Func<AdKats, AdKatsPlayer, Boolean>, AdKatsCommand>(AAPerkFunc, adminsCommand));
            }
            else {
                ConsoleError("Unable to find teamswap command when assigning conditional commands.");
            }
        }

        private void FetchUserList() {
            DebugWrite("fetchUserList starting!", 6);
            if (HandlePossibleDisconnect()) {
                return;
            }
            DateTime start = UtcDbTime();
            try
            {
                if (!_firstUserListComplete && !SendQuery("SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE ( TABLE_SCHEMA = '" + _mySqlSchemaName + "' AND TABLE_NAME = 'adkats_users' AND COLUMN_NAME = 'user_expiration' )", false))
                {
                    SendNonQuery("Adding user expiration.", "ALTER TABLE `adkats_users` ADD COLUMN `user_expiration` DATETIME NOT NULL AFTER `user_role`", true);
                    SendNonQuery("Adding initial user expiration values.", "UPDATE `adkats_users` SET `user_expiration` = DATE_ADD(UTC_TIMESTAMP(), INTERVAL 20 YEAR)", true);
                }
                if (!_firstUserListComplete && !SendQuery("SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE ( TABLE_SCHEMA = '" + _mySqlSchemaName + "' AND TABLE_NAME = 'adkats_users' AND COLUMN_NAME = 'user_notes' )", false))
                {
                    SendNonQuery("Adding user notes.", "ALTER TABLE `adkats_users` ADD COLUMN `user_notes` VARCHAR(1000) NOT NULL DEFAULT 'No Notes' AFTER `user_expiration`", true);
                }
                start = UtcDbTime();
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
	                        `adkats_users`.`user_id`,
	                        `adkats_users`.`user_name`,
	                        `adkats_users`.`user_email`,
	                        `adkats_users`.`user_phone`,
	                        `adkats_users`.`user_role`,
	                        `adkats_users`.`user_expiration`,
	                        `adkats_users`.`user_notes`
                        FROM 
	                        `adkats_users`";
                        var validIDs = new List<Int64>();
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            lock (_userCache) {
                                while (reader.Read())
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    int userID = reader.GetInt32("user_id"); //0
                                    validIDs.Add(userID);
                                    string userName = reader.GetString("user_name"); //1
                                    String userEmail = null;
                                    if (!reader.IsDBNull(2))
                                        userEmail = reader.GetString("user_email"); //2
                                    String userPhone = null;
                                    if (!reader.IsDBNull(3))
                                        userPhone = reader.GetString("user_phone"); //3
                                    AdKatsRole userRole;
                                    if (!_RoleIDDictionary.TryGetValue(reader.GetInt32("user_role"), out userRole))
                                    {
                                        ConsoleError("Unable to find user role for role ID " + reader.GetInt32("user_role"));
                                        continue;
                                    }
                                    DateTime expirationTime = reader.GetDateTime("user_expiration");
                                    String userNotes = reader.GetString("user_notes");

                                    AdKatsUser aUser;
                                    if (_userCache.TryGetValue(userID, out aUser))
                                    {
                                        if (expirationTime < UtcDbTime())
                                        {
                                            userRole = _RoleKeyDictionary["guest_default"];
                                            expirationTime = UtcDbTime().AddYears(20);
                                            QueueUserForUpload(aUser);
                                        }
                                        aUser.user_name = userName;
                                        aUser.user_email = userEmail;
                                        aUser.user_phone = userPhone;
                                        aUser.user_role = userRole;
                                        aUser.user_expiration = expirationTime;
                                        aUser.user_notes = userNotes;
                                    }
                                    else {
                                        aUser = new AdKatsUser {
                                            user_id = userID,
                                            user_name = userName,
                                            user_email = userEmail,
                                            user_phone = userPhone,
                                            user_role = userRole,
                                            user_expiration = expirationTime,
                                            user_notes = userNotes
                                        };
                                        if (expirationTime < UtcDbTime())
                                        {
                                            userRole = _RoleKeyDictionary["guest_default"];
                                            expirationTime = UtcDbTime().AddYears(20);
                                            QueueUserForUpload(aUser);
                                        }
                                        _userCache.Add(aUser.user_id, aUser);
                                    }
                                }
                                foreach (AdKatsUser remUser in _userCache.Values.Where(usr => validIDs.All(id => id != usr.user_id)).ToList())
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    _userCache.Remove(remUser.user_id);
                                    ConsoleSuccess("User " + remUser.user_name + " removed.");
                                }
                            }
                        }
                    }
                    DebugWrite("User fetch (Users) took " + (UtcDbTime() - start).TotalMilliseconds + "ms.", 4);
                    start = UtcDbTime();
                    using (MySqlCommand command = connection.CreateCommand()) {
                        if (_serverInfo.GameID > 0) {
                            command.CommandText = @"
                            SELECT 
	                            `adkats_users`.`user_id`,
	                            `adkats_usersoldiers`.`player_id`,
	                            `tbl_playerdata`.`GameID` AS `game_id`,
	                            `tbl_playerdata`.`ClanTag` AS `clan_tag`,
	                            `tbl_playerdata`.`SoldierName` AS `player_name`,
	                            `tbl_playerdata`.`EAGUID` AS `player_guid`,
	                            `tbl_playerdata`.`IP_Address` AS `player_ip`
                            FROM 
	                            `adkats_users`
                            INNER JOIN
	                            `adkats_usersoldiers`
                            ON 
	                            `adkats_users`.`user_id` = `adkats_usersoldiers`.`user_id`
                            INNER JOIN
	                            `tbl_playerdata`
                            ON
	                            `adkats_usersoldiers`.`player_id` = `tbl_playerdata`.`PlayerID`
                            ORDER BY 
                                `user_id`
                            ASC";
                        }
                        else {

                            command.CommandText = @"
                            SELECT 
	                            `adkats_users`.`user_id`,
	                            `adkats_usersoldiers`.`player_id`,
	                            `tbl_playerdata`.`ClanTag` AS `clan_tag`,
	                            `tbl_playerdata`.`SoldierName` AS `player_name`,
	                            `tbl_playerdata`.`EAGUID` AS `player_guid`,
	                            `tbl_playerdata`.`IP_Address` AS `player_ip`
                            FROM 
	                            `adkats_users`
                            INNER JOIN
	                            `adkats_usersoldiers`
                            ON 
	                            `adkats_users`.`user_id` = `adkats_usersoldiers`.`user_id`
                            INNER JOIN
	                            `tbl_playerdata`
                            ON
	                            `adkats_usersoldiers`.`player_id` = `tbl_playerdata`.`PlayerID`
                            ORDER BY 
                                `user_id`
                            ASC";
                        }
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            lock (_userCache) {
                                foreach (AdKatsPlayer aPlayer in _userCache.Values.SelectMany(aUser => aUser.soldierDictionary.Values))
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    aPlayer.update_playerUpdated = false;
                                }
                                while (reader.Read())
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    int userID = reader.GetInt32("user_id"); //0
                                    int playerID = reader.GetInt32("player_id"); //1
                                    long gameID = (_serverInfo.GameID > 0)?(reader.GetInt32("game_id")):(_serverInfo.GameID); //2
                                    String clanTag = null;
                                    if (!reader.IsDBNull(3))
                                        clanTag = reader.GetString("clan_tag"); //3
                                    String playerName = null;
                                    if (!reader.IsDBNull(4))
                                        playerName = reader.GetString("player_name"); //4
                                    String playerGUID = null;
                                    if (!reader.IsDBNull(5))
                                        playerGUID = reader.GetString("player_guid"); //5
                                    String playerIP = null;
                                    if (!reader.IsDBNull(6))
                                        playerIP = reader.GetString("player_ip"); //6

                                    AdKatsUser aUser;
                                    if (_userCache.TryGetValue(userID, out aUser)) {
                                        AdKatsPlayer aPlayer;
                                        if (aUser.soldierDictionary.TryGetValue(playerID, out aPlayer)) {
                                            aPlayer.game_id = gameID;
                                            aPlayer.player_clanTag = clanTag;
                                            aPlayer.player_name = playerName;
                                            aPlayer.player_guid = playerGUID;
                                            aPlayer.player_ip = playerIP;
                                        }
                                        else {
                                            aPlayer = new AdKatsPlayer(this) {
                                                player_id = playerID,
                                                game_id = gameID,
                                                player_clanTag = clanTag,
                                                player_name = playerName,
                                                player_guid = playerGUID,
                                                player_ip = playerIP
                                            };
                                            aUser.soldierDictionary.Add(playerID, aPlayer);
                                        }
                                        aPlayer.player_role = aUser.user_role;

                                        aPlayer.update_playerUpdated = true;
                                    }
                                    else {
                                        ConsoleError("Unable to add soldier " + playerID + " to user " + userID + " when fetching user list. User not found.");
                                    }
                                }
                                foreach (AdKatsUser aUser in _userCache.Values) {
                                    foreach (AdKatsPlayer aPlayer in aUser.soldierDictionary.Values.Where(aPlayer => !aPlayer.update_playerUpdated)) {
                                        aUser.soldierDictionary.Remove(aPlayer.player_id);
                                    }
                                }
                            }
                        }
                    }
                    DebugWrite("User fetch (User Soldiers) took " + (UtcDbTime() - start).TotalMilliseconds + "ms.", 4);
                    start = UtcDbTime();
                    lock (_specialPlayerCache)
                    {
                        using (MySqlCommand command = connection.CreateCommand()) {
                            command.CommandText = @"
                            SELECT
                                `specialplayer_id`,
	                            `player_group`,
	                            `player_id`,
	                            `player_game`,
	                            `player_server`,
	                            `player_identifier`,
	                            `player_effective`,
	                            `player_expiration`
                            FROM 
	                            `adkats_specialplayers`
                            WHERE
	                            `player_effective` <= UTC_TIMESTAMP()
                            AND
	                            `player_expiration` > UTC_TIMESTAMP()
                            AND
                            (
	                            `player_game` IS NULL
	                            OR
	                            `player_game` = @playerGame
                            )
                            AND
                            (
	                            `player_server` IS NULL
	                            OR
	                            `player_server` = @playerServer
                            )
                            ORDER BY 
	                            `player_group`
                            DESC";
                            command.Parameters.AddWithValue("@playerGame", _serverInfo.GameID);
                            command.Parameters.AddWithValue("@playerServer", _serverInfo.ServerID);
                            using (MySqlDataReader reader = SafeExecuteReader(command)) {
                                List<Int64> validIDs = new List<Int64>();
                                while (reader.Read())
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    AdKatsSpecialPlayer asPlayer;
                                    Int64 specialPlayerID = reader.GetInt64("specialplayer_id");//0
                                    //ID is valid
                                    validIDs.Add(specialPlayerID);
                                    //Check for player already existing
                                    if (_specialPlayerCache.TryGetValue(specialPlayerID, out asPlayer)) {
                                        //Special player already cached, do no special processing
                                    }
                                    else
                                    {
                                        //Get Values
                                        String playerGroup = reader.GetString("player_group"); //1
                                        if (!_specialPlayerGroupKeyDictionary.ContainsKey(playerGroup)) {
                                            ConsoleError("player_group entry '" + playerGroup + "' for specialplayer_id " + specialPlayerID + " is invalid.");
                                            continue;
                                        }
                                        Int32 playerID = 0;
                                        if (!reader.IsDBNull(2))
                                        {
                                            playerID = reader.GetInt32("player_id");//2
                                        }
                                        Int32 playerGame = 0;
                                        if (!reader.IsDBNull(3))
                                        {
                                            playerGame = reader.GetInt32("player_game"); //3
                                        }
                                        Int32 playerServer = 0;
                                        if (!reader.IsDBNull(4))
                                        {
                                            playerServer = reader.GetInt32("player_server"); //4
                                        }
                                        String playerIdentifier = null;
                                        if (!reader.IsDBNull(5))
                                        {
                                            playerIdentifier = reader.GetString("player_identifier"); //5
                                        }
                                        DateTime playerEffective = reader.GetDateTime("player_effective");//6
                                        DateTime playerExpiration = reader.GetDateTime("player_expiration");//7

                                        //Build new Special Player Object
                                        asPlayer = new AdKatsSpecialPlayer();
                                        asPlayer.specialplayer_id = specialPlayerID;
                                        asPlayer.player_group = _specialPlayerGroupKeyDictionary[playerGroup];
                                        if (playerID > 0) {
                                            asPlayer.player_object = FetchPlayer(false, true, false, null, playerID, null, null, null);
                                        }
                                        if (playerGame > 0) {
                                            asPlayer.player_game = playerGame;
                                        }
                                        if (playerServer > 0) {
                                            asPlayer.player_server = playerServer;
                                        }
                                        asPlayer.player_identifier = playerIdentifier;
                                        asPlayer.player_effective = playerEffective;
                                        asPlayer.player_expiration = playerExpiration;

                                        //Assign to cache
                                        _specialPlayerCache[specialPlayerID] = asPlayer;
                                    }
                                }
                                List<Int64> removeIDs = new List<Int64>();
                                foreach (var asPlayerID in _specialPlayerCache.Keys)
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    if (!validIDs.Contains(asPlayerID)) {
                                        removeIDs.Add(asPlayerID);
                                    }
                                }
                                foreach (var asPlayerID in removeIDs)
                                {
                                    if (!_pluginEnabled)
                                    {
                                        return;
                                    }
                                    ConsoleInfo("Removing special player " + asPlayerID + " from cache.");
                                    _specialPlayerCache.Remove(asPlayerID);
                                }
                            }
                        }
                        DebugWrite("User fetch (Special Player Fetch) took " + (UtcDbTime() - start).TotalMilliseconds + "ms.", 4);
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching user list.", e));
            }

            _PlayerRoleRefetch = true;
            _PlayerProcessingWaitHandle.Set();

            start = UtcDbTime();
            UpdateMULTIBalancerWhitelist();
            UpdateMULTIBalancerDisperseList();
            ExecuteCommand("procon.protected.send", "reservedSlotsList.list");
            Thread.Sleep(50);
            UpdateReservedSlots();
            ExecuteCommand("procon.protected.send", "spectatorList.list");
            Thread.Sleep(50);
            UpdateSpectatorList();
            DebugWrite("User fetch (Orchestration) took " + (UtcDbTime() - start).TotalMilliseconds + "ms.", 4);
            start = UtcDbTime();
            _lastUserFetch = UtcDbTime();
            if (!_firstUserListComplete) {
                _firstUserListComplete = true;
                OnlineAdminSayMessage("User fetch complete [" + _userCache.Count + " users, " + _specialPlayerCache.Count + " Special Players]. Fetching player list.");
                ConsoleSuccess("User fetch complete [" + _userCache.Count + " users, " + _specialPlayerCache.Count + " Special Players].");
                ConsoleInfo("Fetching player list.");
                UpdateSettingPage();
                //Call player listing immediately
                ExecuteCommand("procon.protected.send", "admin.listPlayers", "all");
            }
            else
            {
                if (_userCache.Count > 0)
                {
                    DebugWrite("User List Fetched from Database. [" + _userCache.Count + " users, " + _specialPlayerCache.Count + " Special Players]", 1);
                }
                else
                {
                    ConsoleWarn("No users have been added. Add a new user with 'Add User'.");
                }
            }

            UpdateSettingPage();
            DebugWrite("fetchUserList finished!", 6);
        }

        private Boolean AssignPlayerRole(AdKatsPlayer aPlayer) {
            AdKatsUser matchingUser = _userCache.Values.FirstOrDefault(aUser => aUser.soldierDictionary.Values.Any(uPlayer => uPlayer.player_id == aPlayer.player_id || uPlayer.player_guid == aPlayer.player_guid));
            AdKatsRole aRole = null;
            Boolean authorized = false;
            if (matchingUser != null) {
                authorized = true;
                aRole = matchingUser.user_role;
            }
            else {
                aRole = _RoleKeyDictionary["guest_default"];
            }
            //Debug Block
            if (aPlayer.player_role == null) {
                if (authorized) {
                    DebugWrite("Player " + aPlayer.player_name + " has been assigned authorized role " + aRole.role_name + ".", 4);
                }
                else {
                    DebugWrite("Player " + aPlayer.player_name + " has been assigned the guest role.", 4);
                }
            }
            else {
                if (aPlayer.player_role.role_key != aRole.role_key) {
                    if (authorized) {
                        DebugWrite("Role for authorized player " + aPlayer.player_name + " has been CHANGED to " + aRole.role_name + ".", 4);
                        PlayerSayMessage(aPlayer.player_name, "You have been assigned the authorized role " + aRole.role_name + ".");
                    }
                    else {
                        DebugWrite("Player " + aPlayer.player_name + " has been assigned the guest role.", 4);
                        PlayerSayMessage(aPlayer.player_name, "You have been assigned the guest role.");
                    }
                }
            }
            aPlayer.player_role = aRole;
            AssignPlayerAdminAssistant(aPlayer);
            if (aPlayer.player_aa) {
                DebugWrite(aPlayer.player_name + " IS an Admin Assistant.", 3);
            }
            return authorized;
        }

        private void AssignPlayerAdminAssistant(AdKatsPlayer aPlayer) {
            DebugWrite("PlayerIsAdminAssistant starting!", 7);
            if (!_EnableAdminAssistants) {
                aPlayer.player_aa = false;
                return;
            }
            if (aPlayer.player_aa_fetched) {
                return;
            }
            if (PlayerIsAdmin(aPlayer))
            {
                aPlayer.player_aa_fetched = true;
                aPlayer.player_aa = false;
                return;
            }
            List<AdKatsSpecialPlayer> matchingPlayers = GetMatchingASPlayersOfGroup("whitelist_adminassistant", aPlayer);
            if (matchingPlayers.Count > 0)
            {
                aPlayer.player_aa_fetched = true;
                aPlayer.player_aa = true;
                return;
            }
            if (HandlePossibleDisconnect())
            {
                aPlayer.player_aa = false;
                return;
            }
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT
	                        'isAdminAssistant'
                        FROM 
	                        `adkats_records_main`
                        WHERE (
	                        SELECT count(`command_action`) 
	                        FROM `adkats_records_main` 
	                        WHERE `command_action` = " + GetCommandByKey("player_report_confirm").command_id + @"
	                        AND `source_id` = " + aPlayer.player_id + @" 
	                        AND (`adkats_records_main`.`record_time` BETWEEN date_sub(UTC_TIMESTAMP(),INTERVAL 30 DAY) AND UTC_TIMESTAMP())
                        ) >= " + _MinimumRequiredMonthlyReports + @" LIMIT 1
                        UNION
                        SELECT
	                        'isGrandfatheredAdminAssistant'
                        FROM 
	                        `adkats_records_main`
                        WHERE (
	                        SELECT count(`command_action`) 
	                        FROM `adkats_records_main` 
	                        WHERE `command_action` = " + GetCommandByKey("player_report_confirm").command_id + @" 
	                        AND `source_id` = " + aPlayer.player_id + @"
                        ) >= 75";
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                aPlayer.player_aa = true;
                            }
                            aPlayer.player_aa_fetched = true;
                            return;
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while checking if player is an admin assistant.", e));
            }
            DebugWrite("PlayerIsAdminAssistant finished!", 7);
        }

        
        private Boolean FetchDBServerInfo() {
            DebugWrite("FetchDBServerInfo starting!", 6);

            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return false;
            }

            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            `ServerID` as `server_id`,
                            `ServerGroup` as `server_group`,
                            `ServerName` as `server_name`
                        FROM 
                            `tbl_server` 
                        WHERE 
                            IP_Address = @IP_Address";
                        command.Parameters.AddWithValue("@IP_Address", _serverInfo.ServerIP);
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read())
                            {
                                _serverInfo.ServerID = reader.GetInt64("server_id");
                                _serverInfo.ServerGroup = reader.GetInt64("server_group");
                                _serverInfo.ServerName = reader.GetString("server_name");
                                _settingImportID = _serverInfo.ServerID;
                                DebugWrite("Server ID fetched: " + _serverInfo.ServerID, 1);
                                return true;
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching server ID from database.", e));
            }

            DebugWrite("FetchDBServerInfo finished!", 6);
            return false;
        }

        private Int64 FetchServerGroup(Int64 serverID) {
            DebugWrite("fetchServerGroup starting!", 6);

            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return -1;
            }

            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"
                        SELECT 
                            `ServerGroup` as `server_group`
                        FROM 
                            `tbl_server` 
                        WHERE 
                            `ServerID` = @ServerID";
                        command.Parameters.AddWithValue("@ServerID", serverID);
                        using (MySqlDataReader reader = SafeExecuteReader(command)) {
                            if (reader.Read()) {
                                return reader.GetInt64("server_group");
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while fetching server group from database for server " + serverID + ".", e));
            }

            DebugWrite("fetchServerGroup finished!", 6);
            return -1;
        }

        private Boolean HandlePossibleDisconnect() {
            Boolean returnVal = false;
            //Make sure database connection active
            if (_databaseConnectionCriticalState || !DebugDatabaseConnectionActive()) {
                if (!_databaseConnectionCriticalState) {
                    HandleDatabaseConnectionInteruption();
                }
                returnVal = true;
            }
            return returnVal;
        }

        private Boolean DebugDatabaseConnectionActive() {
            DebugWrite("DebugDatabaseConnectionActive starting!", 8);

            Boolean active = true;

            DateTime startTime = UtcDbTime();
            try {
                using (MySqlConnection connection = GetDatabaseConnection()) {
                    using (MySqlCommand command = connection.CreateCommand()) {
                        command.CommandText = @"SELECT UTC_TIMESTAMP() AS `current_time`";
                        Stopwatch watch = new Stopwatch();
                        watch.Start();
                        using (MySqlDataReader reader = command.ExecuteReader())
                        {
                            watch.Stop();
                            if (reader.Read() && watch.Elapsed.TotalSeconds < (50 *_DatabaseReadAverageDuration)) {
                                active = true;
                            }
                            else {
                                active = false;
                            }
                        }
                    }
                }
            }
            catch (Exception) {
                active = false;
            }
            if ((UtcDbTime() - startTime).TotalSeconds > 10) {
                //If the connection took longer than 10 seconds also say the database is disconnected
                active = false;
            }
            DebugWrite("DebugDatabaseConnectionActive finished!", 8);
            return active;
        }

        public Boolean GetGlobalUTCTimestamp(out DateTime globalUTCTime)
        {
            globalUTCTime = UtcDbTime();
            using (var client = new WebClient())
            {
                try
                {
                    String response = client.DownloadString("http://www.timeanddate.com/clocks/onlyforusebyconfiguration2.php");
                    String[] elements = response.Split(' ');
                    Double epochSeconds = 0;
                    if (Double.TryParse(elements[0], out epochSeconds))
                    {
                        globalUTCTime = DateTimeFromEpochSeconds(epochSeconds);
                        return true;
                    }
                }
                catch (Exception)
                {
                    return false;
                }
            }
            return false;
        }

        public Boolean TestGlobalTiming(Boolean failOnFetchError, Boolean verbose, out TimeSpan diffGlobalUTC)
        {
            DateTime globalUTC;
            diffGlobalUTC = TimeSpan.Zero;
            if (GetGlobalUTCTimestamp(out globalUTC)) {
                DateTime curUTC = UtcDbTime();
                diffGlobalUTC = globalUTC - curUTC;
                if (verbose)
                {
                    if (diffGlobalUTC.Duration().TotalSeconds > 300)
                    {
                        ConsoleWarn("Your PRoCon layer has a " + FormatTimeString(diffGlobalUTC.Duration(), 3) + " UTC timestamp mismatch vs Global Time. UTC-Global:(" + globalUTC.ToShortDateString() + " " + globalUTC.ToLongTimeString() + ") UTC-Procon:(" + curUTC.ToShortDateString() + " " + curUTC.ToLongTimeString() + ")");
                        _globalTimingChecked = true;
                        return false;
                    }
                    if (diffGlobalUTC.Duration().TotalSeconds > 15)
                    {
                        ConsoleWarn("Global timing confirmed, but there is a " + FormatTimeString(diffGlobalUTC.Duration(), 3) + " UTC timestamp mismatch between your layer and global time.");
                    }
                    else
                    {
                        ConsoleSuccess("Global timing confirmed.");
                    }
                }
                _globalTimingChecked = true;
                return true;
            }
            if (verbose)
                ConsoleError("Unable to confirm global timing. Global UTC Timestamp could not be fetched.");
            _globalTimingChecked = true;
            return !failOnFetchError;
        }

        private Boolean GetDatabaseUTCTimestamp(out DateTime dbUTC)
        {
            dbUTC = UtcDbTime();
            try
            {
                using (MySqlConnection connection = GetDatabaseConnection())
                {
                    using (MySqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = @"SELECT UTC_TIMESTAMP() AS `current_time`";
                        using (MySqlDataReader reader = SafeExecuteReader(command))
                        {
                            if (reader.Read())
                            {
                                dbUTC = reader.GetDateTime("current_time");
                                return true;
                            }

                        }
                    }
                }
            }
            catch (Exception)
            {
            }
            return false;
        }

        public Boolean TestDBTiming(Boolean verbose, out TimeSpan diffDBUTC)
        {
            //Confirm database UTC timestamp matches procon UTC timestamp
            diffDBUTC = TimeSpan.Zero;
            DateTime dbUTC;
            if (GetDatabaseUTCTimestamp(out dbUTC)) {
                DateTime curUTC = UtcDbTime();
                diffDBUTC = dbUTC - curUTC;
                if (verbose)
                {
                    if (diffDBUTC.Duration().TotalSeconds > 300)
                    {
                        ConsoleWarn("Your PRoCon layer and database have a " + FormatTimeString(diffDBUTC.Duration(), 3) + " UTC timestamp mismatch. UTC-Database:(" + dbUTC.ToShortDateString() + " " + dbUTC.ToLongTimeString() + ") UTC-Procon:(" + curUTC.ToShortDateString() + " " + curUTC.ToLongTimeString() + ")");
                    }
                    else if (diffDBUTC.Duration().TotalSeconds > 15)
                    {
                        ConsoleWarn("Database timing confirmed, but there is a " + FormatTimeString(diffDBUTC.Duration(), 3) + " UTC timestamp mismatch between your layer and database.");
                    }
                    else
                    {
                        ConsoleSuccess("Database timing confirmed.");
                    }
                }
                _dbTimingChecked = true;
                return true;
            }
            if (verbose)
                ConsoleError("Unable to confirm timing controls. Database UTC Timestamp could not be fetched.");
            _dbTimingChecked = true;
            return false;
        }

        private void UpdateMULTIBalancerWhitelist() {
            try {
                if (_FeedMultiBalancerWhitelist) {
                    var autobalanceWhitelistedPlayers = new List<String>();
                    //Pull players from special player cache
                    lock (_specialPlayerCache) {
                        List<AdKatsSpecialPlayer> whitelistedPlayers = GetASPlayersOfGroup("whitelist_multibalancer");
                        if (whitelistedPlayers.Any()) {
                            foreach (AdKatsSpecialPlayer asPlayer in whitelistedPlayers) {
                                String playerIdentifier = null;
                                if (asPlayer.player_object != null && !String.IsNullOrEmpty(asPlayer.player_object.player_name)) {
                                    playerIdentifier = asPlayer.player_object.player_name;
                                }
                                else {
                                    playerIdentifier = asPlayer.player_identifier;
                                }
                                //Skip if no valid info found
                                if (String.IsNullOrEmpty(playerIdentifier)) {
                                    ConsoleError("Player under whitelist_multibalancer was not valid. Unable to add to MULTIBalancer whitelist.");
                                    continue;
                                }
                                if (!autobalanceWhitelistedPlayers.Contains(playerIdentifier)) {
                                    autobalanceWhitelistedPlayers.Add(playerIdentifier);
                                }
                            }
                        }
                    }
                    //Pull players from user list
                    if (_userCache.Count > 0 && _FeedMultiBalancerWhitelist_Admins) {
                        lock (_userCache) {
                            foreach (AdKatsUser user in _userCache.Values) {
                                lock (user) {
                                    lock (user.user_role) {
                                        lock (user.user_role.RoleAllowedCommands) {
                                            //Check each user's allowed commands
                                            foreach (AdKatsCommand command in user.user_role.RoleAllowedCommands.Values) {
                                                //If the teamswap command is allowed add each of the user's soldiers to the whitelist
                                                if (command.command_key == "self_teamswap") {
                                                    foreach (AdKatsPlayer soldier in user.soldierDictionary.Values) {
                                                        if (!autobalanceWhitelistedPlayers.Contains(soldier.player_guid)) {
                                                            autobalanceWhitelistedPlayers.Add(soldier.player_guid);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    SetExternalPluginSetting("MULTIbalancer", "2 - Exclusions|On Whitelist", "True");
                    SetExternalPluginSetting("MULTIbalancer", "1 - Settings|Whitelist", CPluginVariable.EncodeStringArray(autobalanceWhitelistedPlayers.ToArray()));
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while updating MULTIBalancer whitelist.", e));
            }
        }

        private void UpdateMULTIBalancerDisperseList() {
            try {
                if (_FeedMultiBalancerDisperseList) {
                    var evenDispersionList = new List<String>();
                    //Pull players from special player cache
                    lock (_specialPlayerCache) {
                        List<AdKatsSpecialPlayer> evenDispersedPlayers = GetASPlayersOfGroup("blacklist_dispersion");
                        if (evenDispersedPlayers.Any()) {
                            foreach (AdKatsSpecialPlayer asPlayer in evenDispersedPlayers) {
                                String playerIdentifier = null;
                                if (asPlayer.player_object != null && !String.IsNullOrEmpty(asPlayer.player_object.player_guid)) {
                                    playerIdentifier = asPlayer.player_object.player_guid;
                                }
                                else {
                                    playerIdentifier = asPlayer.player_identifier;
                                }
                                //Skip if no valid info found
                                if (String.IsNullOrEmpty(playerIdentifier)) {
                                    ConsoleError("Player under blacklist_dispersion was not valid. Unable to add to MULTIBalancer even dispersion list.");
                                    continue;
                                }
                                if (!evenDispersionList.Contains(playerIdentifier)) {
                                    evenDispersionList.Add(playerIdentifier);
                                }
                            }
                        }
                    }
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Conquest Large|Conquest Large: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Conquest Small|Conquest Small: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Defuse|Defuse: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Domination|Domination: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Obliteration|Obliteration: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Rush|Rush: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Squad Deathmatch|Squad Deathmatch: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Superiority|Superiority: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Team Deathmatch|Team Deathmatch: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "8 - Settings for Unknown or New Mode|Unknown or New Mode: Enable Disperse Evenly List", "True");
                    SetExternalPluginSetting("MULTIbalancer", "1 - Settings|Disperse Evenly List", CPluginVariable.EncodeStringArray(evenDispersionList.ToArray()));
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while updating MULTIBalancer even dispersion list.", e));
            }
        }

        private void UpdateReservedSlots() {
            try {
                if (!_FeedServerReservedSlots || _CurrentReservedSlotPlayers == null) {
                    return;
                }
                DebugWrite("Checking validity of reserved slotted players.", 6);
                var allowedReservedSlotPlayers = new List<string>();
                //Pull players from special player cache
                lock (_specialPlayerCache) {
                    List<AdKatsSpecialPlayer> reservedPlayers = GetASPlayersOfGroup("slot_reserved");
                    if (reservedPlayers.Any()) {
                        foreach (AdKatsSpecialPlayer asPlayer in reservedPlayers) {
                            String playerIdentifier = null;
                            if (asPlayer.player_object != null && !String.IsNullOrEmpty(asPlayer.player_object.player_name)) {
                                playerIdentifier = asPlayer.player_object.player_name;
                            }
                            else {
                                if (SoldierNameValid(asPlayer.player_identifier)) {
                                    playerIdentifier = asPlayer.player_identifier;
                                }
                                else {
                                    ConsoleError("Player under reserved_slot list '" + asPlayer.player_identifier + "' was not a valid soldier name. Unable to add to reserved slot list.");
                                }
                            }
                            //Skip if no valid info found
                            if (String.IsNullOrEmpty(playerIdentifier)) {
                                continue;
                            }
                            if (!allowedReservedSlotPlayers.Contains(playerIdentifier)) {
                                allowedReservedSlotPlayers.Add(playerIdentifier);
                            }
                        }
                    }
                }
                //Pull players from user list
                if (_userCache.Count > 0 && _FeedServerReservedSlots_Admins) {
                    lock (_userCache) {
                        foreach (AdKatsPlayer soldier in FetchAdminSoldiers()) {
                            //Only add soldiers for the current game
                            if (soldier.game_id == _serverInfo.GameID)
                            {
                                if (!allowedReservedSlotPlayers.Contains(soldier.player_name)) {
                                    allowedReservedSlotPlayers.Add(soldier.player_name);
                                }
                            }
                        }
                    }
                }
                //All players fetched, update the server lists
                //Remove soldiers from the list where needed
                foreach (String playerName in _CurrentReservedSlotPlayers) {
                    if (!allowedReservedSlotPlayers.Contains(playerName)) {
                        DebugWrite(playerName + " in server reserved slots, but not in allowed reserved players. Removing.", 3);
                        ExecuteCommand("procon.protected.send", "reservedSlotsList.remove", playerName);
                        _threadMasterWaitHandle.WaitOne(5);
                    }
                }
                //Add soldiers to the list where needed
                foreach (String playerName in allowedReservedSlotPlayers) {
                    if (!_CurrentReservedSlotPlayers.Contains(playerName)) {
                        DebugWrite(playerName + " in allowed reserved players, but not in server reserved slots. Adding.", 3);
                        ExecuteCommand("procon.protected.send", "reservedSlotsList.add", playerName);
                        _threadMasterWaitHandle.WaitOne(5);
                    }
                }
                //Save the list
                ExecuteCommand("procon.protected.send", "reservedSlotsList.save");
                //Display the list
                ExecuteCommand("procon.protected.send", "reservedSlotsList.list");
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while updating server reserved slots.", e));
            }
        }

        public override void OnReservedSlotsList(List<String> soldierNames) {
            try {
                DebugWrite("Reserved slots listed.", 5);
                _CurrentReservedSlotPlayers = soldierNames;
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling reserved slot list.", e));
            }
        }

        private void UpdateSpectatorList()
        {
            DebugWrite("Entering UpdateSpectatorList", 6);
            try {
                if (!_FeedServerSpectatorList || _CurrentSpectatorListPlayers == null) {
                    return;
                }
                DebugWrite("Updating spectator list players.", 6);
                var allowedSpectatorSlotPlayers = new List<string>();
                //Pull players from special player cache
                lock (_specialPlayerCache) {
                    List<AdKatsSpecialPlayer> spectators = GetASPlayersOfGroup("slot_spectator");
                    if (spectators.Any()) {
                        foreach (AdKatsSpecialPlayer asPlayer in spectators) {
                            String playerIdentifier = null;
                            if (asPlayer.player_object != null && !String.IsNullOrEmpty(asPlayer.player_object.player_name)) {
                                playerIdentifier = asPlayer.player_object.player_name;
                            }
                            else {
                                if (SoldierNameValid(asPlayer.player_identifier)) {
                                    playerIdentifier = asPlayer.player_identifier;
                                }
                                else {
                                    ConsoleError("Player under slot_spectator list '" + asPlayer.player_identifier + "' was not a valid soldier name. Unable to add to spectator slot list.");
                                }
                            }
                            //Skip if no valid info found
                            if (String.IsNullOrEmpty(playerIdentifier)) {
                                continue;
                            }
                            if (!allowedSpectatorSlotPlayers.Contains(playerIdentifier)) {
                                DebugWrite("Valid slot_spectator " + playerIdentifier + " fetched.", 5);
                                allowedSpectatorSlotPlayers.Add(playerIdentifier);
                            }
                        }
                    }
                    else {
                        DebugWrite("No players under special player group slot_spectator.", 5);
                    }
                }
                //Pull players from user list
                if (_userCache.Count > 0 && _FeedServerSpectatorList_Admins)
                {
                    DebugWrite("Feeding spetators from user cache.", 5);
                    foreach (AdKatsPlayer soldier in FetchAdminSoldiers())
                    {
                        //Only add soldiers for the current game
                        if (soldier.game_id == _serverInfo.GameID) {
                            //Only add if players are admins
                            if (PlayerIsAdmin(soldier))
                            {
                                if (!allowedSpectatorSlotPlayers.Contains(soldier.player_name))
                                {
                                    DebugWrite("Valid user spectator " + soldier.player_name + " fetched.", 5);
                                    allowedSpectatorSlotPlayers.Add(soldier.player_name);
                                }
                            }
                        }
                    }
                }
                //All players fetched, update the server lists
                //Remove soldiers from the list where needed
                foreach (String playerName in _CurrentSpectatorListPlayers) {
                    if (!allowedSpectatorSlotPlayers.Contains(playerName)) {
                        DebugWrite(playerName + " in server spectator slots, but not in allowed spectator players. Removing.", 3);
                        ExecuteCommand("procon.protected.send", "spectatorList.remove", playerName);
                        _threadMasterWaitHandle.WaitOne(5);
                    }
                }
                //Add soldiers to the list where needed
                foreach (String playerName in allowedSpectatorSlotPlayers) {
                    if (!_CurrentSpectatorListPlayers.Contains(playerName)) {
                        DebugWrite(playerName + " in allowed spectator players, but not in server spectator slots. Adding.", 3);
                        ExecuteCommand("procon.protected.send", "spectatorList.add", playerName);
                        _threadMasterWaitHandle.WaitOne(5);
                    }
                }
                //Save the list
                ExecuteCommand("procon.protected.send", "spectatorList.save");
                //Display the list
                ExecuteCommand("procon.protected.send", "spectatorList.list");
                DebugWrite("DONE checking validity of spectator list players.", 6);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while updating server spectator list.", e));
            }
            DebugWrite("Exiting UpdateSpectatorList", 6);
        }

        public override void OnSpectatorListList(List<String> soldierNames) {
            try {
                DebugWrite("Spectators listed.", 5);
                _CurrentSpectatorListPlayers = soldierNames;
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling spectator list.", e));
            }
        }

        public override void OnMaxSpectators(Int32 spectatorLimit) {
            _serverInfo.MaxSpectators = spectatorLimit;
        }

        public override void OnSpectatorListLoad() {
        }

        public override void OnSpectatorListSave() {
        }

        public override void OnSpectatorListPlayerAdded(String soldierName) {
        }

        public override void OnSpectatorListPlayerRemoved(String soldierName) {
        }

        public override void OnSpectatorListCleared() {
        }

        public void IssueCommand(params String[] commandParams) {
            DebugWrite("IssueCommand starting!", 6);
            try {
                if (!_threadsReady) {
                    ConsoleError("Attempted to issue external command before AdKats threads were running.");
                }
                if (commandParams.Length < 1) {
                    ConsoleError("External command handling canceled. No parameters were provided.");
                    return;
                }
                new Thread(ParseExternalCommand).Start(commandParams);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while starting external command processing.", e));
            }
            DebugWrite("IssueCommand finished!", 6);
        }

        private void ParseExternalCommand(Object commandParams) {
            DebugWrite("ParseExternalCommand starting!", 6);
            try {
                //Set current thread id
                Thread.CurrentThread.Name = "ParseExternalCommand";

                //Create the new record
                var record = new AdKatsRecord {
                    record_source = AdKatsRecord.Sources.ExternalPlugin,
                    server_id = _serverInfo.ServerID,
                    record_time = UtcDbTime()
                };

                //Parse information into a record
                if (commandParams == null) {
                    ConsoleError("Command params were null when parsing external command. Unable to continue.");
                    return;
                }
                String[] paramArray = commandParams as String[];
                if (paramArray == null) {
                    ConsoleError("Command params could not be properly converted to String[]. Unable to continue.");
                    return;
                }
                if (paramArray.Length != 2) {
                    ConsoleError("Invalid parameter count [source, jsonParams]. Unable to continue.");
                    return;
                }
                String commandSource = paramArray[0];
                String unparsedCommandJSON = paramArray[1];

                Hashtable parsedClientInformation = (Hashtable)JSON.JsonDecode(unparsedCommandJSON);
                if (parsedClientInformation == null)
                {
                    ConsoleError("Command params could not be properly converted from JSON. Unable to continue.");
                    return;
                }

                //Import the caller identity
                if (!parsedClientInformation.ContainsKey("caller_identity")) {
                    ConsoleError("Parsed command didn't contain a caller_identity! Unable to process external command.");
                    return;
                }
                var callerIdentity = (String) parsedClientInformation["caller_identity"];
                if (String.IsNullOrEmpty(callerIdentity)) {
                    ConsoleError("caller_identity was empty. Unable to process external command.");
                    return;
                }
                record.external_callerIdentity = callerIdentity;

                //Import the callback options
                if (!parsedClientInformation.ContainsKey("response_requested")) {
                    ConsoleError("Parsed command didn't contain response_requested! Unable to process external command.");
                    return;
                }
                var callbackRequested = (Boolean) parsedClientInformation["response_requested"];
                record.external_responseRequested = callbackRequested;
                if (callbackRequested) {
                    if (!parsedClientInformation.ContainsKey("response_class")) {
                        ConsoleError("Parsed command didn't contain a response_class! Unable to process external command.");
                        return;
                    }
                    var callbackClass = (String) parsedClientInformation["response_class"];
                    if (String.IsNullOrEmpty(callbackClass)) {
                        ConsoleError("response_class was empty. Unable to process external command.");
                        return;
                    }
                    record.external_responseClass = callbackClass;

                    if (!parsedClientInformation.ContainsKey("response_method")) {
                        ConsoleError("Parsed command didn't contain a response_method! Unable to process external command.");
                        return;
                    }
                    var callbackMethod = (String) parsedClientInformation["response_method"];
                    if (String.IsNullOrEmpty(callbackMethod)) {
                        ConsoleError("response_method was empty. Unable to process external command.");
                        return;
                    }
                    record.external_responseMethod = callbackMethod;
                }

                //Import the command type
                if (!parsedClientInformation.ContainsKey("command_type")) {
                    record.record_exception = HandleException(new AdKatsException("Parsed command didn't contain a command_type!"));
                    return;
                }
                var unparsedCommandType = (String) parsedClientInformation["command_type"];
                if (String.IsNullOrEmpty(unparsedCommandType)) {
                    ConsoleError("command_type was empty. Unable to process external command.");
                    return;
                }
                if (!_CommandKeyDictionary.TryGetValue(unparsedCommandType, out record.command_type)) {
                    ConsoleError("command_type was invalid, not found in definition. Unable to process external command.");
                    return;
                }

                //Import the command numeric
                //Only required for temp ban
                if (record.command_type.command_key == "player_ban_temp") {
                    if (!parsedClientInformation.ContainsKey("command_numeric")) {
                        ConsoleError("Parsed command didn't contain a command_numeric! Unable to parse command.");
                        return;
                    }
                    record.command_numeric = (Int32) parsedClientInformation["command_numeric"];
                }

                //Import the source name
                if (!parsedClientInformation.ContainsKey("source_name")) {
                    ConsoleError("Parsed command didn't contain a source_name!");
                    return;
                }
                var sourceName = (String) parsedClientInformation["source_name"];
                if (String.IsNullOrEmpty(sourceName)) {
                    ConsoleError("source_name was empty. Unable to process external command.");
                    return;
                }
                record.source_name = sourceName;

                //Import the target name
                if (!parsedClientInformation.ContainsKey("target_name")) {
                    ConsoleError("Parsed command didn't contain a target_name! Unable to process external command.");
                    return;
                }
                var targetName = (String) parsedClientInformation["target_name"];
                if (String.IsNullOrEmpty(targetName)) {
                    ConsoleError("source_name was empty. Unable to process external command.");
                    return;
                }
                record.target_name = targetName;

                //Import the target guid
                String target_guid = null;
                if (parsedClientInformation.ContainsKey("target_guid")) {
                    target_guid = (String) parsedClientInformation["target_guid"];
                }

                //Import the record message
                if (!parsedClientInformation.ContainsKey("record_message")) {
                    ConsoleError("Parsed command didn't contain a record_message! Unable to process external command.");
                    return;
                }
                var recordMessage = (String) parsedClientInformation["record_message"];
                if (String.IsNullOrEmpty(recordMessage)) {
                    ConsoleError("record_message was empty. Unable to process external command.");
                    return;
                }
                record.record_message = recordMessage;

                _PlayerDictionary.TryGetValue(record.source_name, out record.source_player);
                if (!_PlayerDictionary.TryGetValue(record.target_name, out record.target_player) && record.command_type.command_key.StartsWith("player_")) {
                    if (String.IsNullOrEmpty(target_guid)) {
                        ConsoleError("Target player '" + record.GetTargetNames() + "' was not found in the server. And target_guid was not provided. Unable to process external command.");
                        return;
                    }
                    record.target_player = FetchPlayer(true, false, false, null, -1, record.target_name, target_guid, null);
                }
                QueueRecordForProcessing(record);
            }
            catch (Exception e) {
                //Log the error in console
                HandleException(new AdKatsException("Unable to process external command.", e));
            }
            DebugWrite("ParseExternalCommand finished!", 6);
        }

        public void FetchAuthorizedSoldiers(params String[] commandParams) {
            DebugWrite("FetchAuthorizedSoldiers starting!", 6);
            if (!commandParams.Any())
            {
                ConsoleError("Authorized soldier fetch canceled. No parameters were provided.");
                return;
            }
            if (!_firstUserListComplete)
            {
                ConsoleError("Authorized soldier fetch canceled. Authorized soldiers requested before user list fetched.");
                return;
            }
            //TODO add logging for this
            new Thread(SendAuthorizedSoldiers).Start(commandParams[1]);
            DebugWrite("FetchAuthorizedSoldiers finished!", 6);
        }

        private void SendAuthorizedSoldiers(Object clientInformation) {
            DebugWrite("SendAuthorizedSoldiers starting!", 6);
            try {
                //Set current thread id
                Thread.CurrentThread.Name = "SendAuthorizedSoldiers";

                //Create the new record
                var record = new AdKatsRecord {
                    record_source = AdKatsRecord.Sources.ExternalPlugin
                };

                //Parse information into a record
                var parsedClientInformation = (Hashtable) JSON.JsonDecode((String) clientInformation);

                //Import the caller identity
                if (!parsedClientInformation.ContainsKey("caller_identity")) {
                    ConsoleError("Parsed command didn't contain a caller_identity! Unable to process soldier fetch.");
                    return;
                }
                var callerIdentity = (String) parsedClientInformation["caller_identity"];
                if (String.IsNullOrEmpty(callerIdentity)) {
                    ConsoleError("caller_identity was empty. Unable to process soldier fetch.");
                    return;
                }
                record.external_callerIdentity = callerIdentity;

                //Import the callback options
                if (!parsedClientInformation.ContainsKey("response_requested")) {
                    ConsoleError("Parsed command didn't contain response_requested! Unable to process soldier fetch.");
                    return;
                }
                var callbackRequested = (Boolean) parsedClientInformation["response_requested"];
                record.external_responseRequested = callbackRequested;
                if (callbackRequested) {
                    if (!parsedClientInformation.ContainsKey("response_class")) {
                        ConsoleError("Parsed command didn't contain a response_class! Unable to process soldier fetch.");
                        return;
                    }
                    var callbackClass = (String) parsedClientInformation["response_class"];
                    if (String.IsNullOrEmpty(callbackClass)) {
                        ConsoleError("response_class was empty. Unable to process soldier fetch.");
                        return;
                    }
                    record.external_responseClass = callbackClass;

                    if (!parsedClientInformation.ContainsKey("response_method")) {
                        ConsoleError("Parsed command didn't contain a response_method!");
                        return;
                    }
                    var callbackMethod = (String) parsedClientInformation["response_method"];
                    if (String.IsNullOrEmpty(callbackMethod)) {
                        ConsoleError("response_method was empty. Unable to process soldier fetch.");
                        return;
                    }
                    record.external_responseMethod = callbackMethod;
                }
                else {
                    ConsoleError("response_requested must be true to return authorized soldiers. Unable to process soldier fetch.");
                    return;
                }

                List<AdKatsPlayer> soldierList;
                Boolean containsUserSubset = parsedClientInformation.ContainsKey("user_subset");
                Boolean containsUserRole = parsedClientInformation.ContainsKey("user_role");
                if (containsUserRole && containsUserSubset) {
                    ConsoleError("Both user_subset and user_role were used in request. Only one may be used at any time. Unable to process soldier fetch.");
                    return;
                }
                if (containsUserRole) {
                    var roleString = (String) parsedClientInformation["user_role"];
                    if (String.IsNullOrEmpty(roleString)) {
                        ConsoleError("user_role was found in request, but it was empty. Unable to process soldier fetch.");
                        return;
                    }
                    AdKatsRole aRole;
                    if (!_RoleKeyDictionary.TryGetValue(roleString, out aRole)) {
                        ConsoleError("Specified user role '" + roleString + "' was not found. Unable to process soldier fetch.");
                        return;
                    }
                    soldierList = FetchSoldiersOfRole(aRole);
                }
                else if (containsUserSubset) {
                    var subset = (String) parsedClientInformation["user_subset"];
                    if (String.IsNullOrEmpty(subset)) {
                        DebugWrite("user_subset was found in request, but it was empty. Unable to process soldier fetch.", 3);
                        return;
                    }
                    switch (subset) {
                        case "all":
                            soldierList = FetchAllUserSoldiers();
                            break;
                        case "admin":
                            soldierList = FetchAdminSoldiers();
                            break;
                        case "elevated":
                            soldierList = FetchElevatedSoldiers();
                            break;
                        default:
                            ConsoleError("request_subset was found in request, but it was invalid. Unable to process soldier fetch.");
                            return;
                    }
                }
                else {
                    ConsoleError("Neither user_subset nor user_role was found in request. Unable to process soldier fetch.");
                    return;
                }

                if (soldierList == null) {
                    ConsoleError("Internal error, all parameters were correct, but soldier list was not fetched.");
                    return;
                }

                String[] soldierNames = (from aPlayer in soldierList where (!String.IsNullOrEmpty(aPlayer.player_name) && aPlayer.game_id == _serverInfo.GameID) select aPlayer.player_name).ToArray();

                var responseHashtable = new Hashtable();
                responseHashtable.Add("caller_identity", "AdKats");
                responseHashtable.Add("response_requested", false);
                responseHashtable.Add("response_type", "FetchAuthorizedSoldiers");
                responseHashtable.Add("response_value", CPluginVariable.EncodeStringArray(soldierNames));

                //TODO: add error message if target not found

                ExecuteCommand("procon.protected.plugins.call", record.external_responseClass, record.external_responseMethod, "AdKats", JSON.JsonEncode(responseHashtable));
            }
            catch (Exception e) {
                //Log the error in console
                HandleException(new AdKatsException("Error returning authorized soldiers .", e));
            }
            DebugWrite("SendAuthorizedSoldiers finished!", 6);
        }

        private Boolean SubscribeClient(AdKatsClient aClient)
        {
            if (aClient == null)
            {
                ConsoleError("24134: Client null when issuing subscription.");
                return false;
            }
            if (String.IsNullOrEmpty(aClient.ClientName))
            {
                ConsoleError("Attempted to enable subscription without a client name.");
                return false;
            }
            if (String.IsNullOrEmpty(aClient.ClientMethod))
            {
                ConsoleError("Attempted to enable subscription for " + aClient.ClientName + " without a client method.");
                return false;
            }
            if (String.IsNullOrEmpty(aClient.SubscriptionGroup))
            {
                ConsoleError("Attempted to enable subscription for " + aClient.ClientName + " with a blank group.");
                return false;
            }
            if (!_subscriptionGroups.Contains(aClient.SubscriptionGroup))
            {
                ConsoleError("Attempted to enable subscription for " + aClient.ClientName + " with an invalid group.");
                return false;
            }
            if (_subscribedClients.Any(iClient => 
                iClient.ClientName == aClient.ClientName && 
                iClient.ClientMethod == aClient.ClientMethod && 
                iClient.SubscriptionGroup == aClient.SubscriptionGroup)) {
                ConsoleError("Client " + aClient.ClientName + " already subscribed to " + aClient.SubscriptionGroup + ". Events are being sent to " + aClient.ClientMethod + ".");
                return false;
            }
            _subscribedClients.Add(aClient);
            ConsoleSuccess(aClient.ClientName + " now subscribed to " + aClient.SubscriptionGroup + ". Events will be sent to " + aClient.ClientMethod + ".");
            return true;
        }

        private Boolean UnsubscribeClient(AdKatsClient aClient)
        {
            if (aClient == null)
            {
                ConsoleError("24169: Client null when issuing subscription.");
                return false;
            }
            AdKatsClient eClient = 
                _subscribedClients.Where(iClient => 
                    iClient.ClientName == aClient.ClientName && 
                    iClient.ClientMethod == aClient.ClientMethod && 
                    iClient.SubscriptionGroup == aClient.SubscriptionGroup)
                    .FirstOrDefault();
            if (eClient != null)
            {
                _subscribedClients.Remove(eClient);
                ConsoleSuccess("Client " + aClient.ClientName + " unsubscribed from " + aClient.SubscriptionGroup + ". Events no longer being sent to " + aClient.ClientMethod + ".");
                return true;
            }
            ConsoleError("Client " + aClient.ClientName + " attempted to unsubscribe from " + aClient.SubscriptionGroup + " when they don't have an active subscription.");
            return false;
        }

        public void ReceiveLoadoutValidity(params String[] informationParams)
        {
            DebugWrite("ReceiveLoadoutValidity starting!", 6);
            try
            {
                if (!informationParams.Any())
                {
                    ConsoleError("ReceiveLoadoutValidity canceled. No parameters were provided.");
                    return;
                }

                if (informationParams == null)
                {
                    ConsoleError("Loadout validity params were null when attempting to parse. Unable to continue.");
                    return;
                }
                if (informationParams.Length != 2)
                {
                    ConsoleError("Invalid parameter count when attempting to parse loadout validity. Required: [source, jsonParams]. Unable to continue.");
                    return;
                }
                String unparsedValidityJson = informationParams[1];

                Hashtable parsedValidityHashtable = (Hashtable)JSON.JsonDecode(unparsedValidityJson);
                if (parsedValidityHashtable == null)
                {
                    ConsoleError("Loadout valididy params could not be properly converted from JSON. Unable to continue.");
                    return;
                }

                //Import the caller identity
                if (!parsedValidityHashtable.ContainsKey("caller_identity"))
                {
                    ConsoleError("Loadout valididy params didn't contain a caller_identity! Unable to process.");
                    return;
                }
                String identity = (String)parsedValidityHashtable["caller_identity"];
                if (String.IsNullOrEmpty(identity))
                {
                    ConsoleError("caller_identity was empty. Unable to process.");
                    return;
                }
                if (identity != "AdKatsLRT")
                {
                    ConsoleError("Loadout source not recognized. Unable to process.");
                }

                //Import the callback option
                if (!parsedValidityHashtable.ContainsKey("response_requested"))
                {
                    ConsoleError("Loadout valididy params for " + identity + " didn't contain response_requested! Unable to process.");
                    return;
                }
                var callbackRequested = (Boolean)parsedValidityHashtable["response_requested"];
                if (callbackRequested)
                {
                    ConsoleWarn(identity + " requested confirmation response for loadout validity, which is unavailable.");
                }

                //Import the subscription method
                if (!parsedValidityHashtable.ContainsKey("loadout_player"))
                {
                    ConsoleError("Loadout valididy params for " + identity + " didn't contain loadout_player! Unable to process.");
                    return;
                }
                String loadoutPlayer = (String)parsedValidityHashtable["loadout_player"];
                if (String.IsNullOrEmpty(loadoutPlayer))
                {
                    ConsoleError("loadout_player was empty. Unable to process.");
                    return;
                }

                //Import the subscription group
                if (!parsedValidityHashtable.ContainsKey("loadout_valid"))
                {
                    ConsoleError("Loadout valididy params for " + identity + " didn't contain loadout_valid! Unable to process.");
                    return;
                }
                Boolean loadoutValid = (Boolean)parsedValidityHashtable["loadout_valid"];

                AdKatsRecord aRecord;
                if (_LoadoutConfirmDictionary.TryGetValue(loadoutPlayer, out aRecord))
                {
                    ConsoleSuccess("Report " + aRecord.command_numeric + " loadout checked.");
                    aRecord.isLoadoutChecked = true;
                    aRecord.targetLoadoutValid = loadoutValid;
                    QueueRecordForActionHandling(aRecord);
                    _LoadoutConfirmDictionary.Remove(loadoutPlayer);
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while processing loadout validity.", e));
            }
            DebugWrite("ReceiveLoadoutValidity finished!", 6);
        }

        public void SubscribeAsClient(params String[] subscriptionParams)
        {
            DebugWrite("SubscribeAsClient starting!", 6);
            if (!subscriptionParams.Any())
            {
                ConsoleError("SubscribeAsClient canceled. No parameters were provided.");
                return;
            }

            if (subscriptionParams == null)
            {
                ConsoleError("Subscription params were null when attempting to subscribe. Unable to continue.");
                return;
            }
            if (subscriptionParams.Length != 2)
            {
                ConsoleError("Invalid parameter count when attempting to subscribe. Required: [source, jsonParams]. Unable to continue.");
                return;
            }
            String unparsedSubscriptionJSON = subscriptionParams[1];

            Hashtable parsedClientInformation = (Hashtable)JSON.JsonDecode(unparsedSubscriptionJSON);
            if (parsedClientInformation == null)
            {
                ConsoleError("Subscription params could not be properly converted from JSON. Unable to continue.");
                return;
            }

            //Create new client
            AdKatsClient aClient = new AdKatsClient(this);

            //Import the caller identity
            if (!parsedClientInformation.ContainsKey("caller_identity"))
            {
                ConsoleError("Subscription params didn't contain a caller_identity! Unable to process.");
                return;
            }
            aClient.ClientName = (String)parsedClientInformation["caller_identity"];
            if (String.IsNullOrEmpty(aClient.ClientName))
            {
                ConsoleError("caller_identity was empty. Unable to process.");
                return;
            }

            //Import the callback option
            if (!parsedClientInformation.ContainsKey("response_requested"))
            {
                ConsoleError("Subscription params for " + aClient.ClientName + " didn't contain response_requested! Unable to process.");
                return;
            }
            var callbackRequested = (Boolean)parsedClientInformation["response_requested"];
            if (callbackRequested) {
                ConsoleWarn(aClient.ClientName + " requested confirmation response for group subscription, which is unavailable.");
            }

            //Import the subscription method
            if (!parsedClientInformation.ContainsKey("subscription_method"))
            {
                ConsoleError("Subscription params for " + aClient.ClientName + " didn't contain subscription_method! Unable to process.");
                return;
            }
            String subMethod = (String)parsedClientInformation["subscription_method"];
            if (String.IsNullOrEmpty(subMethod))
            {
                ConsoleError("subscription_method was empty. Unable to process.");
                return;
            }
            aClient.ClientMethod = subMethod;

            //Import the subscription group
            if (!parsedClientInformation.ContainsKey("subscription_group"))
            {
                ConsoleError("Subscription params for " + aClient.ClientName + " didn't contain subscription_group! Unable to process.");
                return;
            }
            String subGroup = (String)parsedClientInformation["subscription_group"];
            if (String.IsNullOrEmpty(subGroup))
            {
                ConsoleError("subscription_group was empty. Unable to process.");
                return;
            }
            if (!_subscriptionGroups.Contains(subGroup))
            {
                ConsoleError("subscription_group was invalid, not found in subscription group library. Unable to process.");
                return;
            }
            aClient.SubscriptionGroup = subGroup;

            //Import the subscription method
            if (!parsedClientInformation.ContainsKey("subscription_enabled"))
            {
                ConsoleError("Subscription params for " + aClient.ClientName + " didn't contain subscription_enabled! Unable to process.");
                return;
            }
            Boolean subEnabled = (Boolean)parsedClientInformation["subscription_enabled"];
            if (subEnabled) {
                aClient.EnableSubscription();
                SubscribeClient(aClient);
            }
            else {
                aClient.DisableSubscription();
                UnsubscribeClient(aClient);
            }

            DebugWrite("SubscribeAsClient finished!", 6);
        }

        private Boolean SendOnlineSoldiers(AdKatsClient client)
        {
            DebugWrite("SendOnlineSoldiers starting!", 6);
            try
            {
                if (client == null) {
                    ConsoleError("Client was null when sending online soldiers.");
                    return false;
                }
                if (String.IsNullOrEmpty(client.ClientName))
                {
                    ConsoleError("Client name was empty when sending online players.");
                    return false;
                }
                if (String.IsNullOrEmpty(client.ClientMethod))
                {
                    ConsoleError("Client method was empty when sending online players.");
                    return false;
                }

                //Get player list
                List<AdKatsPlayer> playerList = _PlayerDictionary.Values.ToList();
                
                //Parse player list
                ArrayList onlineSoldierList = new ArrayList();
                foreach (AdKatsPlayer aPlayer in playerList) {
                    Hashtable tPlayer = new Hashtable();
                    tPlayer["player_id"] = aPlayer.player_id;
                    tPlayer["player_guid"] = aPlayer.player_guid;
                    tPlayer["player_pbguid"] = aPlayer.player_pbguid;
                    tPlayer["player_ip"] = aPlayer.player_ip;
                    if (aPlayer.location != null && aPlayer.location.status == "success") 
                    {
                        tPlayer["player_country"] = aPlayer.location.countryCode;
                    }
                    else
                    {
                        tPlayer["player_country"] = null;
                    }
                    tPlayer["player_name"] = aPlayer.player_name;
                    tPlayer["player_online"] = aPlayer.player_online;
                    tPlayer["player_personaID"] = aPlayer.player_personaID;
                    tPlayer["player_clanTag"] = aPlayer.player_clanTag;
                    tPlayer["player_aa"] = aPlayer.player_aa;
                    tPlayer["player_ping"] = Math.Round(aPlayer.player_ping_avg, 2);
                    tPlayer["player_reputation"] = Math.Round(aPlayer.player_reputation, 3);
                    tPlayer["player_infractionPoints"] = FetchPoints(aPlayer, false);
                    tPlayer["player_role"] = aPlayer.player_role.role_key;
                    tPlayer["player_type"] = aPlayer.player_type.ToString();
                    tPlayer["player_isAdmin"] = PlayerIsAdmin(aPlayer);
                    tPlayer["player_reported"] = aPlayer.TargetedRecords.Any(aRecord => aRecord.command_type.command_key == "player_report" || aRecord.command_type.command_key == "player_calladmin");
                    tPlayer["player_punished"] = aPlayer.TargetedRecords.Any(aRecord => aRecord.command_type.command_key == "player_punish");
                    tPlayer["player_marked"] = aPlayer.TargetedRecords.Any(aRecord => aRecord.command_type.command_key == "player_mark");
                    if (aPlayer.LastPunishment != null)
                    {
                        tPlayer["player_lastPunishment"] = Math.Round((UtcDbTime() - aPlayer.LastPunishment.record_time).TotalSeconds);
                    }
                    else
                    {
                        tPlayer["player_lastPunishment"] = 0;
                    }
                    if (aPlayer.LastForgive != null)
                    {
                        tPlayer["player_lastForgive"] = Math.Round((UtcDbTime() - aPlayer.LastForgive.record_time).TotalSeconds);
                    }
                    else
                    {
                        tPlayer["player_lastForgive"] = 0;
                    }
                    tPlayer["player_lastAction"] = Math.Round((UtcDbTime() - aPlayer.lastAction).TotalSeconds);
                    tPlayer["player_spawnedOnce"] = aPlayer.player_spawnedOnce;
                    tPlayer["player_conversationPartner"] = ((aPlayer.conversationPartner == null) ? ("") : (aPlayer.conversationPartner.player_name));
                    tPlayer["player_kills"] = (aPlayer.frostbitePlayerInfo == null) ? (0) : (aPlayer.frostbitePlayerInfo.Kills);
                    tPlayer["player_deaths"] = (aPlayer.frostbitePlayerInfo == null) ? (0) : (aPlayer.frostbitePlayerInfo.Deaths);
                    tPlayer["player_kdr"] = (aPlayer.frostbitePlayerInfo == null) ? (0) : Math.Round(aPlayer.frostbitePlayerInfo.Kdr, 2);
                    tPlayer["player_rank"] = (aPlayer.frostbitePlayerInfo == null) ? (0) : (aPlayer.frostbitePlayerInfo.Rank);
                    tPlayer["player_score"] = (aPlayer.frostbitePlayerInfo == null) ? (0) : (aPlayer.frostbitePlayerInfo.Score);
                    tPlayer["player_squad"] = (aPlayer.frostbitePlayerInfo == null) ? (0) : (aPlayer.frostbitePlayerInfo.SquadID);
                    tPlayer["player_team"] = (aPlayer.frostbitePlayerInfo == null) ? (0) : (aPlayer.frostbitePlayerInfo.TeamID);
                    onlineSoldierList.Add(tPlayer);
                }

                Hashtable responseHashtable = new Hashtable();
                responseHashtable.Add("caller_identity", "AdKats");
                responseHashtable.Add("response_requested", false);
                responseHashtable.Add("response_type", "OnlineSoldiers");
                responseHashtable.Add("response_value", onlineSoldierList);

                ExecuteCommand("procon.protected.plugins.call", client.ClientName, client.ClientMethod, "AdKats", JSON.JsonEncode(responseHashtable));
                return true;
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error sending online soldiers.", e));
            }
            DebugWrite("SendOnlineSoldiers finished!", 6);
            return false;
        }

        public AdKatsPlayerStats FetchPlayerStats(AdKatsPlayer aPlayer) {
            DebugWrite("entering getPlayerStats", 7);
            //Create return value
            var stats = new AdKatsPlayerStats();
            try {
                //Fetch from BF3Stats
                Hashtable responseData = null;
                if (_gameVersion == GameVersion.BF3) {
                    responseData = FetchBF3StatsPlayer(aPlayer.player_name);
                    if (responseData != null) {
                        var dataStatus = (String) responseData["status"];
                        if (dataStatus == "error") {
                            stats.StatsException = new AdKatsException("BF3 Stats reported error.");
                        }
                        else if (dataStatus == "notfound") {
                            stats.StatsException = new AdKatsException(aPlayer.player_name + " not found");
                        }
                        else {
                            //Pull the global stats
                            stats.Platform = (String) responseData["plat"];
                            stats.ClanTag = (String) responseData["tag"];
                            stats.Language = (String) responseData["language"];
                            stats.Country = (String) responseData["country"];
                            stats.CountryName = (String) responseData["country_name"];
                            var dtDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0);
                            stats.FirstSeen = dtDateTime.AddSeconds((Double) responseData["date_insert"]);
                            stats.LastPlayerUpdate = dtDateTime.AddSeconds((Double) responseData["date_update"]);

                            //Get internal stats
                            if (dataStatus == "data") {
                                var statsList = (Hashtable) responseData["stats"];
                                stats.LastStatUpdate = dtDateTime.AddSeconds((Double) statsList["date_update"]);
                                //Get rank
                                var rankTable = (Hashtable) statsList["rank"];
                                stats.Rank = (Double) rankTable["nr"];
                                //Get overall
                                var global = (Hashtable) statsList["global"];
                                stats.Kills = (Double) global["kills"];
                                stats.Deaths = (Double) global["deaths"];
                                stats.Wins = (Double) global["wins"];
                                stats.Losses = (Double) global["losses"];
                                stats.Shots = (Double) global["shots"];
                                stats.Hits = (Double) global["hits"];
                                stats.Headshots = (Double) global["headshots"];
                                stats.Time = TimeSpan.FromSeconds((Double) global["time"]);
                                //Get weapons
                                stats.WeaponStats = new Dictionary<String, AdKatsWeaponStats>();
                                var weaponStats = (Hashtable) statsList["weapons"];
                                foreach (String weaponKey in weaponStats.Keys) {
                                    //Create new construct
                                    var weapon = new AdKatsWeaponStats();
                                    //Grab data
                                    var currentWeapon = (Hashtable) weaponStats[weaponKey];
                                    //Parse into construct
                                    weapon.ID = (String) currentWeapon["name"];
                                    weapon.Shots = (Double) currentWeapon["shots"];
                                    weapon.Hits = (Double) currentWeapon["hits"];
                                    weapon.Kills = (Double) currentWeapon["kills"];
                                    weapon.Headshots = (Double) currentWeapon["headshots"];
                                    weapon.Category = (String) currentWeapon["category"];
                                    weapon.Kit = (String) currentWeapon["kit"];
                                    weapon.Range = (String) currentWeapon["range"];
                                    weapon.Time = TimeSpan.FromSeconds((Double) currentWeapon["time"]);
                                    //Calculate values
                                    weapon.HSKR = weapon.Headshots / weapon.Kills;
                                    weapon.KPM = weapon.Kills / weapon.Time.TotalMinutes;
                                    weapon.DPS = weapon.Kills / weapon.Hits * 100;
                                    //Assign the construct
                                    stats.WeaponStats.Add(weapon.ID, weapon);
                                }
                            }
                            else {
                                stats.StatsException = new AdKatsException(aPlayer.player_name + " did not have stats");
                            }
                        }
                    }
                }
                else if (_gameVersion == GameVersion.BF4) {
                    responseData = FetchBF4StatsPlayer(aPlayer.player_name);
                    if (responseData != null) {
                        if (responseData.ContainsKey("error")) {
                            stats.StatsException = new AdKatsException("BF4 stats returned error '" + ((String) responseData["error"]) + "' when querying for player '" + aPlayer.player_name + "'.");
                            ConsoleError(stats.StatsException.ToString());
                            return null;
                        }
                        if (!responseData.ContainsKey("player") || !responseData.ContainsKey("stats") || !responseData.ContainsKey("weapons")) {
                            stats.StatsException = new AdKatsException("BF4 stats response for player '" + aPlayer.player_name + "' was invalid.");
                            ConsoleError(stats.StatsException.ToString());
                            return null;
                        }
                        try {
                            //Player section
                            var playerData = (Hashtable) responseData["player"];
                            if (playerData != null && playerData.Count > 0) {
                                stats.Platform = (String) playerData["plat"];
                                stats.ClanTag = (String) playerData["tag"];
                                stats.Country = (String) playerData["country"];
                                stats.CountryName = (String) playerData["countryName"];
                                var dtDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0);
                                var createMilli = (Double) playerData["dateCreate"];
                                stats.FirstSeen = dtDateTime.AddMilliseconds(createMilli);
                                var updateMilli = (Double) playerData["dateUpdate"];
                                stats.LastPlayerUpdate = dtDateTime.AddMilliseconds(updateMilli);
                                //Get rank
                                var rankData = (Hashtable) playerData["rank"];
                                stats.Rank = (Double) rankData["nr"];
                            }
                            else {
                                stats.StatsException = new AdKatsException(aPlayer.player_name + " did not have global info.");
                            }

                            //Get Stats
                            var statsData = (Hashtable) responseData["stats"];
                            if (statsData != null && statsData.Count > 0) {
                                //Stat last update is the same as last player update in BF4
                                stats.LastStatUpdate = stats.LastPlayerUpdate;
                                stats.Kills = (Double) statsData["kills"];
                                stats.Deaths = (Double) statsData["deaths"];
                                stats.Wins = (Double) statsData["numWins"];
                                stats.Losses = (Double) statsData["numLosses"];
                                stats.Shots = (Double) statsData["shotsFired"];
                                stats.Hits = (Double) statsData["shotsHit"];
                                stats.Headshots = (Double) statsData["headshots"];
                                stats.Time = TimeSpan.FromSeconds((Double) statsData["timePlayed"]);
                            }
                            else {
                                stats.StatsException = new AdKatsException(aPlayer.player_name + " did not have global stats.");
                            }

                            //Get Weapons
                            var weaponData = (ArrayList) responseData["weapons"];
                            if (weaponData != null && weaponData.Count > 0) {
                                stats.WeaponStats = new Dictionary<String, AdKatsWeaponStats>();
                                foreach (Hashtable currentWeapon in weaponData) {
                                    //Create new construct
                                    var weapon = new AdKatsWeaponStats();
                                    //Grab stat data
                                    var currentWeaponStats = (Hashtable) currentWeapon["stat"];
                                    weapon.ID = (String) currentWeaponStats["id"];
                                    weapon.Time = TimeSpan.FromSeconds((Double) currentWeaponStats["time"]);
                                    weapon.Shots = (Double) currentWeaponStats["shots"];
                                    weapon.Hits = (Double) currentWeaponStats["hits"];
                                    weapon.Kills = (Double) currentWeaponStats["kills"];
                                    weapon.Headshots = (Double) currentWeaponStats["hs"];

                                    //Grab detail data
                                    var currentWeaponDetail = (Hashtable) currentWeapon["detail"];
                                    weapon.Category = (String)currentWeaponDetail["category"];

                                    //Attempt to grab weapon max damage
                                    var weaponDetailData = (Hashtable)currentWeaponDetail["weaponData"];
                                    if (weaponDetailData != null && weaponDetailData.ContainsKey("statDamage"))
                                    {
                                        weapon.MaxDPS = (Double)weaponDetailData["statDamage"] * 100;
                                    }
                                    //leave kit alone
                                    //leave range alone
                                    //Calculate values
                                    weapon.HSKR = weapon.Headshots / weapon.Kills;
                                    weapon.KPM = weapon.Kills / weapon.Time.TotalMinutes;
                                    weapon.DPS = weapon.Kills / weapon.Hits * 100;
                                    //Assign the construct
                                    stats.WeaponStats.Add(weapon.ID, weapon);
                                }
                            }
                            else {
                                stats.StatsException = new AdKatsException(aPlayer.player_name + " did not have weapon stats.");
                            }
                        }
                        catch (Exception e) {
                            HandleException(new AdKatsException("Error while parsing BF4Stats player data.", e));
                        }
                    }
                }
            }
            catch (Exception e) {
                stats.StatsException = new AdKatsException("Server error fetching stats.", e);
            }
            //Assign the stats if no errors
            if (stats.StatsException == null) {
                aPlayer.stats = stats;
            }
            DebugWrite("exiting getPlayerStats", 7);
            return stats;
        }

        private Hashtable FetchBF3StatsPlayer(String playerName) {
            Hashtable playerData = null;
            try {
                using (var client = new WebClient()) {
                    var data = new NameValueCollection {
                        {"player", playerName},
                        {"opt", "all"}
                    };
                    byte[] response = client.UploadValues("http://api.bf3stats.com/pc/player/", data);
                    if (response != null) {
                        String textResponse = System.Text.Encoding.Default.GetString(response);
                        playerData = (Hashtable) JSON.JsonDecode(textResponse);
                    }
                }
            }
            catch (Exception e) {
                //Do nothing
            }
            return playerData;
        }

        private Hashtable FetchBF4StatsPlayer(String playerName) {
            Hashtable playerData = null;
            try {
                using (var client = new WebClient()) {
                    var data = new NameValueCollection {
                        {"plat", "pc"},
                        {"name", playerName},
                        {"output", "json"}
                    };
                    byte[] response = client.UploadValues("http://api.bf4stats.com/api/playerInfo", data);
                    if (response != null) {
                        String textResponse = System.Text.Encoding.Default.GetString(response);
                        playerData = (Hashtable) JSON.JsonDecode(textResponse);
                    }
                }
            }
            catch (Exception) {
                //Do nothing
            }
            return playerData;
        }

        public void FetchPlayerBattlelogInformation(AdKatsPlayer aPlayer)
        {
            try
            {
                if (!String.IsNullOrEmpty(aPlayer.player_personaID))
                {
                    return;
                }
                if (String.IsNullOrEmpty(aPlayer.player_name))
                {
                    ConsoleError("Attempted to get battlelog information of nameless player.");
                    return;
                }
                if (_gameVersion == GameVersion.BF3)
                {
                    using (var client = new WebClient())
                    {
                        try
                        {
                            DoBattlelogWait();
                            String response = client.DownloadString("http://battlelog.battlefield.com/bf3/user/" + aPlayer.player_name);
                            Match pid = Regex.Match(response, @"bf3/soldier/" + aPlayer.player_name + @"/stats/(\d+)", RegexOptions.IgnoreCase | RegexOptions.Singleline);
                            if (!pid.Success)
                            {
                                //HandleException(new AdKatsException("Could not find BF3 persona ID for " + aPlayer.player_name));
                                return;
                            }
                            aPlayer.player_personaID = pid.Groups[1].Value.Trim();
                            DebugWrite("Persona ID fetched for " + aPlayer.player_name, 4);
                            Match tag = Regex.Match(response, @"\[\s*([a-zA-Z0-9]+)\s*\]\s*" + aPlayer.player_name, RegexOptions.IgnoreCase | RegexOptions.Singleline);
                            if (!tag.Success || String.IsNullOrEmpty(tag.Groups[1].Value.Trim())) 
                            {
                                DebugWrite("Could not find BF3 clan tag for " + aPlayer.player_name, 4);
                            }
                            else
                            {
                                aPlayer.player_clanTag = tag.Groups[1].Value.Trim();
                                DebugWrite("Clan tag [" + aPlayer.player_clanTag + "] found for " + aPlayer.player_name, 4);
                            }
                        }
                        catch (Exception)
                        {
                            return;
                        }
                    }
                }
                else if (_gameVersion == GameVersion.BF4)
                {
                    using (var client = new WebClient())
                    {
                        try
                        {
                            DoBattlelogWait();
                            String personaResponse = client.DownloadString("http://battlelog.battlefield.com/bf4/user/" + aPlayer.player_name);
                            Match pid = Regex.Match(personaResponse, @"bf4/soldier/" + aPlayer.player_name + @"/stats/(\d+)", RegexOptions.IgnoreCase | RegexOptions.Singleline);
                            if (!pid.Success)
                            {
                                HandleException(new AdKatsException("Could not find persona ID for " + aPlayer.player_name));
                                return;
                            }
                            aPlayer.player_personaID = pid.Groups[1].Value.Trim();
                            DebugWrite("Persona ID fetched for " + aPlayer.player_name, 4);

                            DoBattlelogWait();
                            String overviewResponse = client.DownloadString("http://battlelog.battlefield.com/bf4/warsawoverviewpopulate/" + aPlayer.player_personaID + "/1/");

                            Hashtable json = (Hashtable)JSON.JsonDecode(overviewResponse);
                            Hashtable data = (Hashtable) json["data"];
                            Hashtable info = null;
                            if (!data.ContainsKey("viewedPersonaInfo") || (info = (Hashtable)data["viewedPersonaInfo"]) == null)
                            {
                                aPlayer.player_clanTag = String.Empty;
                                DebugWrite("Could not find BF4 clan tag for " + aPlayer.player_name, 4);
                            }
                            else
                            {
                                String tag = String.Empty;
                                if (!info.ContainsKey("tag") || String.IsNullOrEmpty(tag = (String)info["tag"]))
                                {
                                    aPlayer.player_clanTag = String.Empty;
                                    DebugWrite("Could not find BF4 clan tag for " + aPlayer.player_name, 4);
                                }
                                else
                                {
                                    aPlayer.player_clanTag = tag;
                                    DebugWrite("Clan tag [" + aPlayer.player_clanTag + "] found for " + aPlayer.player_name, 4);
                                }
                            }
                        }
                        catch (Exception)
                        {
                            return;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while fetching battlelog information for " + aPlayer.player_name, e));
            }
        }
        
        private void PostVersionTracking() {
            if (String.IsNullOrEmpty(_serverInfo.ServerIP)) {
                return;
            }
            try
            {
                using (var client = new WebClient())
                {
                    var data = new NameValueCollection {
                        {"server_ip", _serverInfo.ServerIP},
                        {"server_name", _serverInfo.ServerName},
                        {"adkats_version_current", PluginVersion},
                        {"adkats_enabled", _pluginEnabled.ToString().ToLower()},
                        {"adkats_uptime", (_threadsReady)?(Math.Round((UtcDbTime() - _AdKatsStartTime).TotalSeconds).ToString()):("0")},
                        {"updates_disabled", _versionTrackingDisabled.ToString().ToLower()}
                    };
                    byte[] response = client.UploadValues("http://api.gamerethos.net/adkats/usage", data);
                }
            }
            catch (Exception e)
            {
                //Do nothing
            }
            _LastVersionTrackingUpdate = UtcDbTime();
        }

        private Boolean PopulateCommandReputationDictionaries() {
            try {
                var sourceDic = new Dictionary<String, Double>();
                var targetDic = new Dictionary<String, Double>();
                ArrayList repDefs = FetchAdKatsReputationDefinitions();
                if (repDefs == null || repDefs.Count == 0) {
                    return false;
                }
                foreach (Hashtable repWeapon in repDefs) {
                    sourceDic[(String) repWeapon["command_typeaction"]] = (double) repWeapon["source_weight"];
                    targetDic[(String) repWeapon["command_typeaction"]] = (double) repWeapon["target_weight"];
                }
                _commandSourceReputationDictionary = sourceDic;
                _commandTargetReputationDictionary = targetDic;
                return true;
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while populating command reputation cache", e));
            }
            return false;
        }

        private ArrayList FetchAdKatsReputationDefinitions()
        {
            DebugWrite("Entering FetchAdKatsReputationDefinitions", 7);
            ArrayList repTable = null;
            using (var client = new WebClient())
            {
                String repInfo;
                DebugWrite("Fetching reputation definitions...", 2);
                try
                {
                    repInfo = client.DownloadString("https://raw.github.com/AdKats/AdKats/master/adkatsreputationstats.json");
                    DebugWrite("Reputation definitions fetched.", 1);
                }
                catch (Exception)
                {
                    try
                    {
                        repInfo = client.DownloadString("http://api.gamerethos.net/adkats/fetch/reputation");
                        DebugWrite("Reputation definitions fetched from backup location.", 1);
                    }
                    catch (Exception)
                    {
                        return null;
                    }
                }
                try
                {
                    repTable = (ArrayList)JSON.JsonDecode(repInfo);
                }
                catch (Exception e)
                {
                    HandleException(new AdKatsException("Error while parsing reputation definitions.", e));
                }
            }
            DebugWrite("Exiting FetchAdKatsReputationDefinitions", 7);
            return repTable;
        }

        private Boolean PopulateWeaponNameDictionaries()
        {
            try
            {
                Hashtable weaponNames = FetchAdKatsWeaponNames();
                if (weaponNames == null)
                {
                    return false;
                }
                var gameWeaponNames = (Hashtable)weaponNames[_gameVersion.ToString()];
                if (gameWeaponNames == null) {
                    ConsoleError("Weapons for " + _gameVersion.ToString() + " not found in weapon name library.");
                    return false;
                }
                foreach (DictionaryEntry currentWeapon in gameWeaponNames)
                {
                    //Create new construct
                    String weaponCode = (String)currentWeapon.Key;
                    String shortName = (String)((Hashtable)currentWeapon.Value)["readable_short"];
                    String longName = (String)((Hashtable)currentWeapon.Value)["readable_long"];
                    //Add the weapon name
                    _weaponNames[weaponCode] = new AdKatsWeaponName() {
                        weapon_game = _gameVersion,
                        readable_short = shortName,
                        readable_long = longName
                    };
                }
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Error while populating weapon name cache", e));
            }
            return true;
        }

        private Hashtable FetchAdKatsWeaponNames()
        {
            DebugWrite("Entering FetchAdKatsWeaponNames", 7);
            Hashtable weaponNames = null;
            using (var client = new WebClient())
            {
                String downloadString;
                DebugWrite("Fetching weapon names...", 2);
                try
                {
                    downloadString = client.DownloadString("https://raw.github.com/AdKats/AdKats/master/adkatsweaponnames.json");
                    DebugWrite("Weapon names fetched.", 1);
                }
                catch (Exception)
                {
                    try
                    {
                        downloadString = client.DownloadString("http://api.gamerethos.net/adkats/fetch/weaponnames");
                        DebugWrite("Weapon names fetched from backup location.", 1);
                    }
                    catch (Exception)
                    {
                        return null;
                    }
                }
                try
                {
                    weaponNames = (Hashtable)JSON.JsonDecode(downloadString);
                }
                catch (Exception e)
                {
                    HandleException(new AdKatsException("Error while parsing reputation definitions.", e));
                }
            }
            DebugWrite("Exiting FetchAdKatsWeaponNames", 7);
            return weaponNames;
        }

        private Boolean PopulateSpecialGroupDictionaries()
        {
            DebugWrite("Entering PopulateSpecialGroupsDictionary", 7);
            try
            {
                var groupList = FetchAdKatsSpecialGroupDefinitions();
                if (groupList == null || groupList.Count == 0)
                {
                    return false;
                }
                lock (_specialPlayerGroupKeyDictionary)
                {
                    lock (_specialPlayerGroupIDDictionary)
                    {
                        _specialPlayerGroupIDDictionary.Clear();
                        _specialPlayerGroupKeyDictionary.Clear();
                        foreach (var group in groupList)
                        {
                            _specialPlayerGroupIDDictionary[group.group_id] = group;
                            _specialPlayerGroupKeyDictionary[group.group_key] = group;
                        }
                    }
                }
                return true;
            }
            catch (Exception e)
            {
                HandleException(new AdKatsException("Exception while populating special group cache", e));
            }
            DebugWrite("Exiting PopulateSpecialGroupsDictionary", 7);
            return false;
        }

        private List<AdKatsSpecialGroup> FetchAdKatsSpecialGroupDefinitions()
        {
            DebugWrite("Entering FetchAdKatsSpecialGroupDefinitions", 7);
            List<AdKatsSpecialGroup> SpecialGroupsList = null;
            using (var client = new WebClient())
            {
                String groupInfo;
                DebugWrite("Fetching special group definitions...", 2);
                try
                {
                    groupInfo = client.DownloadString("https://raw.github.com/AdKats/AdKats/master/adkatsspecialgroups.json");
                    DebugWrite("Special group definitions fetched.", 1);
                }
                catch (Exception)
                {
                    try
                    {
                        groupInfo = client.DownloadString("http://api.gamerethos.net/adkats/fetch/specialgroups");
                        DebugWrite("Special group definitions fetched from backup location.", 1);
                    }
                    catch (Exception)
                    {
                        return null;
                    }
                }
                try
                {
                    var groupsTable = (Hashtable)JSON.JsonDecode(groupInfo);
                    ArrayList GroupsList = (ArrayList)groupsTable["SpecialGroups"];
                    if (GroupsList == null || GroupsList.Count == 0)
                    {
                        return null;
                    }
                    SpecialGroupsList = new List<AdKatsSpecialGroup>();
                    foreach (Hashtable groupHash in GroupsList)
                    {
                        AdKatsSpecialGroup update = new AdKatsSpecialGroup();
                        //update_id
                        update.group_id = Convert.ToInt32(groupHash["group_id"]);
                        //group_key
                        Object group_key = groupHash["group_key"];
                        if (group_key == null)
                        {
                            ConsoleError("AdKats special group entry group_key was not found.");
                            continue;
                        }
                        update.group_key = (String)group_key;
                        //group_name
                        Object group_name = groupHash["group_name"];
                        if (group_name == null)
                        {
                            ConsoleError("AdKats special group entry group_name was not found.");
                            continue;
                        }
                        update.group_name = (String)group_name;
                        //Add
                        SpecialGroupsList.Add(update);
                    }
                }
                catch (Exception e)
                {
                    HandleException(new AdKatsException("Error while parsing special group definitions.", e));
                    return null;
                }
            }
            DebugWrite("Exiting FetchAdKatsSpecialGroupDefinitions", 7);
            return SpecialGroupsList;
        }

        private void RunSQLUpdates() {
            DebugWrite("Entering RunSQLUpdates", 7);
            if (_aliveThreads.Values.Any(aThread => aThread.Name == "SQLUpdater"))
            {
                return;
            }
            StartAndLogThread(new Thread(new ThreadStart(delegate
            {
                Thread.CurrentThread.Name = "SQLUpdater";
                Thread.Sleep(250);
                try
                {
                    Int32 currentVersionInt = Int32.Parse(PluginVersion.Replace(".", ""));
                    foreach (AdKatsSQLUpdate update in FetchSQLUpdates())
                    {
                        if (!_pluginEnabled)
                        {
                            break;
                        }
                        if (update == null)
                        {
                            ConsoleError("SQL update was null. Skipping.");
                            continue;
                        }
                        try
                        {
                            //Check for valid version
                            if (!String.IsNullOrEmpty(update.version_minimum) && currentVersionInt < Int32.Parse(update.version_minimum.Replace(".", "")))
                            {
                                DebugWrite("Cancelling SQL update '" + update.update_id + "'. Version too early for update.", 5);
                                continue;
                            }
                            if (!String.IsNullOrEmpty(update.version_maximum) && currentVersionInt > Int32.Parse(update.version_maximum.Replace(".", "")))
                            {
                                DebugWrite("Cancelling SQL update '" + update.update_id + "'. Version too late for update.", 5);
                                continue;
                            }
                            //Check for valid initial conditions
                            Boolean invalid = false;
                            foreach (String icheckSQL in update.update_checks)
                            {
                                if (!_pluginEnabled)
                                {
                                    break;
                                }
                                String checkSQL = icheckSQL.Replace("%DATABASENAME%", _mySqlSchemaName);
                                if (SendQuery(checkSQL, false))
                                {
                                    if (!update.update_checks_hasResults)
                                    {
                                        //Has results, when it shouldn't
                                        invalid = true;
                                        break;
                                    }
                                }
                                else
                                {
                                    if (update.update_checks_hasResults)
                                    {
                                        //Doesn't have results, when it should
                                        invalid = true;
                                        break;
                                    }
                                }
                            }
                            if (invalid)
                            {
                                DebugWrite("Cancelling SQL update '" + update.update_id + "', it does not apply to this database.", 5);
                                continue;
                            }
                            //Run the updates
                            Int32 executeIndex = 0;
                            Boolean failed = false;
                            foreach (String iexecuteSQL in update.update_execute)
                            {
                                if (!_pluginEnabled)
                                {
                                    break;
                                }
                                String executeSQL = iexecuteSQL.Replace("%DATABASENAME%", _mySqlSchemaName);
                                if (!SendNonQuery("Executing SQL Update '" + update.update_id + "' (" + update.message_name + ")" + executeIndex++, executeSQL, false) && update.update_execute_requiresModRows)
                                {
                                    failed = true;
                                    break;
                                }
                            }
                            if (failed)
                            {
                                ConsoleError("Cancelling SQL update '" + update.update_id + "'. Update failed execution (" + update.message_failure + "), running failure clause(s). ");
                                Int32 failureIndex = 0;
                                foreach (String failureSQL in update.update_failure)
                                {
                                    SendNonQuery("Running SQL Update '" + update.update_id + "' Failure Clause " + failureIndex++, failureSQL, false);
                                }
                                continue;
                            }
                            ConsoleSuccess("SQL Update '" + update.update_id + "' completed execution (" + update.message_success + ").");
                            Int32 successIndex = 0;
                            foreach (String successSQL in update.update_success)
                            {
                                if (!_pluginEnabled)
                                {
                                    break;
                                }
                                SendNonQuery("Running SQL Update '" + update.update_id + "' Success Clause " + successIndex++, successSQL, false);
                            }
                        }
                        catch (Exception e)
                        {
                            HandleException(new AdKatsException("Error while running SQL update '" + update.update_id + "'.", e));
                        }
                    }
                }
                catch (Exception e)
                {
                    HandleException(new AdKatsException("Error while processing SQL updates.", e));
                }
                LogThreadExit();
            })));
            DebugWrite("Exiting RunSQLUpdates", 7);
        }

        private List<AdKatsSQLUpdate> FetchSQLUpdates()
        {
            DebugWrite("Entering FetchSQLUpdates", 7);
            List<AdKatsSQLUpdate> SQLUpdates = new List<AdKatsSQLUpdate>();
            using (var client = new WebClient())
            {
                try
                {
                    String updateInfo;
                    try
                    {
                        updateInfo = client.DownloadString("https://raw.github.com/AdKats/AdKats/master/adkatsupdates.json");
                        DebugWrite("SQL updates fetched.", 1);
                    }
                    catch (Exception)
                    {
                        try
                        {
                            updateInfo = client.DownloadString("http://api.gamerethos.net/adkats/fetch/sqlupdates");
                            DebugWrite("SQL updates fetched from backup location.", 1);
                        }
                        catch (Exception)
                        {
                            ConsoleError("Unable to download SQL updates.");
                            return SQLUpdates;
                        }
                    }
                    Hashtable updateTable = (Hashtable)JSON.JsonDecode(updateInfo);
                    ArrayList SQLUpdateList = (ArrayList) updateTable["SQLUpdates"];
                    if (SQLUpdateList != null && SQLUpdateList.Count > 0) {
                        DebugWrite("SQL updates found. Parsing...", 5);
                        foreach (Hashtable updateHash in SQLUpdateList) {
                            AdKatsSQLUpdate update = new AdKatsSQLUpdate();
                            //update_id
                            update.update_id = (String)updateHash["update_id"];
                            if (String.IsNullOrEmpty(update.update_id))
                            {
                                ConsoleError("SQL update update_id was not found or empty.");
                                continue;
                            }
                            DebugWrite("Parsing SQL Update '" + update.update_id + "'", 5);
                            //version_minimum
                            update.version_minimum = (String)updateHash["version_minimum"];
                            DebugWrite("SQL update '" + update.update_id + "' version_minimum: " + update.version_minimum, 5);
                            //version_maximum
                            update.version_maximum = (String)updateHash["version_maximum"];
                            DebugWrite("SQL update '" + update.update_id + "' version_maximum: " + update.version_maximum, 5);
                            //message_name
                            update.message_name = (String)updateHash["message_name"];
                            if (String.IsNullOrEmpty(update.message_name))
                            {
                                ConsoleError("SQL update '" + update.update_id + "' message_name was not found or empty.");
                                continue;
                            }
                            DebugWrite("SQL update '" + update.update_id + "' message_name: " + update.message_name, 5);
                            //message_success
                            update.message_success = (String)updateHash["message_success"];
                            if (String.IsNullOrEmpty(update.message_success))
                            {
                                ConsoleError("SQL update '" + update.update_id + "' message_success was not found or empty.");
                                continue;
                            }
                            DebugWrite("SQL update '" + update.update_id + "' message_success: " + update.message_success, 5);
                            //message_failure
                            update.message_failure = (String)updateHash["message_failure"];
                            if (String.IsNullOrEmpty(update.message_failure))
                            {
                                ConsoleError("SQL update '" + update.update_id + "' message_failure was not found or empty.");
                                continue;
                            }
                            DebugWrite("SQL update '" + update.update_id + "' message_failure: " + update.message_failure, 5);
                            //update_checks_hasResults
                            Object update_checks_hasResults = updateHash["update_checks_hasResults"];
                            if (update_checks_hasResults == null)
                            {
                                ConsoleError("SQL update '" + update.update_id + "' update_checks_hasResults was not found.");
                                continue;
                            }
                            update.update_checks_hasResults = (Boolean)update_checks_hasResults;
                            DebugWrite("SQL update '" + update.update_id + "' update_checks_hasResults: " + update.update_checks_hasResults, 5);
                            //update_checks
                            var update_checks = (ArrayList)updateHash["update_checks"];
                            if (update_checks == null) {
                                ConsoleError("SQL update '" + update.update_id + "' update_checks was not found.");
                                continue;
                            }
                            foreach (String line in update_checks)
                            {
                                update.update_checks.Add(line);
                            }
                            DebugWrite("SQL update '" + update.update_id + "' update_checks: " + update.update_checks.Count, 5);
                            //update_execute_requiresModRows
                            Object update_execute_requiresModRows = updateHash["update_execute_requiresModRows"];
                            if (update_execute_requiresModRows == null)
                            {
                                ConsoleError("SQL update '" + update.update_id + "' update_execute_requiresModRows was not found.");
                                continue;
                            }
                            update.update_execute_requiresModRows = (Boolean)update_execute_requiresModRows;
                            DebugWrite("SQL update '" + update.update_id + "' update_execute_requiresModRows: " + update.update_execute_requiresModRows, 5);
                            //update_execute
                            var update_execute = (ArrayList)updateHash["update_execute"];
                            if (update_execute == null)
                            {
                                ConsoleError("SQL update '" + update.update_id + "' update_execute was not found.");
                                continue;
                            }
                            foreach (String line in update_execute)
                            {
                                update.update_execute.Add(line);
                            }
                            DebugWrite("SQL update '" + update.update_id + "' update_execute: " + update.update_execute.Count, 5);
                            //update_success
                            var update_success = (ArrayList)updateHash["update_success"];
                            if (update_success == null)
                            {
                                ConsoleError("SQL update '" + update.update_id + "' update_success was not found.");
                                continue;
                            }
                            foreach (String line in update_success)
                            {
                                update.update_success.Add(line);
                            }
                            DebugWrite("SQL update '" + update.update_id + "' update_success: " + update.update_success.Count, 5);
                            //update_failure
                            var update_failure = (ArrayList)updateHash["update_failure"];
                            if (update_failure == null)
                            {
                                ConsoleError("SQL update '" + update.update_id + "' update_failure was not found.");
                                continue;
                            }
                            foreach (String line in update_failure)
                            {
                                update.update_failure.Add(line);
                            }
                            DebugWrite("SQL update '" + update.update_id + "' update_failure: " + update.update_failure.Count, 5);
                            //Add
                            SQLUpdates.Add(update);
                        }
                    }
                    else {
                        DebugWrite("No SQL updates found.", 5);
                    }
                }
                catch (Exception e)
                {
                    if (_isTestingAuthorized) {
                        HandleException(new AdKatsException("Error while fetching SQL updates.", e));
                    }
                    else {
                        ConsoleError("Unable to process SQL updates.");
                    }
                }
            }
            DebugWrite("Exiting FetchSQLUpdates", 7);
            return SQLUpdates;
        }

        private void PushThreadDebug(Int64 ticks, String thread, Int32 threadid, Int32 line, String element) {
            try {
                DebugWrite(ticks + " " + thread + " " + threadid + " " + line + " " + element, 8);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("error pushing thread debug", e));
            }
        }

        private String ReplacePlayerInformation(String originalString, AdKatsPlayer aPlayer) {
            String processedString = "";
            if (String.IsNullOrEmpty(originalString)) {
                return processedString;
            }
            //Create new instance of original string
            processedString += originalString;
            if (aPlayer == null) {
                return processedString;
            }
            if (aPlayer.player_id > 0) {
                processedString = processedString.Replace("%player_id%", aPlayer.player_id + "");
            }
            if (!String.IsNullOrEmpty(aPlayer.player_name)) {
                processedString = processedString.Replace("%player_name%", aPlayer.player_name);
            }
            if (!String.IsNullOrEmpty(aPlayer.player_guid)) {
                processedString = processedString.Replace("%player_guid%", aPlayer.player_guid);
            }
            if (!String.IsNullOrEmpty(aPlayer.player_pbguid)) {
                processedString = processedString.Replace("%player_pbguid%", aPlayer.player_pbguid);
            }
            if (!String.IsNullOrEmpty(aPlayer.player_ip)) {
                processedString = processedString.Replace("%player_ip%", aPlayer.player_ip);
            }
            return processedString;
        }

        public Boolean UserIsAdmin(AdKatsUser aUser) {
            return aUser != null && RoleIsAdmin(aUser.user_role);
        }

        public Boolean PlayerIsAdmin(AdKatsPlayer aPlayer) {
            return aPlayer != null && RoleIsAdmin(aPlayer.player_role);
        }

        public Boolean PlayerIsExternal(AdKatsPlayer aPlayer) {
            return aPlayer.player_server.ServerID != _serverInfo.ServerID;
        }

        public Boolean RoleIsAdmin(AdKatsRole aRole) {
            if (aRole == null) {
                ConsoleError("role null in RoleIsAdmin");
                return false;
            }
            if (aRole.RoleAllowedCommands.Values.Any(command => command.command_playerInteraction))
            {
                return true;
            }
            return false;
        }

        public Boolean PlayerIsWinning(AdKatsPlayer aPlayer)
        {
            if (aPlayer.frostbitePlayerInfo == null) {
                return false;
            }
            //Team Info Check
            AdKatsTeam team1 = _teamDictionary[1];
            AdKatsTeam team2 = _teamDictionary[2];
            AdKatsTeam winningTeam, losingTeam;
            if (team1.TeamTicketCount > team2.TeamTicketCount)
            {
                winningTeam = team1;
                losingTeam = team2;
            }
            else
            {
                winningTeam = team2;
                losingTeam = team1;
            }
            return aPlayer.frostbitePlayerInfo.TeamID == winningTeam.TeamID;
        }

        public AdKatsCommand GetCommandByKey(String commandKey) {
            AdKatsCommand command = null;
            if (String.IsNullOrEmpty(commandKey)) {
                HandleException(new AdKatsException("commandKey was null when fetching command"));
                return command;
            }
            _CommandKeyDictionary.TryGetValue(commandKey, out command);
            if (command == null) {
                HandleException(new AdKatsException("Unable to get command for key '" + commandKey + "'"));
            }
            return command;
        }

        public String GetShortWeaponNameByCode(String weaponCode)
        {
            AdKatsWeaponName weaponName = null;
            if (String.IsNullOrEmpty(weaponCode))
            {
                HandleException(new AdKatsException("weaponCode was null when fetching weapon name"));
                return null;
            }
            _weaponNames.TryGetValue(weaponCode, out weaponName);
            if (weaponName == null)
            {
                HandleException(new AdKatsException("Unable to get weapon name for code '" + weaponCode + "'"));
                return weaponCode;
            }
            return weaponName.readable_short;
        }

        public String GetLongWeaponNameByCode(String weaponCode)
        {
            AdKatsWeaponName weaponName = null;
            if (String.IsNullOrEmpty(weaponCode))
            {
                HandleException(new AdKatsException("weaponCode was null when fetching weapon name"));
                return null;
            }
            _weaponNames.TryGetValue(weaponCode, out weaponName);
            if (weaponName == null)
            {
                HandleException(new AdKatsException("Unable to get weapon name for code '" + weaponCode + "'"));
                return weaponCode;
            }
            return weaponName.readable_short;
        }

        public String GetPlayerTeamKey(AdKatsPlayer aPlayer)
        {
            String teamKey = "UKN";
            if (aPlayer == null || aPlayer.frostbitePlayerInfo == null)
            {
                return teamKey;
            }
            AdKatsTeam aTeam;
            if (GetTeamByID(aPlayer.frostbitePlayerInfo.TeamID, out aTeam))
            {
                return aTeam.TeamKey;
            }
            return teamKey;
        }

        public String GetPlayerTeamName(AdKatsPlayer aPlayer)
        {
            String teamName = "Unknown";
            if (aPlayer == null || aPlayer.frostbitePlayerInfo == null)
            {
                return teamName;
            }
            AdKatsTeam aTeam;
            if (GetTeamByID(aPlayer.frostbitePlayerInfo.TeamID, out aTeam))
            {
                return aTeam.TeamName;
            }
            return teamName;
        }

        public Boolean GetTeamByID(Int32 teamID, out AdKatsTeam aTeam) {
            aTeam = null;
            if (_teamDictionary.TryGetValue(teamID, out aTeam)) {
                return true;
            }
            HandleException(new AdKatsException("Team not found for ID " + teamID + " in dictionary of " + _teamDictionary.Count + " teams."));
            return false;
        }

        public String ExtractString(String s, String tag) {
            if (String.IsNullOrEmpty(s) || String.IsNullOrEmpty(tag))
            {
                ConsoleError("Unable to extract string '" + s + "'. Invalid inputs.");
                return null;
            }
            String startTag = "<" + tag + ">";
            Int32 startIndex = s.IndexOf(startTag, System.StringComparison.Ordinal) + startTag.Length;
            if (startIndex == -1) {
                ConsoleError("Unable to extract string '" + s + "'. Starting tag not found.");
                return null;
            }
            Int32 endIndex = s.IndexOf("</" + tag + ">", startIndex, System.StringComparison.Ordinal);
            if (startIndex == -1)
            {
                ConsoleError("Unable to extract string '" + s + "'. Ending tag not found.");
                return null;
            }
            return s.Substring(startIndex, endIndex - startIndex);
        }

        public Boolean SoldierNameValid(String input) {
            try {
                DebugWrite("Checking player '" + input + "' for validity.", 7);
                if (String.IsNullOrEmpty(input)) {
                    DebugWrite("Soldier Name empty or null.", 5);
                    return false;
                }
                if (input.Length > 16) {
                    DebugWrite("Soldier Name '" + input + "' too long, maximum length is 16 characters.", 5);
                    return false;
                }
                if (new Regex("[^a-zA-Z0-9_-]").Replace(input, "").Length != input.Length) {
                    DebugWrite("Soldier Name '" + input + "' contained invalid characters.", 5);
                    return false;
                }
                return true;
            }
            catch (Exception) {
                //Soldier id caused exception in the regex, definitely not valid
                ConsoleError("Soldier Name '" + input + "' contained invalid characters.");
                return false;
            }
        }

        public String FormatTimeString(TimeSpan timeSpan, Int32 maxComponents) {
            DebugWrite("Entering formatTimeString", 7);
            String timeString = null;
            if (maxComponents < 1) {
                return timeString;
            }
            try {
                String formattedTime = (timeSpan.TotalMilliseconds >= 0) ? ("") : ("-");

                Double secondSubset = Math.Abs(timeSpan.TotalSeconds);
                if (secondSubset < 1) {
                    return "0s";
                }
                Double minuteSubset = (secondSubset / 60);
                Double hourSubset = (minuteSubset / 60);
                Double daySubset = (hourSubset / 24);
                Double weekSubset = (daySubset / 7);
                Double monthSubset = (weekSubset / 4);
                Double yearSubset = (monthSubset / 12);

                var years = (Int32) yearSubset;
                Int32 months = (Int32) monthSubset % 12;
                Int32 weeks = (Int32) weekSubset % 4;
                Int32 days = (Int32) daySubset % 7;
                Int32 hours = (Int32) hourSubset % 24;
                Int32 minutes = (Int32) minuteSubset % 60;
                Int32 seconds = (Int32) secondSubset % 60;

                Int32 usedComponents = 0;
                if (years > 0 && usedComponents < maxComponents) {
                    usedComponents++;
                    formattedTime += years + "y";
                }
                if (months > 0 && usedComponents < maxComponents) {
                    usedComponents++;
                    formattedTime += months + "M";
                }
                if (weeks > 0 && usedComponents < maxComponents) {
                    usedComponents++;
                    formattedTime += weeks + "w";
                }
                if (days > 0 && usedComponents < maxComponents) {
                    usedComponents++;
                    formattedTime += days + "d";
                }
                if (hours > 0 && usedComponents < maxComponents) {
                    usedComponents++;
                    formattedTime += hours + "h";
                }
                if (minutes > 0 && usedComponents < maxComponents) {
                    usedComponents++;
                    formattedTime += minutes + "m";
                }
                if (seconds > 0 && usedComponents < maxComponents) {
                    usedComponents++;
                    formattedTime += seconds + "s";
                }
                timeString = formattedTime;
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while formatting time String.", e));
            }
            if (String.IsNullOrEmpty(timeString)) {
                timeString = "0s";
            }
            DebugWrite("Exiting formatTimeString", 7);
            return timeString;
        }

        private Double ConvertToTimestamp(DateTime value) {
            //create Timespan by subtracting the value provided from
            //the Unix Epoch
            TimeSpan span = (value - new DateTime(1970, 1, 1, 0, 0, 0, 0).ToLocalTime());

            //return the total seconds (which is a UNIX timestamp)
            return span.TotalSeconds;
        }

        private void RemovePlayerFromDictionary(String playerName, Boolean lockDictionary) {
            DebugWrite("Entering removePlayerFromDictionary", 7);
            try {
                //If the player is currently in the player list, remove them
                if (!String.IsNullOrEmpty(playerName)) {
                    if (_PlayerDictionary.ContainsKey(playerName)) {
                        DebugWrite("Removing " + playerName + " from current player list.", 4);
                        if (lockDictionary) {
                            lock (_PlayerDictionary) {
                                _PlayerDictionary.Remove(playerName);
                            }
                        }
                        else {
                            _PlayerDictionary.Remove(playerName);
                        }
                    }
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while removing player from player dictionary.", e));
            }
            DebugWrite("Exiting removePlayerFromDictionary", 7);
        }

        public CPlayerInfo BuildCPlayerInfo(String playerName, String playerGUID) {
            DebugWrite("Entering ", 7);
            CPlayerInfo playerInfo = null;
            try {
                IList<String> lstParameters = new List<String>();
                IList<String> lstVariables = new List<String>();
                lstParameters.Add("id");
                lstVariables.Add(playerName);
                lstParameters.Add("guid");
                lstVariables.Add(playerGUID);
                playerInfo = new CPlayerInfo(lstParameters, lstVariables);
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while creating CPlayerInfo object.", e));
            }
            DebugWrite("Exiting ", 7);
            return playerInfo;
        }

        private TimeSpan GetRemainingBanTime(AdKatsBan aBan) {
            return aBan.ban_endTime.Subtract(UtcDbTime());
        }

        public Boolean ConfirmStatLoggerSetup() {
            //This function has been disabled for now

            //Make sure database connection active
            if (HandlePossibleDisconnect()) {
                return false;
            }
            try {
                List<MatchCommand> registered = GetRegisteredCommands();
                MatchCommand loggerStatusCommand = null;
                foreach (MatchCommand command in registered) {
                    if (System.String.Compare(command.RegisteredClassname, "CChatGUIDStatsLoggerBF3", System.StringComparison.Ordinal) == 0 && System.String.Compare(command.RegisteredMethodName, "GetStatus", System.StringComparison.Ordinal) == 0) {
                        loggerStatusCommand = command;
                        DebugWrite("Found command for BF3 stat logger.", 5);
                        break;
                    }
                    if (System.String.Compare(command.RegisteredClassname, "CChatGUIDStatsLogger", System.StringComparison.Ordinal) == 0 && System.String.Compare(command.RegisteredMethodName, "GetStatus", System.StringComparison.Ordinal) == 0) {
                        loggerStatusCommand = command;
                        DebugWrite("Found command for Universal stat logger.", 5);
                        break;
                    }
                }
                if (loggerStatusCommand != null) {
                    //Stat logger is installed, fetch its status
                    Hashtable statLoggerStatus = GetStatLoggerStatus();

                    //Only continue if response value
                    if (statLoggerStatus == null) {
                        return false;
                    }
                    foreach (String key in statLoggerStatus.Keys) {
                        DebugWrite("Logger response: (" + key + "): " + statLoggerStatus[key], 5);
                    }
                    if (((String) statLoggerStatus["pluginVersion"]) != "1.1.0.2") {
                        ConsoleError("Invalid version of CChatGUIDStatsLoggerBF3 installed. Version 1.1.0.2 is required. If there is a new version, inform ColColonCleaner.");
                        return false;
                    }

                    if (!Regex.Match((String) statLoggerStatus["DBHost"], _mySqlHostname, RegexOptions.IgnoreCase).Success || !Regex.Match((String) statLoggerStatus["DBPort"], _mySqlPort, RegexOptions.IgnoreCase).Success || !Regex.Match((String) statLoggerStatus["DBName"], _mySqlSchemaName, RegexOptions.IgnoreCase).Success) {
                        //Are db settings set for AdKats? If not, import them from stat logger.
                        if (String.IsNullOrEmpty(_mySqlHostname) || String.IsNullOrEmpty(_mySqlPort) || String.IsNullOrEmpty(_mySqlSchemaName)) {
                            _mySqlHostname = (String) statLoggerStatus["DBHost"];
                            _mySqlPort = (String) statLoggerStatus["DBPort"];
                            _mySqlSchemaName = (String) statLoggerStatus["DBName"];
                            UpdateSettingPage();
                        }
                        //Are DB Settings set for stat logger? If not, set them
                        if (String.IsNullOrEmpty((String) statLoggerStatus["DBHost"]) || String.IsNullOrEmpty((String) statLoggerStatus["DBPort"]) || String.IsNullOrEmpty((String) statLoggerStatus["DBName"])) {
                            SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Host", _mySqlHostname);
                            SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Port", _mySqlPort);
                            SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Database Name", _mySqlSchemaName);
                            SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "UserName", _mySqlUsername);
                            SetExternalPluginSetting("CChatGUIDStatsLoggerBF3", "Password", _mySqlPassword);

                            ConsoleError("CChatGUIDStatsLoggerBF3 database connection was not configured. It has been set up to use the same database and credentials as AdKats.");
                            //Update the logger status
                            statLoggerStatus = GetStatLoggerStatus();
                        }
                        else {
                            ConsoleError("CChatGUIDStatsLoggerBF3 is not set up to use the same database as AdKats. Modify settings so they both use the same database.");
                            return false;
                        }
                    }
                    if (((String) statLoggerStatus["DBConnectionActive"]) != "True") {
                        ConsoleError("CChatGUIDStatsLoggerBF3's connection to the database is not active. Backup mode Enabled...");
                    }
                    return true;
                }
                ConsoleError("^1^bCChatGUIDStatsLoggerBF3^n plugin not found. Installing special release version 1.1.0.2 of that plugin is required for AdKats!");
                return false;
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while confirming stat logger setup.", e));
                return false;
            }
        }

        public Hashtable GetStatLoggerStatus() {
            //Disabled

            //Make sure AdKats database connection active
            if (HandlePossibleDisconnect()) {
                return null;
            }
            try {
                //Check if enabled
                if (!_pluginEnabled) {
                    DebugWrite("Attempted to fetch stat logger status while plugin disabled.", 4);
                    return null;
                }
                //Build request
                var request = new Hashtable();
                request["pluginName"] = "AdKats";
                request["pluginMethod"] = "HandleStatLoggerStatusResponse";
                // Send request
                _StatLoggerStatusWaitHandle.Reset();
                ExecuteCommand("procon.protected.plugins.call", "CChatGUIDStatsLoggerBF3", "GetStatus", JSON.JsonEncode(request));
                //Wait a maximum of 5 seconds for stat logger response
                if (!_StatLoggerStatusWaitHandle.WaitOne(5000)) {
                    ConsoleWarn("^bCChatGUIDStatsLoggerBF3^n is not enabled or is lagging! Attempting to enable, please wait...");
                    Int32 attempts = 0;
                    Boolean success = false;
                    do {
                        attempts++;
                        DebugWrite("Stat Logger Enable Attempt " + attempts, 2);
                        //Issue the command to enable stat logger
                        ExecuteCommand("procon.protected.plugins.enable", "CChatGUIDStatsLoggerBF3", "True");
                        //Wait 5 seconds for enable and initial connect
                        _threadMasterWaitHandle.WaitOne(5000);
                        //Refetch the status
                        _StatLoggerStatusWaitHandle.Reset();
                        ExecuteCommand("procon.protected.plugins.call", "CChatGUIDStatsLoggerBF3", "GetStatus", JSON.JsonEncode(request));
                        if (_StatLoggerStatusWaitHandle.WaitOne(5000)) {
                            success = true;
                        }
                    } while (!success && attempts < 10);
                    if (!success) {
                        ConsoleError("CChatGUIDStatsLoggerBF3 could not be enabled automatically. Please enable manually.");
                        return null;
                    }
                }
                if (_lastStatLoggerStatusUpdate != null && _lastStatLoggerStatusUpdate.ContainsKey("pluginVersion") && _lastStatLoggerStatusUpdate.ContainsKey("pluginEnabled") && _lastStatLoggerStatusUpdate.ContainsKey("DBHost") && _lastStatLoggerStatusUpdate.ContainsKey("DBPort") && _lastStatLoggerStatusUpdate.ContainsKey("DBName") && _lastStatLoggerStatusUpdate.ContainsKey("DBTimeOffset") && _lastStatLoggerStatusUpdate.ContainsKey("DBConnectionActive") && _lastStatLoggerStatusUpdate.ContainsKey("ChatloggingEnabled") && _lastStatLoggerStatusUpdate.ContainsKey("InstantChatLoggingEnabled") && _lastStatLoggerStatusUpdate.ContainsKey("StatsLoggingEnabled") && _lastStatLoggerStatusUpdate.ContainsKey("DBliveScoreboardEnabled") && _lastStatLoggerStatusUpdate.ContainsKey("DebugMode") && _lastStatLoggerStatusUpdate.ContainsKey("Error")) {
                    //Response appears to be valid, return it
                    return _lastStatLoggerStatusUpdate;
                }
                //Response is invalid, throw error and return null
                ConsoleError("Status response from CChatGUIDStatsLoggerBF3 was not valid.");
                return null;
            }
            catch (Exception) {
                HandleException(new AdKatsException("Error while getting stat logger status."));
                return null;
            }
        }

        public void HandleStatLoggerStatusResponse(params String[] commands) {
            DebugWrite("Entering HandleStatLoggerStatusResponse", 7);
            try {
                if (commands.Length < 1) {
                    ConsoleError("Status fetch response handle canceled, no parameters provided.");
                    return;
                }
                _lastStatLoggerStatusUpdate = (Hashtable) JSON.JsonDecode(commands[0]);
                _lastStatLoggerStatusUpdateTime = UtcDbTime();
                _StatLoggerStatusWaitHandle.Set();
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while handling stat logger status response.", e));
            }
            DebugWrite("Exiting HandleStatLoggerStatusResponse", 7);
        }

        public DateTime UtcDbTime() {
            return DateTime.UtcNow + _dbTimingOffset;
        }

        public static String GetRandom32BitHashCode() {
            String randomString = "";
            var random = new Random();

            for (Int32 i = 0; i < 32; i++) {
                randomString += Convert.ToChar(Convert.ToInt32(Math.Floor(91 * random.NextDouble()))).ToString(CultureInfo.InvariantCulture);
            }

            return Encode(randomString);
        }

        public static String Encode(String str) {
            byte[] encbuff = System.Text.Encoding.UTF8.GetBytes(str);
            return Convert.ToBase64String(encbuff);
        }

        public static String Decode(String str) {
            byte[] decbuff = Convert.FromBase64String(str.Replace(" ", "+"));
            return System.Text.Encoding.UTF8.GetString(decbuff);
        }

        public static String EncodeStringArray(String[] strValue) {
            var encodedString = new StringBuilder();

            for (Int32 i = 0; i < strValue.Length; i++) {
                if (i > 0) {
                    encodedString.Append("|");
                    //strReturn += "|";
                }
                encodedString.Append(Encode(strValue[i]));
                //strReturn += Encode(strValue[i]);
            }

            return encodedString.ToString();
        }

        public byte[] GetBytes(String str) {
            var bytes = new byte[str.Length * sizeof (char)];
            System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
            return bytes;
        }

        public String GetString(byte[] bytes) {
            var chars = new char[bytes.Length / sizeof (char)];
            System.Buffer.BlockCopy(bytes, 0, chars, 0, bytes.Length);
            return new String(chars);
        }

        //Calling this method will make the settings window refresh with new data
        public void UpdateSettingPage() {
            DebugWrite("Updating Setting Page: " + (UtcDbTime() - _lastUpdateSettingRequest).TotalSeconds + " seconds since last update.", 4);
            _lastUpdateSettingRequest = UtcDbTime();
            SetExternalPluginSetting("AdKats", "UpdateSettings", "Update");
        }

        //Calls setVariable with the given parameters
        public void SetExternalPluginSetting(String pluginName, String settingName, String settingValue) {
            if (String.IsNullOrEmpty(pluginName) || String.IsNullOrEmpty(settingName) || settingValue == null) {
                ConsoleError("Required inputs null or empty in setExternalPluginSetting");
                return;
            }
            ExecuteCommand("procon.protected.plugins.setVariable", pluginName, settingName, settingValue);
        }

        //Credit to Micovery and PapaCharlie9 for modified Levenshtein Distance algorithm 
        public static Int32 LevenshteinDistance(String s, String t) {
            s = s.ToLower();
            t = t.ToLower();
            Int32 n = s.Length;
            Int32 m = t.Length;
            var d = new Int32[n + 1, m + 1];
            if (n == 0)
                return m;
            if (m == 0)
                return n;
            for (Int32 i = 0; i <= n; d[i, 0] = i++)
                ;
            for (Int32 j = 0; j <= m; d[0, j] = j++)
                ;
            for (Int32 i = 1; i <= n; i++)
                for (Int32 j = 1; j <= m; j++)
                    d[i, j] = Math.Min(Math.Min(d[i - 1, j] + 1, d[i, j - 1] + 0), d[i - 1, j - 1] + ((t[j - 1] == s[i - 1]) ? 0 : 1));
            return d[n, m];
        }

        //parses single word or number parameters out of a String until param count is reached
        private String[] ParseParameters(String message, Int32 maxParamCount) {
            //create list for parameters
            var parameters = new List<String>();
            if (message.Length > 0) {
                //Add all single word/number parameters
                String[] paramSplit = message.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                Int32 maxLoop = (paramSplit.Length < maxParamCount) ? (paramSplit.Length) : (maxParamCount);
                for (Int32 i = 0; i < maxLoop - 1; i++) {
                    DebugWrite("Param " + i + ": " + paramSplit[i], 6);
                    parameters.Add(paramSplit[i]);
                    message = message.TrimStart(paramSplit[i].ToCharArray()).Trim();
                }
                //Add final multi-word parameter
                parameters.Add(message);
            }
            DebugWrite("Num params: " + parameters.Count, 6);
            return parameters.ToArray();
        }

        public void JoinWith(Thread thread) {
            if (thread == null || !thread.IsAlive) {
                DebugWrite("Thread already finished.", 3);
                return;
            }
            DebugWrite("Waiting for ^b" + thread.Name + "^n to finish", 3);
            thread.Join();
        }

        public String FormatMessage(String msg, ConsoleMessageType type) {
            String prefix = "[^bAdKats^n] ";
            switch (type) {
                case ConsoleMessageType.Info:
                    prefix += "^1^bINFO^0^n: ";
                    break;
                case ConsoleMessageType.Warning:
                    prefix += "^1^bWARNING^0^n: ";
                    break;
                case ConsoleMessageType.Error:
                    prefix += "^1^bERROR^0^n: ";
                    break;
                case ConsoleMessageType.Success:
                    prefix += "^b^2SUCCESS^n^0: ";
                    break;
                case ConsoleMessageType.Exception:
                    prefix += "^1^bEXCEPTION^0^n: ";
                    break;
            }
            return prefix + msg;
        }

        public String BoldMessage(String msg) {
            return "^b" + msg + "^n";
        }

        public String ItalicMessage(String msg) {
            return "^i" + msg + "^n";
        }

        public String ColorMessageMaroon(String msg) {
            return "^1" + msg + "^0";
        }

        public String ColorMessageGreen(String msg) {
            return "^2" + msg + "^0";
        }

        public String ColorMessageOrange(String msg) {
            return "^3" + msg + "^0";
        }

        public String ColorMessageBlue(String msg) {
            return "^4" + msg + "^0";
        }

        public String ColorMessageBlueLight(String msg) {
            return "^5" + msg + "^0";
        }

        public String ColorMessageViolet(String msg) {
            return "^6" + msg + "^0";
        }

        public String ColorMessagePink(String msg) {
            return "^7" + msg + "^0";
        }

        public String ColorMessageRed(String msg) {
            return "^8" + msg + "^0";
        }

        public String ColorMessageGrey(String msg) {
            return "^9" + msg + "^0";
        }

        protected void LogThreadExit() {
            lock (_aliveThreads)
            {
                _aliveThreads.Remove(Thread.CurrentThread.ManagedThreadId);
                //ConsoleWarn("THREAD DEBUG: Stopping [" + Thread.CurrentThread.ManagedThreadId + ":'" + Thread.CurrentThread.Name + "']. " + _aliveThreads.Count + " threads running.");
            }
        }

        protected void StartAndLogThread(Thread aThread) {
            aThread.Start();
            lock (_aliveThreads) {
                if (!_aliveThreads.ContainsKey(aThread.ManagedThreadId)) {
                    _aliveThreads.Add(aThread.ManagedThreadId, aThread);
                    _threadMasterWaitHandle.WaitOne(100);
                    //ConsoleWarn("THREAD DEBUG: Starting [" + aThread.ManagedThreadId + ":'" + aThread.Name + "']. " + _aliveThreads.Count + " threads running.");
                }
            }
        }

        public String GenerateKickReason(AdKatsRecord record) {
            String sourceNameString = "[" + record.source_name + "]";

            //Create the full message
            String fullMessage = record.record_message + " " + sourceNameString;

            //Trim the kick message if necessary
            Int32 cutLength = fullMessage.Length - 80;
            if (cutLength > 0) {
                String cutReason = record.record_message.Substring(0, record.record_message.Length - cutLength);
                fullMessage = cutReason + " " + sourceNameString;
            }
            return fullMessage;
        }

        public String GenerateBanReason(AdKatsBan aBan) {
            String banDurationString;
            //If ban time > 1000 days just say perm
            TimeSpan remainingTime = GetRemainingBanTime(aBan);
            if (remainingTime.TotalDays > 1000) {
                banDurationString = "[perm]";
            }
            else {
                banDurationString = "[" + FormatTimeString(remainingTime, 2) + "]";
            }
            String sourceNameString = "[" + aBan.ban_record.source_name + "]";
            String banAppendString = ((_UseBanAppend) ? ("[" + _BanAppend + "]") : (""));

            //Create the full message
            String fullMessage = aBan.ban_record.record_message + " " + banDurationString + sourceNameString + banAppendString;

            //Trim the kick message if necessary
            Int32 cutLength = fullMessage.Length - 80;
            if (cutLength > 0) {
                String cutReason = aBan.ban_record.record_message.Substring(0, aBan.ban_record.record_message.Length - cutLength);
                fullMessage = cutReason + " " + banDurationString + sourceNameString + banAppendString;
            }
            return fullMessage;
        }

        public void CheckForPluginUpdates(Boolean manual) {
            try
            {
                if ((_pluginVersionStatus == VersionStatus.OutdatedBuild && !_automaticUpdatesDisabled && !_pluginUpdatePatched) || 
                    (_isTestingAuthorized) || 
                    (!String.IsNullOrEmpty(_AdKatsLRTExtensionToken)) || 
                    manual)
                {
                    if (_aliveThreads.Values.Any(aThread => aThread.Name == "PluginUpdater"))
                    {
                        if (_pluginUpdateCaller != null) {
                            SendMessageToSource(_pluginUpdateCaller, "Update already in progress.");
                        }
                        _pluginUpdateCaller = null;
                        LogThreadExit();
                        return;
                    }
                    var pluginUpdater = new Thread(new ThreadStart(delegate
                    {
                        try
                        {
                            Thread.CurrentThread.Name = "PluginUpdater";
                            _pluginUpdateProgress = "Started";
                            if (_pluginUpdateCaller != null)
                            {
                                SendMessageToSource(_pluginUpdateCaller, "Preparing to download plugin update.");
                            }
                            if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                                ConsoleInfo("Preparing to download plugin update to version " + _latestPluginVersion);
                            String pluginSource = null;
                            using (var client = new WebClient())
                            {
                                try
                                {
                                    const string stableURL = "https://raw.githubusercontent.com/AdKats/AdKats/master/AdKats.cs";
                                    const string testURL = "https://raw.githubusercontent.com/AdKats/AdKats/test/AdKats.cs";
                                    if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                                    {
                                        pluginSource = client.DownloadString(stableURL);
                                    }
                                    else
                                    {
                                        pluginSource = client.DownloadString(testURL);
                                    }
                                }
                                catch (Exception e)
                                {
                                    if (_pluginUpdateCaller != null)
                                    {
                                        SendMessageToSource(_pluginUpdateCaller, "Unable to download plugin update.");
                                    }
                                    if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                                        ConsoleError("Unable to download plugin update to version " + _latestPluginVersion);
                                    _pluginUpdateCaller = null;
                                    LogThreadExit();
                                    return;
                                }
                            }
                            if (String.IsNullOrEmpty(pluginSource))
                            {
                                if (_pluginUpdateCaller != null)
                                {
                                    SendMessageToSource(_pluginUpdateCaller, "Downloaded plugin source was empty. Cannot update.");
                                }
                                if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                                    ConsoleError("Downloaded plugin source was empty. Cannot update to version " + _latestPluginVersion);
                                _pluginUpdateCaller = null;
                                LogThreadExit();
                                return;
                            }
                            _pluginUpdateProgress = "Downloaded";
                            if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                            {
                                ConsoleSuccess("Updated plugin source downloaded.");
                                ConsoleInfo("Preparing test compile on updated plugin source.");
                            }
                            String pluginFileName = "AdKats.cs";
                            String dllPath = Directory.GetParent(Assembly.GetExecutingAssembly().Location).FullName;
                            String pluginPath = Path.Combine(dllPath.Trim(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar }), pluginFileName);
                            var compileResults = CompilePluginSource(pluginSource);
                            if (compileResults.Errors.HasErrors)
                            {
                                foreach (CompilerError errComp in compileResults.Errors)
                                {
                                    if (String.Compare(errComp.ErrorNumber, "CS0016", StringComparison.Ordinal) != 0 && errComp.IsWarning == false)
                                    {
                                        if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                                            ConsoleError(String.Format("\t^1{0} (Line: {1}, C: {2}) {3}: {4}", new object[] { pluginFileName, errComp.Line, errComp.Column, errComp.ErrorNumber, errComp.ErrorText }));
                                    }
                                }
                                if (_pluginUpdateCaller != null)
                                {
                                    SendMessageToSource(_pluginUpdateCaller, "Updated plugin source could not compile. Cannot update.");
                                }
                                if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                                    ConsoleError("Updated plugin source could not compile. Cannot update to version " + _latestPluginVersion);
                                _pluginUpdateCaller = null;
                                LogThreadExit();
                                return;
                            }
                            else
                            {
                                if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                                    ConsoleSuccess("Plugin update compiled successfully.");
                            }
                            _pluginUpdateProgress = "Compiled";
                            if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                                ConsoleInfo("Preparing to update source file on disk.");
                            Int64 originalSizeKb = new FileInfo(pluginPath).Length / 1024;
                            Int64 patchedSizeKB = 0;
                            Boolean fileWriteFailed = false;
                            Int32 attempts = 0;
                            do {
                                using (FileStream stream = File.Open(pluginPath, FileMode.Create)) {
                                    if (!stream.CanWrite)
                                    {
                                        if (_pluginUpdateCaller != null)
                                        {
                                            SendMessageToSource(_pluginUpdateCaller, "Cannot write updates to source file. Cannot update.");
                                        }
                                        ConsoleError("Cannot write updates to source file. Cannot update.");
                                        _pluginUpdateCaller = null;
                                        LogThreadExit();
                                        return;
                                    }
                                    Byte[] info = new UTF8Encoding(true).GetBytes(pluginSource);
                                    stream.Write(info, 0, info.Length);
                                }
                                patchedSizeKB = new FileInfo(pluginPath).Length / 1024;
                                //There is no way the valid plugin can be less than 1 Kb
                                if (patchedSizeKB < 1)
                                {
                                    if (_pluginUpdateCaller != null)
                                    {
                                        SendMessageToSource(_pluginUpdateCaller, "Write failure on plugin update. Attempting write again.");
                                    }
                                    ConsoleError("Write failure on plugin update. Attempting write again.");
                                    Thread.Sleep(500);
                                    fileWriteFailed = true;
                                }
                                else {
                                    fileWriteFailed = false;
                                }
                                if (++attempts > 5)
                                {
                                    if (_pluginUpdateCaller != null)
                                    {
                                        SendMessageToSource(_pluginUpdateCaller, "Constant failure to write plugin update to file. Cannot update.");
                                    }
                                    ConsoleError("Constant failure to write plugin update to file. Cannot update.");
                                    _pluginUpdateCaller = null;
                                    LogThreadExit();
                                    return;
                                }
                            } while (fileWriteFailed); 
                            String patchedVersion = ExtractString(pluginSource, "version_code");
                            if (!String.IsNullOrEmpty(patchedVersion)) {
                                String trimmedPatchedVersion = patchedVersion.Replace(".", "");
                                Int32 patchedVersionInt = Int32.Parse(trimmedPatchedVersion);
                                if (patchedVersionInt >= _currentPluginVersionInt) {
                                    //Patched version is newer than current version
                                    if (patchedVersionInt > _pluginPatchedVersionInt && _pluginUpdatePatched)
                                    {
                                        if (_pluginUpdateCaller != null)
                                        {
                                            SendMessageToSource(_pluginUpdateCaller, "Previous update " + _pluginPatchedVersion + " overwritten by newer patch " + patchedVersion + ", restart procon to run this version. Plugin size " + patchedSizeKB + "KB");
                                        }
                                        //Patched version is newer than an already patched version
                                        ConsoleSuccess("Previous update " + _pluginPatchedVersion + " overwritten by newer patch " + patchedVersion + ", restart procon to run this version. Plugin size " + patchedSizeKB + "KB");
                                    }
                                    else if (!_pluginUpdatePatched && patchedVersionInt > _currentPluginVersionInt) 
                                    {
                                        if (_pluginUpdateCaller != null) {
                                            SendMessageToSource(_pluginUpdateCaller, "Plugin updated to version " + patchedVersion + ", restart procon to run this version. Plugin size " + patchedSizeKB + "KB");
                                        }
                                        //User not notified of patch yet
                                        ConsoleSuccess("Plugin updated to version " + patchedVersion + ", restart procon to run this version. Plugin size " + patchedSizeKB + "KB");
                                        ConsoleSuccess("Updated plugin file located at: " + pluginPath);
                                    }
                                    else 
                                    {
                                        if (_pluginUpdateCaller != null)
                                        {
                                            SendMessageToSource(_pluginUpdateCaller, "Plugin updated to same version, " + patchedVersion + ". Plugin size " + patchedSizeKB + "KB");
                                        }
                                    }
                                }
                                else if (!_pluginUpdatePatched)
                                {
                                    if (_pluginUpdateCaller != null)
                                    {
                                        SendMessageToSource(_pluginUpdateCaller, "Plugin reverted to previous version " + patchedVersion + ", restart procon to run this version. Plugin size " + patchedSizeKB + "KB");
                                    }
                                    //Patched version is older than current version
                                    ConsoleWarn("Plugin reverted to previous version " + patchedVersion + ", restart procon to run this version. Plugin size " + patchedSizeKB + "KB");
                                }
                                _pluginPatchedVersion = patchedVersion;
                                _pluginPatchedVersionInt = patchedVersionInt;
                            }
                            else
                            {
                                if (_pluginUpdateCaller != null)
                                {
                                    SendMessageToSource(_pluginUpdateCaller, "Plugin update patched, but its version could not be extracted. Plugin size " + patchedSizeKB + "KB");
                                }
                                ConsoleWarn("Plugin update patched, but its version could not be extracted. Plugin size " + patchedSizeKB + "KB");
                            }
                            _pluginUpdateProgress = "Patched";
                            _pluginUpdatePatched = true;

                            //Extensions
                            //1 - AdKatsLRT - Private Extension - Token Required
                            if (!String.IsNullOrEmpty(_AdKatsLRTExtensionToken)) {
                                String extensionSource;
                                using (var client = new WebClient())
                                {
                                    try
                                    {
                                        extensionSource = client.DownloadString("https://raw.githubusercontent.com/AdKats/AdKats-LRT/master/AdKatsLRT.cs?token=" + _AdKatsLRTExtensionToken);
                                    }
                                    catch (Exception e)
                                    {
                                        if (_pluginUpdateCaller != null)
                                        {
                                            SendMessageToSource(_pluginUpdateCaller, "Unable to install/update AdKatsLRT Extension. Connection error, or invalid token.");
                                        }
                                        ConsoleError("Unable to install/update AdKatsLRT Extension. Connection error, or invalid token.");
                                        _pluginUpdateCaller = null;
                                        LogThreadExit();
                                        return;
                                    }
                                }
                                if (String.IsNullOrEmpty(extensionSource))
                                {
                                    if (_pluginUpdateCaller != null)
                                    {
                                        SendMessageToSource(_pluginUpdateCaller, "Downloaded AdKatsLRT Extension source was empty. Unable to install/update AdKatsLRT Extension.");
                                    }
                                    ConsoleError("Downloaded AdKatsLRT Extension source was empty. Unable to install/update AdKatsLRT Extension.");
                                    _pluginUpdateCaller = null;
                                    LogThreadExit();
                                    return;
                                }
                                String extensionFileName = "AdKatsLRT.cs";
                                String extensionPath = Path.Combine(dllPath.Trim(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar }), extensionFileName);
                                var extensionCompileResults = CompilePluginSource(extensionSource);
                                if (extensionCompileResults.Errors.HasErrors)
                                {
                                    foreach (CompilerError errComp in extensionCompileResults.Errors)
                                    {
                                        if (String.Compare(errComp.ErrorNumber, "CS0016", StringComparison.Ordinal) != 0 && errComp.IsWarning == false)
                                        {
                                            if (_pluginVersionStatus == VersionStatus.OutdatedBuild)
                                                ConsoleError(String.Format("\t^1{0} (Line: {1}, C: {2}) {3}: {4}", new object[] { extensionFileName, errComp.Line, errComp.Column, errComp.ErrorNumber, errComp.ErrorText }));
                                        }
                                    }
                                    if (_pluginUpdateCaller != null)
                                    {
                                        SendMessageToSource(_pluginUpdateCaller, "Updated AdKatsLRT Extension source could not compile. Unable to install/update AdKatsLRT Extension.");
                                    }
                                    ConsoleError("Updated AdKatsLRT Extension source could not compile. Unable to install/update AdKatsLRT Extension.");
                                    _pluginUpdateCaller = null;
                                    LogThreadExit();
                                    return;
                                }
                                Int64 patchedExtensionSizeKb = 0;
                                Boolean extensionFileWriteFailed = false;
                                Int32 extensionWriteAttempts = 0;
                                do
                                {
                                    using (FileStream stream = File.Open(extensionPath, FileMode.Create))
                                    {
                                        if (!stream.CanWrite)
                                        {
                                            if (_pluginUpdateCaller != null)
                                            {
                                                SendMessageToSource(_pluginUpdateCaller, "Cannot write updates to AdKatsLRT Extension source file. Unable to install/update AdKatsLRT Extension.");
                                            }
                                            ConsoleError("Cannot write updates to AdKatsLRT Extension source file. Unable to install/update AdKatsLRT Extension.");
                                            _pluginUpdateCaller = null;
                                            LogThreadExit();
                                            return;
                                        }
                                        Byte[] info = new UTF8Encoding(true).GetBytes(extensionSource);
                                        stream.Write(info, 0, info.Length);
                                    }
                                    patchedExtensionSizeKb = new FileInfo(extensionPath).Length / 1024;
                                    //There is no way the valid extension can be less than 1 Kb
                                    if (patchedExtensionSizeKb < 1)
                                    {
                                        if (_pluginUpdateCaller != null)
                                        {
                                            SendMessageToSource(_pluginUpdateCaller, "Write failure on AdKatsLRT Extension update. Attempting write again.");
                                        }
                                        ConsoleError("Write failure on AdKatsLRT Extension update. Attempting write again.");
                                        extensionFileWriteFailed = true;
                                    }
                                    else
                                    {
                                        extensionFileWriteFailed = false;
                                    }
                                    if (++extensionWriteAttempts > 5)
                                    {
                                        if (_pluginUpdateCaller != null)
                                        {
                                            SendMessageToSource(_pluginUpdateCaller, "Constant failure to write AdKatsLRT Extension update to file. Unable to install/update AdKatsLRT Extension.");
                                        }
                                        ConsoleError("Constant failure to write AdKatsLRT Extension update to file. Unable to install/update AdKatsLRT Extension.");
                                        _pluginUpdateCaller = null;
                                        LogThreadExit();
                                        return;
                                    }
                                } while (extensionFileWriteFailed);
                                if (_pluginUpdateCaller != null)
                                {
                                    SendMessageToSource(_pluginUpdateCaller, "AdKatsLRT Extension installed/updated. Extension size " + patchedExtensionSizeKb + "KB");
                                }
                                ConsoleSuccess("AdKatsLRT Extension installed/updated. Extension size " + patchedExtensionSizeKb + "KB");
                            }
                        }
                        catch (Exception e) {
                            HandleException(new AdKatsException("Error while running update thread.", e));
                        }
                        _pluginUpdateCaller = null;
                        LogThreadExit();
                    }));
                    StartAndLogThread(pluginUpdater);
                }
            }
            catch (Exception e) {
                HandleException(new AdKatsException("Error while updating plugin source to latest version", e));
            }
        }

        public void ProconChatWrite(String msg) {
            msg = msg.Replace(System.Environment.NewLine, String.Empty);
            ExecuteCommand("procon.protected.chat.write", "AdKats > " + msg);
            if (_slowmo) {
                _threadMasterWaitHandle.WaitOne(1000);
            }
        }

        public void ConsoleWrite(String msg, ConsoleMessageType type) {
            ExecuteCommand("procon.protected.pluginconsole.write", FormatMessage(msg, type));
            if (_slowmo)
            {
                _threadMasterWaitHandle.WaitOne(1000);
            }
        }

        public void ConsoleWrite(String msg) {
            ConsoleWrite(msg, ConsoleMessageType.Normal);
        }

        public void ConsoleInfo(String msg) {
            ConsoleWrite(msg, ConsoleMessageType.Info);
        }

        public void ConsoleWarn(String msg) {
            ConsoleWrite(msg, ConsoleMessageType.Warning);
        }

        public void ConsoleError(String msg) {
            ConsoleWrite(msg, ConsoleMessageType.Error);
        }

        public void ConsoleSuccess(String msg) {
            ConsoleWrite(msg, ConsoleMessageType.Success);
        }

        public void DebugWrite(String msg, Int32 level) {
            if (_debugLevel >= level) {
                ConsoleWrite(msg, ConsoleMessageType.Normal);
            }
        }

        public void PrintPreparedCommand(MySqlCommand cmd) {
            String query = cmd.Parameters.Cast<MySqlParameter>().Aggregate(cmd.CommandText, (current, p) => current.Replace(p.ParameterName, (p.Value != null)?(p.Value.ToString()):("NULL")));
            ConsoleWrite(query);
        }

        public DateTime DateTimeFromEpochSeconds(Double epochSeconds)
        {
            var epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
            return epoch.AddSeconds(epochSeconds);
        }

        public AdKatsException HandleException(AdKatsException aException) {
            //If it's null or AdKats isn't enabled, just return
            if (aException == null) {
                ConsoleError("Attempted to handle exception when none was given.");
                return null;
            }
            if (!_pluginEnabled) {
                return aException;
            }
            _slowmo = AdKats.SlowMoOnException;
            String prefix = "Line ";
            if (aException.InternalException != null) {
                Int64 impericalLineNumber = (new StackTrace(aException.InternalException, true)).GetFrame(0).GetFileLineNumber();
                Int64 parsedLineNumber = 0;
                Int64.TryParse(aException.InternalException.ToString().Split(' ').Last(), out parsedLineNumber);
                if (impericalLineNumber != 0) {
                    prefix += impericalLineNumber;
                }
                else if (parsedLineNumber != 0) {
                    prefix += parsedLineNumber;
                }
                else {
                    prefix += "Unknown";
                }
                prefix += "-" + _currentPluginVersionInt + ": ";
            }
            //Check if the exception attributes to the database
            if (aException.InternalException != null && 
                (aException.InternalException.GetType() == typeof (System.TimeoutException) ||
                aException.InternalException.ToString().Contains("Unable to connect to any of the specified MySQL hosts") || 
                aException.InternalException.ToString().Contains("Reading from the stream has failed.") || 
                aException.InternalException.ToString().Contains("Too many connections") || 
                aException.InternalException.ToString().Contains("Timeout expired") || 
                aException.InternalException.ToString().Contains("An existing connection was forcibly closed by the remote host") || 
                aException.InternalException.ToString().Contains("Unable to read data") || 
                aException.InternalException.ToString().Contains("Lock wait timeout exceeded"))) {
                HandleDatabaseConnectionInteruption();
            }
            else if(aException.InternalException != null && 
                    aException.InternalException.ToString().Contains("Deadlock"))
            {
                //Ignore. Deadlock cannot be avoided. Request already retried.
            }
            else {
                ConsoleWrite(prefix + aException, ConsoleMessageType.Exception);
                if (_CommandKeyDictionary.ContainsKey("adkats_exception"))
                {
                    //Create the Exception record
                    var record = new AdKatsRecord
                    {
                        record_source = AdKatsRecord.Sources.InternalAutomated,
                        isDebug = true,
                        server_id = _serverInfo.ServerID,
                        command_type = GetCommandByKey("adkats_exception"),
                        command_numeric = _currentPluginVersionInt,
                        target_name = "AdKats",
                        target_player = null,
                        source_name = "AdKats",
                        record_message = prefix + aException.ToString()
                    };
                    //Process the record
                    QueueRecordForProcessing(record);
                }
            }
            return aException;
        }

        public MySqlDataReader SafeExecuteReader(MySqlCommand command)
        {
            Stopwatch watch = new Stopwatch();
            watch.Start();
            try
            {
                var reader = command.ExecuteReader();
                watch.Stop();
                if (watch.Elapsed.TotalSeconds > 4 && watch.Elapsed.TotalSeconds > (50 * _DatabaseReadAverageDuration) && _firstPlayerListComplete) 
                {
                    HandleDatabaseConnectionInteruption();
                }
                if (_DatabaseReaderDurations.Count < 25000)
                {
                    lock (_DatabaseReaderDurations)
                    {
                        _DatabaseReaderDurations.Add(watch.Elapsed.TotalSeconds);
                        _DatabaseReadAverageDuration = _DatabaseReaderDurations.Average();
                    }
                }
                return reader;
            }
            catch (Exception e)
            {
                try
                {
                    //If the failure was due to deadlock, wait a short duration and issue again
                    if (e.ToString().ToLower().Contains("deadlock"))
                    {
                        Thread.Sleep(250);
                        //If any further errors thrown, just throw them
                        watch.Reset();
                        watch.Start();
                        var reader = command.ExecuteReader();
                        watch.Stop();
                        if (watch.Elapsed.TotalSeconds > 4 && watch.Elapsed.TotalSeconds > (50 * _DatabaseReadAverageDuration) && _firstPlayerListComplete)
                        {
                            HandleDatabaseConnectionInteruption();
                        }
                        if (_DatabaseReaderDurations.Count < 25000)
                        {
                            lock (_DatabaseReaderDurations)
                            {
                                _DatabaseReaderDurations.Add(watch.Elapsed.TotalSeconds);
                                _DatabaseReadAverageDuration = _DatabaseReaderDurations.Average();
                            }
                        }
                        return reader;
                    }
                    throw e;
                }
                catch (Exception e2) 
                {
                    e = e2;
                    if ((e2.GetType() == typeof(System.TimeoutException) ||
                        e2.ToString().Contains("Unable to connect to any of the specified MySQL hosts") ||
                        e2.ToString().Contains("Reading from the stream has failed.") ||
                        e2.ToString().Contains("Too many connections") ||
                        e2.ToString().Contains("Timeout expired") ||
                        e2.ToString().Contains("An existing connection was forcibly closed by the remote host") ||
                        e2.ToString().Contains("Unable to read data") ||
                        e2.ToString().Contains("Lock wait timeout exceeded")))
                    {
                        ConsoleInfo("Average Read: " + Math.Round(_DatabaseReadAverageDuration, 3) + "s " + _DatabaseReaderDurations.Count + " | Average Write: " + Math.Round(_DatabaseWriteAverageDuration, 3) + "s " + _DatabaseNonQueryDurations.Count);
                        PrintPreparedCommand(command);
                    }
                }
                throw e;
            }
        }

        public Int32 SafeExecuteNonQuery(MySqlCommand command)
        {
            Stopwatch watch = new Stopwatch();
            watch.Start();
            try
            {
                var modified = command.ExecuteNonQuery();
                watch.Stop();
                if (watch.Elapsed.TotalSeconds > 4 && watch.Elapsed.TotalSeconds > (50 * _DatabaseWriteAverageDuration) && _firstPlayerListComplete)
                {
                    HandleDatabaseConnectionInteruption();
                }
                if (_DatabaseNonQueryDurations.Count < 25000)
                {
                    lock (_DatabaseNonQueryDurations)
                    {
                        _DatabaseNonQueryDurations.Add(watch.Elapsed.TotalSeconds);
                        _DatabaseWriteAverageDuration = _DatabaseNonQueryDurations.Average();
                    }
                }
                return modified;
            }
            catch (Exception e)
            {
                try
                {
                    //If the failure was due to deadlock, wait a short duration and issue again
                    if (e.ToString().ToLower().Contains("deadlock"))
                    {
                        Thread.Sleep(250);
                        //If any further errors thrown, just throw them
                        watch.Reset();
                        watch.Start();
                        var modified = command.ExecuteNonQuery();
                        watch.Stop();
                        if (watch.Elapsed.TotalSeconds > 4 && watch.Elapsed.TotalSeconds > (50 * _DatabaseWriteAverageDuration) && _firstPlayerListComplete)
                        {
                            HandleDatabaseConnectionInteruption();
                        }
                        if (_DatabaseNonQueryDurations.Count < 25000)
                        {
                            lock (_DatabaseNonQueryDurations)
                            {
                                _DatabaseNonQueryDurations.Add(watch.Elapsed.TotalSeconds);
                                _DatabaseWriteAverageDuration = _DatabaseNonQueryDurations.Average();
                            }
                        }
                        return modified;
                    }
                    throw e;
                }
                catch (Exception e2)
                {
                    e = e2;
                    if ((e2.GetType() == typeof(System.TimeoutException) ||
                        e2.ToString().Contains("Unable to connect to any of the specified MySQL hosts") ||
                        e2.ToString().Contains("Reading from the stream has failed.") ||
                        e2.ToString().Contains("Too many connections") ||
                        e2.ToString().Contains("Timeout expired") ||
                        e2.ToString().Contains("An existing connection was forcibly closed by the remote host") ||
                        e2.ToString().Contains("Unable to read data") ||
                        e2.ToString().Contains("Lock wait timeout exceeded")))
                    {
                        ConsoleInfo("Average Read: " + Math.Round(_DatabaseReadAverageDuration, 3) + "s " + _DatabaseReaderDurations.Count + " | Average Write: " + Math.Round(_DatabaseWriteAverageDuration, 3) + "s " + _DatabaseNonQueryDurations.Count);
                        PrintPreparedCommand(command);
                    }
                }
                throw e;
            }
        }

        public void HandleDatabaseConnectionInteruption() {
            //Only handle these errors if all threads are already functioning normally
            if (_firstPlayerListComplete) {
                if (_databaseTimeouts == 0) {
                    _lastDatabaseTimeout = UtcDbTime();
                }
                ++_databaseTimeouts;
                ConsoleWarn("Database connection issue detected. Trigger " + _databaseTimeouts + "/" + DatabaseTimeoutThreshold + ".");
                //Check for critical state (timeouts > threshold, and last issue less than 1 minute ago)
                if ((UtcDbTime() - _lastDatabaseTimeout).TotalSeconds < 60) {
                    if (_databaseTimeouts >= DatabaseTimeoutThreshold) {
                        try {
                            //If the handler is already alive, return
                            if (_DisconnectHandlingThread != null && _DisconnectHandlingThread.IsAlive) {
                                DebugWrite("Attempted to start disconnect handling thread when it was already running.", 2);
                                return;
                            }
                            //Create a new thread to handle the disconnect orchestration
                            _DisconnectHandlingThread = new Thread(new ThreadStart(delegate {
                                try {
                                    Thread.CurrentThread.Name = "DisconnectHandling";
                                    //Log the time of critical disconnect
                                    DateTime disconnectTime = DateTime.Now;
                                    var disconnectTimer = new Stopwatch();
                                    disconnectTimer.Start();
                                    //Immediately disable Stat Logger
                                    ConsoleError("Database connection in critical failure state. Disabling Stat Logger and putting AdKats in Backup Mode.");
                                    _databaseConnectionCriticalState = true;
                                    ExecuteCommand("procon.protected.plugins.enable", "CChatGUIDStatsLoggerBF3", "False");
                                    ExecuteCommand("procon.protected.plugins.enable", "CChatGUIDStatsLogger", "False");
                                    //Set resolved
                                    Boolean restored = false;
                                    //Enter loop to check for database reconnection
                                    do {
                                        //If someone manually disables AdKats, exit everything
                                        if (!_pluginEnabled) {
                                            return;
                                        }
                                        //Wait 15 seconds to retry
                                        _threadMasterWaitHandle.WaitOne(15000);
                                        //Check if the connection has been restored
                                        restored = DebugDatabaseConnectionActive();
                                        if (!restored) {
                                            _databaseSuccess = 0;
                                            //Inform the user database still not connectable
                                            ConsoleError("Database still not accessible. (" + String.Format("{0:0.00}", disconnectTimer.Elapsed.TotalMinutes) + " minutes since critical disconnect at " + disconnectTime.ToShortTimeString() + ".");
                                        }
                                        else {
                                            _databaseSuccess++;
                                            ConsoleInfo("Database connection appears restored, but waiting " + (DatabaseSuccessThreshold - _databaseSuccess) + " more successful connections to restore normal operation.");
                                        }
                                    } while (_databaseSuccess < DatabaseSuccessThreshold);
                                    //Connection has been restored, inform the user
                                    disconnectTimer.Stop();
                                    ConsoleSuccess("Database connection restored, re-enabling Stat Logger and returning AdKats to Normal Mode.");
                                    //Reset timeout counts
                                    _databaseSuccess = 0;
                                    _databaseTimeouts = 0;
                                    //re-enable AdKats and Stat Logger
                                    _databaseConnectionCriticalState = false;
                                    ExecuteCommand("procon.protected.plugins.enable", "CChatGUIDStatsLoggerBF3", "True");
                                    ExecuteCommand("procon.protected.plugins.enable", "CChatGUIDStatsLogger", "True");

                                    //Clear the player dinctionary, causing all players to be fetched from the database again
                                    lock (_PlayerDictionary) {
                                        _PlayerDictionary.Clear();
                                    }

                                    //Create the Exception record
                                    var record = new AdKatsRecord {
                                        record_source = AdKatsRecord.Sources.InternalAutomated,
                                        isDebug = true,
                                        server_id = _serverInfo.ServerID,
                                        command_type = GetCommandByKey("adkats_exception"),
                                        command_numeric = 0,
                                        target_name = "Database",
                                        target_player = null,
                                        source_name = "AdKats",
                                        record_message = "Critical Database Disconnect Handled (" + String.Format("{0:0.00}", disconnectTimer.Elapsed.TotalMinutes) + " minutes). AdKats on server " + _serverInfo.ServerID + " functioning normally again."
                                    };
                                    //Process the record
                                    QueueRecordForProcessing(record);
                                }
                                catch (Exception) {
                                    ConsoleError("Error handling database disconnect.");
                                }
                                ConsoleSuccess("Exiting Critical Disconnect Handler.");
                                LogThreadExit();
                            }));

                            //Start the thread
                            StartAndLogThread(_DisconnectHandlingThread);
                        }
                        catch (Exception) {
                            ConsoleError("Error while initializing disconnect handling thread.");
                        }
                    }
                }
                else {
                    //Reset the current timout count
                    _databaseTimeouts = 0;
                }
                _lastDatabaseTimeout = UtcDbTime();
            }
            else {
                DebugWrite("Attempted to handle database timeout when threads not running.", 2);
            }
        }

        public void StartRoundTimer() {
            if (_pluginEnabled && _threadsReady) {
                try {
                    //If the thread is still alive, inform the user and return
                    if (_RoundTimerThread != null && _RoundTimerThread.IsAlive) {
                        ConsoleError("Tried to enable a round timer while one was still active.");
                        return;
                    }
                    _RoundTimerThread = new Thread(new ThreadStart(delegate {
                        try {
                            Thread.CurrentThread.Name = "RoundTimer";
                            DebugWrite("starting round timer", 2);
                            _threadMasterWaitHandle.WaitOne(5000);
                            var maxRoundTimeSeconds = (Int32) (_maxRoundTimeMinutes * 60);
                            for (Int32 secondsRemaining = maxRoundTimeSeconds; secondsRemaining > 0; secondsRemaining--) {
                                if (_roundState == RoundState.Ended || !_pluginEnabled || !_threadsReady) {
                                    return;
                                }
                                if (secondsRemaining == maxRoundTimeSeconds - 60 && secondsRemaining > 60) {
                                    AdminTellMessage("Round will end automatically in ~" + (Int32) (secondsRemaining / 60.0) + " minutes.");
                                    DebugWrite("Round will end automatically in ~" + (Int32) (secondsRemaining / 60.0) + " minutes.", 3);
                                }
                                else if (secondsRemaining == (maxRoundTimeSeconds / 2) && secondsRemaining > 60) {
                                    AdminTellMessage("Round will end automatically in ~" + (Int32) (secondsRemaining / 60.0) + " minutes.");
                                    DebugWrite("Round will end automatically in ~" + (Int32) (secondsRemaining / 60.0) + " minutes.", 3);
                                }
                                else if (secondsRemaining == 30) {
                                    AdminTellMessage("Round ends in 30 seconds. (Current winning team will win)");
                                    DebugWrite("Round ends in 30 seconds. (Current winning team will win)", 3);
                                }
                                else if (secondsRemaining == 20) {
                                    AdminTellMessage("Round ends in 20 seconds. (Current winning team will win)");
                                    DebugWrite("Round ends in 20 seconds. (Current winning team will win)", 3);
                                }
                                else if (secondsRemaining <= 10) {
                                    AdminSayMessage("Round ends in..." + secondsRemaining);
                                    DebugWrite("Round ends in..." + secondsRemaining, 3);
                                }
                                //Sleep for 1 second
                                _threadMasterWaitHandle.WaitOne(1000);
                            }
                            if (_teamDictionary[1].TeamTicketCount < _teamDictionary[2].TeamTicketCount) {
                                ExecuteCommand("procon.protected.send", "mapList.endRound", "2");
                                DebugWrite("Ended Round (2)", 4);
                            }
                            else {
                                ExecuteCommand("procon.protected.send", "mapList.endRound", "1");
                                DebugWrite("Ended Round (1)", 4);
                            }
                        }
                        catch (Exception e) {
                            HandleException(new AdKatsException("Error in round timer thread.", e));
                        }
                        DebugWrite("Exiting round timer.", 2);
                        LogThreadExit();
                    }));

                    //Start the thread
                    StartAndLogThread(_RoundTimerThread);
                }
                catch (Exception e) {
                    HandleException(new AdKatsException("Error starting round timer thread.", e));
                }
            }
        }

        private void DoBattlelogWait()
        {
            if ((UtcDbTime() - _LastBattlelogAction) < _BattlelogWaitDuration)
            {
                Thread.Sleep(_BattlelogWaitDuration - (UtcDbTime() - _LastBattlelogAction));
            }
            _LastBattlelogAction = UtcDbTime();
        }

        private void DoIPAPIWait()
        {
            if ((UtcDbTime() - _LastIPAPIAction) < _IPAPIWaitDuration)
            {
                Thread.Sleep(_IPAPIWaitDuration - (UtcDbTime() - _LastIPAPIAction));
            }
            _LastIPAPIAction = UtcDbTime();
        }

        private void DoGoogleWait()
        {
            if ((UtcDbTime() - _LastGoogleAction) < _GoogleWaitDuration)
            {
                Thread.Sleep(_GoogleWaitDuration - (UtcDbTime() - _LastGoogleAction));
            }
            _LastGoogleAction = UtcDbTime();
        }

        private void FetchIPLocation(AdKatsPlayer aPlayer) {
            if ( String.IsNullOrEmpty(aPlayer.player_ip) || 
                (aPlayer.location != null && aPlayer.location.status == "success" && aPlayer.player_ip == aPlayer.location.IP))
            {
                return;
            }
            var loc = new IPAPILocation(aPlayer.player_ip);
            using (var client = new WebClient()) {
                try {
                    Hashtable response = null;
                    try {
                        DoIPAPIWait();
                        response = (Hashtable)JSON.JsonDecode(client.DownloadString("http://ip-api.com/json/" + aPlayer.player_ip));
                    }
                    catch (Exception e) {
                        ConsoleError("ip-api failed to respond with player location information, your layer may be IP banned. (" + e.Message + ")");
                        return;
                    }
                    loc.status = (String) response["status"];
                    if (loc.status == "fail") {
                        loc.message = (String) response["message"];
                        aPlayer.location = loc;
                        return;
                    }
                    if (loc.status == "success") {
                        loc.country = (String) response["country"];
                        loc.countryCode = (String) response["countryCode"];
                        loc.region = (String) response["region"];
                        loc.regionName = (String) response["regionName"];
                        loc.city = (String) response["city"];
                        loc.zip = (String)response["zip"];
                        loc.lat = (Double)response["lat"];
                        loc.lon = (Double)response["lon"];
                        loc.timezone = (String) response["timezone"];
                        loc.isp = (String) response["isp"];
                        loc.org = (String) response["org"];
                        loc.query = (String) response["query"];
                        aPlayer.location = loc;
                    }
                }
                catch (Exception e)
                {
                    HandleException(new AdKatsException("Error while parsing IP response information.", e));
                }
            }
        }

        public CompilerResults CompilePluginSource(String pluginSource) {
            String procon_path = Directory.GetParent(Application.ExecutablePath).FullName;
            String pluginDirectory = Path.Combine(procon_path, Path.Combine("Plugins", _gameVersion.ToString()));
            var providerOptions = new Dictionary<String, String>();
            providerOptions.Add("CompilerVersion", "v3.5");
            var cSharpCodeProvider = new CSharpCodeProvider(providerOptions);
            var compilerParameters = new CompilerParameters();
            compilerParameters.ReferencedAssemblies.Add("System.dll");
            compilerParameters.ReferencedAssemblies.Add("System.Core.dll");
            compilerParameters.ReferencedAssemblies.Add("System.Data.dll");
            compilerParameters.ReferencedAssemblies.Add("System.Windows.Forms.dll");
            compilerParameters.ReferencedAssemblies.Add("System.Xml.dll");
            compilerParameters.ReferencedAssemblies.Add("MySql.Data.dll");
            compilerParameters.ReferencedAssemblies.Add("PRoCon.Core.dll");
            compilerParameters.GenerateInMemory = true;
            compilerParameters.IncludeDebugInformation = false;
            compilerParameters.TempFiles = new TempFileCollection(pluginDirectory);
            return cSharpCodeProvider.CompileAssemblyFromSource(compilerParameters, pluginSource);
        }

        public class AdKatsWeaponName {
            public GameVersion weapon_game;
            public String readable_short;
            public String readable_long;
        }

        public class AdKatsBan {
            //Current exception state of the ban
            public DateTime ban_endTime;
            public Boolean ban_enforceGUID = true;
            public Boolean ban_enforceIP = false;
            public Boolean ban_enforceName = false;
            public AdKatsException ban_exception = null;

            public Int64 ban_id = -1;
            public String ban_notes = null;
            public AdKatsRecord ban_record = null;
            public DateTime ban_startTime;
            public String ban_status = "Active";
            public String ban_sync = null;
            public Int64 player_id = -1;
            //startTime and endTime are not set by AdKats, they are set in the database.
            //startTime and endTime will be valid only when bans are fetched from the database
        }

        public class AdKatsCommand {
            //Active option
            public enum CommandActive {
                Active,
                Disabled,
                Invisible
            }

            //Logging option
            public enum CommandLogging {
                Log,
                Ignore,
                Mandatory,
                Unable
            }

            public CommandActive command_active = CommandActive.Active;
            public Int64 command_id = -1;
            public String command_key = null;
            public CommandLogging command_logging = CommandLogging.Log;
            public String command_name = null;
            public Boolean command_playerInteraction = true;
            public String command_text = null;

            public override string ToString() {
                return command_name ?? "Unknown Command";
            }
        }

        public class AdKatsException {
            public System.Exception InternalException = null;
            public String Message = String.Empty;
            public String Method = String.Empty;
            //Param Constructors
            public AdKatsException(String message, System.Exception internalException) {
                Method = new StackFrame(1).GetMethod().Name;
                Message = message;
                InternalException = internalException;
            }

            public AdKatsException(String message) {
                Method = new StackFrame(1).GetMethod().Name;
                Message = message;
            }

            //Override toString
            public override String ToString() {
                return "[" + Method + "][" + Message + "]" + ((InternalException != null) ? (": " + InternalException) : (""));
            }
        }

        public class AdKatsPlayer {
            public CPunkbusterInfo PBPlayerInfo = null;
            public Queue<KeyValuePair<AdKatsPlayer, DateTime>> RecentKills = null;
            public List<AdKatsRecord> TargetedRecords = null;
            public String player_clanTag = null;
            public CPlayerInfo frostbitePlayerInfo = null;
            public Int64 game_id = -1;
            public DateTime lastAction = DateTime.UtcNow;
            public DateTime lastKill = DateTime.UtcNow;
            public DateTime lastDeath = DateTime.UtcNow;
            public DateTime lastSpawn = DateTime.UtcNow;
            public Boolean player_aa = false;
            public Boolean player_aa_fetched = false;
            public Boolean player_aa_told = false;
            public String player_guid = null;
            public Int64 player_id = -1;
            public String player_ip = null;
            public String player_name = null;
            public String player_name_previous = null;
            public Boolean player_online = true;
            public String player_pbguid = null;
            public AdKatsRole player_role = null;
            public String player_slot = null;
            public Double player_reputation = 0;
            public DateTime player_firstseen = DateTime.UtcNow;
            public AdKatsServer player_server = null;
            public TimeSpan player_serverplaytime = TimeSpan.FromSeconds(0);
            public Boolean player_spawnedOnce = false;
            public PlayerType player_type = PlayerType.Player;
            public String player_personaID = null;
            private Boolean player_locked;
            private DateTime player_locked_start = DateTime.UtcNow;
            private TimeSpan player_locked_duration = TimeSpan.Zero;
            private String player_locked_source;
            public AdKatsRecord LastPunishment = null;
            public AdKatsRecord LastForgive = null;
            public AdKatsTeam RequiredTeam = null;
            public readonly Queue<KeyValuePair<Double, DateTime>> player_pings;
            public Boolean player_pings_full { get; private set; }
            public Double player_ping_avg { get; private set; }
            public Double player_ping { get; private set; }
            public DateTime player_ping_time { get; private set; }
            public Boolean player_ping_added { get; private set; }
            public AdKatsPlayer conversationPartner = null;

            public AdKatsPlayerStats stats = null;
            public IPAPILocation location = null;
            public Boolean update_playerUpdated = true;
            public Boolean player_new = false;

            private AdKats Plugin;

            public AdKatsPlayer(AdKats plugin) {
                Plugin = plugin;
                RecentKills = new Queue<KeyValuePair<AdKatsPlayer, DateTime>>();
                player_pings = new Queue<KeyValuePair<Double, DateTime>>();
                TargetedRecords = new List<AdKatsRecord>();
            }

            public String GetVerboseName() {
                return ((String.IsNullOrEmpty(player_clanTag)) ? ("") : ("[" + player_clanTag + "]")) + player_name;
            }

            public TimeSpan GetIdleTime() {
                return Plugin.UtcDbTime() - lastAction;
            }

            public void ClearPingEntries() {
                player_pings.Clear();
                player_pings_full = false;
                player_ping = 0;
                player_ping_avg = 0;
            }

            public void AddPingEntry(Double newPingValue)
            {
                //Get rounded time (floor)
                DateTime newPingTime = Plugin.UtcDbTime();
                newPingTime = newPingTime.AddTicks(-(newPingTime.Ticks % TimeSpan.TicksPerSecond));
                if (!player_ping_added) {
                    player_ping_avg = newPingValue;
                    player_ping = newPingValue;
                    player_ping_time = newPingTime;
                    player_pings.Enqueue(new KeyValuePair<double, DateTime>(newPingValue, newPingTime));
                    player_ping_added = true;
                    return;
                }

                //Linear Interpolation
                DateTime oldPingTime = player_ping_time;
                Double oldPingValue = player_ping;
                Double interTimeOldSeconds = 0;
                Double interTimeNewSeconds = (newPingTime - oldPingTime).TotalSeconds;
                Double m = (newPingValue - oldPingValue) / (interTimeNewSeconds);
                Double b = oldPingValue;
                for (Int32 sec = (Int32)interTimeOldSeconds; sec < interTimeNewSeconds; sec++) {
                    DateTime subPingTime = oldPingTime.AddSeconds(sec);
                    Double subPingValue = (m * sec) + b;
                    player_pings.Enqueue(new KeyValuePair<double, DateTime>(subPingValue, subPingTime));
                }

                //Remove old values
                Boolean removed = false;
                do
                {
                    removed = false;
                    if (player_pings.Any() && (Plugin.UtcDbTime() - player_pings.Peek().Value).TotalSeconds > Plugin._pingMovingAverageDurationSeconds)
                    {
                        player_pings.Dequeue();
                        player_pings_full = true;
                        removed = true;
                    }
                } while (removed);

                //Set instance vars
                player_ping = newPingValue;
                player_ping_time = newPingTime;
                player_ping_avg = player_pings.Sum(pingEntry => pingEntry.Key) / ((double)player_pings.Count);
            }

            public Boolean IsLocked() {
                if (player_locked && player_locked_start + player_locked_duration < Plugin.UtcDbTime())
                {
                    //Unlock the player
                    player_locked = false;
                }
                return player_locked;
            }

            public Boolean Lock(String locker, TimeSpan duration) {
                if (IsLocked()) {
                    return false;
                }
                if (String.IsNullOrEmpty(locker)) {
                    Plugin.ConsoleError("Attempted to lock player with empty locker.");
                    return false;
                }
                if (duration == null || duration == TimeSpan.Zero) {
                    Plugin.ConsoleError("Attempted to lock player with invalid duration.");
                    return false;
                }
                player_locked = true;
                player_locked_duration = duration;
                player_locked_start = Plugin.UtcDbTime();
                player_locked_source = locker;
                return true;
            }

            public void Unlock() {
                player_locked = false;
            }

            public TimeSpan GetLockRemaining() {
                if (IsLocked()) {
                    return (player_locked_start + player_locked_duration) - Plugin.UtcDbTime();
                }
                return TimeSpan.Zero;
            }

            public String GetLockSource() {
                if (IsLocked()) {
                    return player_locked_source;
                }
                return null;
            }
        }

        public class AdKatsClient {
            public String ClientName;
            public String ClientMethod;
            public String SubscriptionGroup;
            public Boolean SubscriptionEnabled;
            public DateTime SubscriptionTime { get; private set; }

            private AdKats Plugin;

            public AdKatsClient(AdKats plugin) {
                Plugin = plugin;
            }

            public void EnableSubscription() {
                SubscriptionEnabled = true;
                SubscriptionTime = Plugin.UtcDbTime();
            }

            public void DisableSubscription() {
                SubscriptionEnabled = false;
                SubscriptionTime = Plugin.UtcDbTime();
            }
        }

        public class AdKatsServer {
            public Int64 ServerID;
            public Int64 ServerGroup;
            public String ServerIP;
            public String ServerName;
            public String ServerType = "UNKNOWN";
            public Int64 GameID = -1;
            public String ConnectionState;
            public Boolean CommanderEnabled;
            public Boolean FairFightEnabled;
            public Boolean ForceReloadWholeMags;
            public Boolean HitIndicatorEnabled;
            public String GamePatchVersion = "UNKNOWN";
            public Int32 MaxSpectators = -1;
            public CServerInfo InfoObject { get; private set; }
            private DateTime infoObjectTime = DateTime.UtcNow;

            private AdKats Plugin;

            public AdKatsServer(AdKats plugin) {
                Plugin = plugin;
            }

            public void SetInfoObject(CServerInfo infoObject) {
                InfoObject = infoObject;
                ServerName = infoObject.ServerName;
                infoObjectTime = Plugin.UtcDbTime();
            }

            public TimeSpan GetRoundElapsedTime()
            {
                if (InfoObject == null)
                {
                    return TimeSpan.Zero;
                }
                return TimeSpan.FromSeconds(InfoObject.RoundTime) + (Plugin.UtcDbTime() - infoObjectTime);
            }
        }

        public class AdKatsPlayerStats {
            public Double Assists = -1;
            public String ClanTag = null;
            public String Country = null;
            public String CountryName = null;
            public Double Deaths = -1;
            public DateTime FirstSeen = DateTime.MaxValue;
            public Double Headshots = -1;
            public Double Hits = -1;
            public Double Kills = -1;
            public String Language = null;
            public DateTime LastPlayerUpdate = DateTime.MaxValue;
            public DateTime LastStatUpdate = DateTime.MaxValue;
            public Double Losses = -1;
            public String Platform = null;

            public Double Rank = -1;
            public Int32 Score = -1;
            public Double Shots = -1;

            public AdKatsException StatsException = null;
            public TimeSpan Time = TimeSpan.FromSeconds(0);
            public Dictionary<String, AdKatsWeaponStats> WeaponStats = null;
            public Double Wins = -1;
        }

        public class AdKatsRecord {
            //Source of this record
            public enum Sources {
                Default,
                InternalAutomated,
                ExternalPlugin,
                InGame,
                Settings,
                ServerCommand,
                Database,
                HTTP
            }

            //Attributes for the record
            public AdKatsCommand command_action = null;
            public Int32 command_numeric = 0;
            public AdKatsCommand command_type = null;

            //All messages sent through this record via sendMessageToSource or other means
            public List<String> debugMessages;

            //Settings for External Plugin commands
            /*
             * SENDING:
             * callerIdentity
             * recordID
             * commandType
             * commandAction
             * isIRO
             * commandNumeric
             * sourceName
             * targetName
             * targetID
             * recordMessage
             * recordTime
             * recordError
             * recordErrorMessages
             * recordDebugMessages
             * actionExecuted
             * */
            public String external_callerIdentity = null;
            public String external_responseClass = null;
            public String external_responseMethod = null;
            public Boolean external_responseRequested;

            public Boolean isConfirmed;
            public Boolean isAliveChecked;
            public Boolean isLoadoutChecked;
            public Boolean targetLoadoutValid;
            public Boolean isContested;
            public Boolean isDebug;
            public Boolean isIRO;
            public Boolean record_action_executed;
            public AdKatsException record_exception = null;
            public Int64 record_id = -1;
            public String record_message = null;
            public Sources record_source = Sources.Default;
            public DateTime record_time = DateTime.UtcNow;
            public Int64 server_id = -1;
            public String source_name = null;
            public AdKatsPlayer source_player = null;

            public String target_name = null;
            public AdKatsPlayer target_player = null;

            //Multiple targets if needed
            //Not pushed to database
            public DateTime record_creationTime { get; private set; }
            public Boolean record_held;
            public Boolean record_orchestrate;
            public List<String> TargetNamesLocal; 
            public List<AdKatsPlayer> TargetPlayersLocal;
            public List<AdKatsRecord> TargetInnerRecords;

            //Default Constructor
            public AdKatsRecord() {
                debugMessages = new List<String>();
                TargetNamesLocal = new List<String>();
                TargetPlayersLocal = new List<AdKatsPlayer>();
                TargetInnerRecords = new List<AdKatsRecord>();
                record_creationTime = DateTime.UtcNow;
            }

            public String GetSourceName()
            {
                String source = "";
                if (source_player != null)
                {
                    source = ((source_player.player_online) ? ("") : ("(OFFLINE)")) + source_player.GetVerboseName();
                }
                else if (String.IsNullOrEmpty(source_name)) {
                    source = "NOSOURCE";
                }
                else
                {
                    source = source_name;
                }
                return source;
            }

            public String GetTargetNames()
            {
                String targets = "";
                if (TargetPlayersLocal.Any())
                {
                    foreach (AdKatsPlayer aPlayer in TargetPlayersLocal)
                    {
                        targets += ((aPlayer.player_online) ? ("") : ("(OFFLINE)")) + aPlayer.GetVerboseName() + ", ";
                    }
                }
                else if (target_player != null) 
                {
                    targets = ((target_player.player_online) ? ("") : ("(OFFLINE)")) + target_player.GetVerboseName();
                }
                else
                {
                    targets = target_name;
                }
                return targets.Trim().TrimEnd(',');
            }
        }

        public class AdKatsStatistic {
            public enum StatisticType {
                map_benefit,
                map_detriment,
                player_win,
                player_loss,
                player_baserape
            }

            public Int64 stat_id;
            public Int64 server_id;
            public Int64 round_id;
            public StatisticType stat_type;
            public String target_name;
            public AdKatsPlayer target_player;
            public Double stat_value;
            public String stat_comment;
            public DateTime stat_time;
        }

        public class AdKatsChatMessage {
            public enum ChatSubset {
                Global,
                Team,
                Squad
            }

            public String Speaker;
            public String Message;
            public String OriginalMessage;
            public ChatSubset Subset;
            public Int32 SubsetTeamID;
            public Int32 SubsetSquadID;
        }

        public class AdKatsRole {
            public Dictionary<String, KeyValuePair<Func<AdKats, AdKatsPlayer, Boolean>, AdKatsCommand>> ConditionalAllowedCommands = null;
            public Dictionary<String, AdKatsCommand> RoleAllowedCommands = null;
            public Dictionary<String, AdKatsSpecialGroup> RoleSetGroups = null; 
            public CPrivileges RoleProconPrivileges = null;
            public Int64 role_id = -1;
            public String role_key = null;
            public String role_name = null;
            public Int64 role_powerLevel = 0;

            public AdKatsRole() {
                RoleAllowedCommands = new Dictionary<String, AdKatsCommand>();
                RoleSetGroups = new Dictionary<String, AdKatsSpecialGroup>();
                ConditionalAllowedCommands = new Dictionary<String, KeyValuePair<Func<AdKats, AdKatsPlayer, Boolean>, AdKatsCommand>>();
            }
        }

        public class AdKatsSpecialGroup {
            public Int64 group_id;
            public String group_key;
            public String group_name;
        }

        public class AdKatsSpecialPlayer {
            public Int64 specialplayer_id;
            public Int32? player_game = null;
            public AdKatsSpecialGroup player_group = null;
            public String player_identifier = null;
            public AdKatsPlayer player_object = null;
            public Int32? player_server = null;
            public DateTime player_effective;
            public DateTime player_expiration;
        }

        public class AdKatsTeam {
            private AdKats Plugin;

            private readonly Queue<KeyValuePair<Double, DateTime>> TeamTicketCounts;
            public Double TeamTicketDifferenceRate { get; private set; }
            public Int32 TeamTicketCount { get; private set; }
            public DateTime TeamTicketsTime { get; private set; }
            public Boolean TeamTicketsAdded { get; private set; }

            //Ticket Adjustments
            private Int32 TeamTicketAdjustment;
            private readonly Queue<KeyValuePair<Double, DateTime>> TeamAdjustedTicketCounts;
            public Double TeamAdjustedTicketDifferenceRate { get; private set; }
            public Int32 TeamAdjustedTicketCount { get; private set; }
            public DateTime TeamAdjustedTicketsTime { get; private set; }
            public Boolean TeamAdjustedTicketsAdded { get; private set; }

            private readonly Queue<KeyValuePair<Double, DateTime>> TeamTotalScores;
            public Double TeamScoreDifferenceRate { get; private set; }
            public Double TeamTotalScore { get; private set; }
            public DateTime TeamTotalScoresTime { get; private set; }
            public Boolean TeamTotalScoresAdded { get; private set; }

            public AdKatsTeam(AdKats plugin, Int32 teamID, String teamKey, String teamName, String teamDesc) {
                Plugin = plugin;
                TeamID = teamID;
                TeamKey = teamKey;
                TeamName = teamName;
                TeamDesc = teamDesc;
                TeamTotalScores = new Queue<KeyValuePair<Double, DateTime>>();
                TeamTicketCounts = new Queue<KeyValuePair<Double, DateTime>>();
                TeamAdjustedTicketCounts = new Queue<KeyValuePair<Double, DateTime>>();
            }

            public Int32 TeamID { get; private set; }
            public String TeamKey { get; private set; }
            public String TeamName { get; private set; }
            public String TeamDesc { get; private set; }

            //Live Vars
            public Boolean Populated { get; private set; }
            public Int32 TeamPlayerCount { get; set; }

            public void UpdatePlayerCount(Int32 playerCount) {
                Populated = true;
                TeamPlayerCount = playerCount;
            }

            public void IncrementTeamTicketAdjustment()
            {
                Interlocked.Increment(ref TeamTicketAdjustment);
            }

            public void UpdateTicketCount(Double newTicketCount)
            {
                try
                {
                    UpdateAdjustedTicketCount(newTicketCount);
                    //Get rounded time (floor)
                    DateTime newTicketTime = Plugin.UtcDbTime();
                    newTicketTime = newTicketTime.AddTicks(-(newTicketTime.Ticks % TimeSpan.TicksPerSecond));
                    if (!TeamTicketsAdded) {
                        TeamTicketDifferenceRate = 0;
                        TeamTicketCount = (Int32)newTicketCount;
                        TeamTicketsTime = newTicketTime;
                        TeamTicketCounts.Enqueue(new KeyValuePair<double, DateTime>(newTicketCount, newTicketTime));
                        TeamTicketsAdded = true;
                        return;
                    }

                    //Interpolation
                    DateTime oldTicketTime = TeamTicketsTime;
                    Double oldTicketValue = TeamTicketCount;
                    Double interTimeOldSeconds = 0;
                    Double interTimeNewSeconds = (newTicketTime - oldTicketTime).TotalSeconds;
                    Double m = (newTicketCount - oldTicketValue) / (interTimeNewSeconds);
                    Double b = oldTicketValue;
                    for (Int32 sec = (Int32)interTimeOldSeconds; sec < interTimeNewSeconds; sec++)
                    {
                        DateTime subTicketTime = oldTicketTime.AddSeconds(sec);
                        Double subTicketValue = (m * sec) + b;
                        TeamTicketCounts.Enqueue(new KeyValuePair<double, DateTime>(subTicketValue, subTicketTime));
                    }

                    //Remove old values (more than 60 seconds ago)
                    Boolean removed = false;
                    do
                    {
                        removed = false;
                        if (TeamTicketCounts.Any() && (Plugin.UtcDbTime() - TeamTicketCounts.Peek().Value).TotalSeconds > 60)
                        {
                            TeamTicketCounts.Dequeue();
                            removed = true;
                        }
                    } while (removed);

                    //Set instance vars
                    TeamTicketCount = (Int32)newTicketCount;
                    TeamTicketsTime = newTicketTime;

                    List<Double> values = TeamTicketCounts.Select(pair => pair.Key).ToList();
                    var differences = new List<Double>();
                    for (int i = 0; i < values.Count - 1; i++)
                    {
                        differences.Add(values[i + 1] - values[i]);
                    }
                    differences.Sort();
                    //Convert to tickets/min
                    TeamTicketDifferenceRate = (differences.Sum() / differences.Count) * 60;
                    if (Double.IsNaN(TeamTicketDifferenceRate))
                    {
                        TeamTicketDifferenceRate = 0;
                    }
                }
                catch (Exception e) {
                    Plugin.HandleException(new AdKatsException("Error while updating team ticket count.", e));
                }
            }

            private void UpdateAdjustedTicketCount(Double newRealTicketCount)
            {
                try
                {
                    //Calculate adjusted ticket count
                    Double newAdjustedTicketCount = newRealTicketCount + TeamTicketAdjustment;
                    //Get rounded time (floor)
                    DateTime newAdjustedTicketTime = Plugin.UtcDbTime();
                    newAdjustedTicketTime = newAdjustedTicketTime.AddTicks(-(newAdjustedTicketTime.Ticks % TimeSpan.TicksPerSecond));
                    if (!TeamTicketsAdded)
                    {
                        TeamAdjustedTicketDifferenceRate = 0;
                        TeamAdjustedTicketCount = (Int32)newAdjustedTicketCount;
                        TeamAdjustedTicketsTime = newAdjustedTicketTime;
                        TeamAdjustedTicketCounts.Enqueue(new KeyValuePair<double, DateTime>(newAdjustedTicketCount, newAdjustedTicketTime));
                        TeamAdjustedTicketsAdded = true;
                        return;
                    }

                    //Interpolation
                    DateTime oldTicketTime = TeamAdjustedTicketsTime;
                    Double oldTicketValue = TeamAdjustedTicketCount;
                    Double interTimeOldSeconds = 0;
                    Double interTimeNewSeconds = (newAdjustedTicketTime - oldTicketTime).TotalSeconds;
                    Double m = (newAdjustedTicketCount - oldTicketValue) / (interTimeNewSeconds);
                    Double b = oldTicketValue;
                    for (Int32 sec = (Int32)interTimeOldSeconds; sec < interTimeNewSeconds; sec++)
                    {
                        DateTime subTicketTime = oldTicketTime.AddSeconds(sec);
                        Double subTicketValue = (m * sec) + b;
                        TeamAdjustedTicketCounts.Enqueue(new KeyValuePair<double, DateTime>(subTicketValue, subTicketTime));
                    }

                    //Remove old values (more than 60 seconds ago)
                    Boolean removed = false;
                    do
                    {
                        removed = false;
                        if (TeamAdjustedTicketCounts.Any() && (Plugin.UtcDbTime() - TeamAdjustedTicketCounts.Peek().Value).TotalSeconds > 60)
                        {
                            TeamAdjustedTicketCounts.Dequeue();
                            removed = true;
                        }
                    } while (removed);

                    //Set instance vars
                    TeamAdjustedTicketCount = (Int32)newAdjustedTicketCount;
                    TeamAdjustedTicketsTime = newAdjustedTicketTime;

                    List<Double> values = TeamAdjustedTicketCounts.Select(pair => pair.Key).ToList();
                    var differences = new List<Double>();
                    for (int i = 0; i < values.Count - 1; i++)
                    {
                        differences.Add(values[i + 1] - values[i]);
                    }
                    differences.Sort();
                    //Convert to tickets/min
                    TeamAdjustedTicketDifferenceRate = (differences.Sum() / differences.Count) * 60;
                    if (Double.IsNaN(TeamAdjustedTicketDifferenceRate) ||
                        TeamAdjustedTicketDifferenceRate > 0)
                    {
                        TeamAdjustedTicketDifferenceRate = 0;
                    }
                }
                catch (Exception e)
                {
                    Plugin.HandleException(new AdKatsException("Error while updating team adjusted ticket count.", e));
                }
            }

            public void UpdateTotalScore(Double newTotalScore)
            {
                try
                {
                    //Get rounded time (floor)
                    DateTime newScoreTime = Plugin.UtcDbTime();
                    newScoreTime = newScoreTime.AddTicks(-(newScoreTime.Ticks % TimeSpan.TicksPerSecond));
                    if (!TeamTotalScoresAdded)
                    {
                        TeamScoreDifferenceRate = 0;
                        TeamTotalScore = newTotalScore;
                        TeamTotalScoresTime = newScoreTime;
                        TeamTotalScores.Enqueue(new KeyValuePair<double, DateTime>(newTotalScore, newScoreTime));
                        TeamTotalScoresAdded = true;
                        return;
                    }

                    //Interpolation
                    DateTime oldScoreTime = TeamTotalScoresTime;
                    Double oldScoreValue = TeamTotalScore;
                    Double interTimeOldSeconds = 0;
                    Double interTimeNewSeconds = (newScoreTime - oldScoreTime).TotalSeconds;
                    Double m = (newTotalScore - oldScoreValue) / (interTimeNewSeconds);
                    Double b = oldScoreValue;
                    for (Int32 sec = (Int32)interTimeOldSeconds; sec < interTimeNewSeconds; sec++)
                    {
                        DateTime subScoreTime = oldScoreTime.AddSeconds(sec);
                        Double subScoreValue = (m * sec) + b;
                        TeamTotalScores.Enqueue(new KeyValuePair<double, DateTime>(subScoreValue, subScoreTime));
                    }

                    //Remove old values (more than 60 seconds ago)
                    Boolean removed = false;
                    do
                    {
                        removed = false;
                        if (TeamTotalScores.Any() && (Plugin.UtcDbTime() - TeamTotalScores.Peek().Value).TotalSeconds > 60)
                        {
                            TeamTotalScores.Dequeue();
                            removed = true;
                        }
                    } while (removed);

                    //Set instance vars
                    TeamTotalScore = newTotalScore;
                    TeamTotalScoresTime = newScoreTime;

                    List<Double> values = TeamTotalScores.Select(pair => pair.Key).ToList();
                    var differences = new List<Double>();
                    for (int i = 0; i < values.Count - 1; i++)
                    {
                        differences.Add(values[i + 1] - values[i]);
                    }
                    differences.Sort();
                    //Convert to tickets/min
                    TeamScoreDifferenceRate = (differences.Sum() / differences.Count) * 60;
                    if (Double.IsNaN(TeamScoreDifferenceRate))
                    {
                        TeamScoreDifferenceRate = 0;
                    }
                }
                catch (Exception e)
                {
                    Plugin.HandleException(new AdKatsException("Error while updating team ticket total score.", e));
                }
            }

            public void Reset() {
                try
                {
                    TeamTicketCount = 0;
                    TeamAdjustedTicketCount = 0;
                    TeamTicketCounts.Clear();
                    TeamAdjustedTicketCounts.Clear();
                    TeamTicketDifferenceRate = 0;
                    TeamAdjustedTicketDifferenceRate = 0;
                    TeamTicketsAdded = false;
                    TeamAdjustedTicketsAdded = false;
                    TeamTicketAdjustment = 0;
                    TeamTotalScore = 0;
                    TeamTotalScores.Clear();
                    TeamScoreDifferenceRate = 0;
                    TeamTotalScoresAdded = false;
                }
                catch (Exception e) {
                    Plugin.HandleException(new AdKatsException("Error while resetting team.", e));
                }
            }
        }

        public class AdKatsUser {
            //No reference to player table made here, plain String id access
            public Dictionary<long, AdKatsPlayer> soldierDictionary = null;
            public String user_email = null;
            public Int64 user_id = -1;
            public String user_name = null;
            public String user_phone = null;
            public AdKatsRole user_role = null;
            public DateTime user_expiration;
            public String user_notes = "";

            public AdKatsUser() {
                soldierDictionary = new Dictionary<long, AdKatsPlayer>();
            }
        }

        public class AdKatsWeaponStats {
            public String Category = null;
            public Double DPS = -1;
            public Double HSKR = -1;
            public Double Headshots = -1;
            public Double Hits = -1;
            public String ID = null;
            public Double KPM = -1;
            public Double Kills = -1;
            public String Kit = null;
            public String Range = null;
            public Double Shots = -1;
            public TimeSpan Time = TimeSpan.FromSeconds(0);
            public Double MaxDPS = 1;
        }

        public class AdKatsSQLUpdate {
            public String update_id;
            public String version_minimum;
            public String version_maximum;
            public String message_name;
            public String message_success;
            public String message_failure;
            public Boolean update_checks_hasResults = true;
            public List<String> update_checks;
            public Boolean update_execute_requiresModRows;
            public List<String> update_execute;
            public List<String> update_success;
            public List<String> update_failure;
            public AdKatsSQLUpdate() {
                update_checks = new List<string>();
                update_execute = new List<string>();
                update_success = new List<string>();
                update_failure = new List<string>();
            }
        }

        internal enum AssessmentTypes {
            none,
            black,
            white,
            watch
        }

        public class BBM5108Ban {
            public DateTime ban_duration;
            public String ban_length = null;
            public String ban_reason = null;
            public String eaguid = null;
            public String soldiername = null;
        }

        public class EmailHandler {
            private readonly Queue<MailMessage> _EmailProcessingQueue = new Queue<MailMessage>();
            public readonly EventWaitHandle _EmailProcessingWaitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
            public String CustomHTMLAddition;
            public AdKats Plugin;
            public List<String> RecipientEmails = new List<string>();
            public String SMTPPassword = "paqwjboqkbfywapu";
            public Int32 SMTPPort = 587;
            public String SMTPServer = "smtp.gmail.com";
            public String SMTPUser = "adkatsbattlefield@gmail.com";
            public String SenderEmail = "adkatsbattlefield@gmail.com";
            public Boolean UseSSL = true;
            private Thread _EmailProcessingThread;

            public EmailHandler(AdKats plugin) {
                Plugin = plugin;
                switch (Plugin._gameVersion) {
                    case GameVersion.BF3:
                        CustomHTMLAddition = @"<br><a href='http://battlelog.battlefield.com/bf3/user/%player_name%/'>BF3 Battlelog Profile</a><br>
<br><a href='http://bf3stats.com/stats_pc/%player_name%'>BF3Stats Profile</a><br>
<br><a href='http://history.anticheatinc.com/bf3/?searchvalue=%player_name%'>AntiCheat, INC. Search</a><br>
<br><a href='http://metabans.com/search/%player_name%'>Metabans Search</a><br>
<br><a href='http://i-stats.net/index.php?action=pcheck&game=BF3&player=%player_name%'>I-Stats Search</a><br>
<br><a href='http://www.team-des-fra.fr/CoM/bf3.php?p=%player_name%'>TeamDes Search</a><br>
<br><a href='http://cheatometer.hedix.de/?p=%player_name%'>Hedix Search</a><br>";
                        break;
                    case GameVersion.BF4:
                        CustomHTMLAddition = @"<br><a href='http://battlelog.battlefield.com/bf4/de/user/%player_name%/'>BF4 Battlelog Profile</a><br>
<br><a href='http://bf4stats.com/pc/%player_name%'>BF4Stats Profile</a><br>
<br><a href='http://history.anticheatinc.com/bf4/?searchvalue=%player_name%'>AntiCheat, INC. Search</a><br>
<br><a href='http://metabans.com/search/%player_name%'>Metabans Search</a><br>";
                        break;
                    default:
                        Plugin.ConsoleError("Game version not understood in email handler");
                        CustomHTMLAddition = "";
                        break;
                }
            }

            public void SendReport(AdKatsRecord record) {
                try {
                    if (Plugin.FetchOnlineAdminSoldiers().Any() && false) {
                        Plugin.ConsoleWarn("Online admins detected, report email aborted.");
                        return;
                    }
                    if (record.target_player == null) {
                        Plugin.SendMessageToSource(record, "Unable to send report email. No target player found.");
                    }
                    //Create a new thread to handle keep-alive
                    //This thread will remain running for the duration the layer is online
                    var emailSendingThread = new Thread(new ThreadStart(delegate {
                        try {
                            Thread.CurrentThread.Name = "emailsending";
                            String subject = String.Empty;
                            String body = String.Empty;

                            var sb = new StringBuilder();
                            if (String.IsNullOrEmpty(Plugin._serverInfo.ServerName)) {
                                //Unable to send report email, server id unknown
                                return;
                            }
                            subject = record.GetTargetNames() + " reported in [" + Plugin._gameVersion + "] " + Plugin._serverInfo.ServerName;
                            sb.Append("<h1>AdKats " + Plugin._gameVersion + " Player Report [" + record.command_numeric + "]</h1>");
                            sb.Append("<h2>" + Plugin._serverInfo.ServerName + "</h2>");
                            sb.Append("<h3>" + DateTime.Now + " ProCon Time</h3>");
                            sb.Append("<h3>" + record.GetSourceName() + " has reported " + record.GetTargetNames() + " for " + record.record_message + "</h3>");
                            sb.Append("<p>");
                            CPlayerInfo playerInfo = record.target_player.frostbitePlayerInfo;
                            //sb.Append("<h4>Current Information on " + record.target_name + ":</h4>");
                            int numReports = Plugin._RoundReports.Values.Count(aRecord => aRecord.target_name == record.target_name);
                            sb.Append("Reported " + numReports + " times during the current round.<br/>");
                            sb.Append("Has " + Plugin.FetchPoints(record.target_player, false) + " infraction points on this server.<br/>");
                            sb.Append("Score: " + playerInfo.Score + "<br/>");
                            sb.Append("Kills: " + playerInfo.Kills + "<br/>");
                            sb.Append("Deaths: " + playerInfo.Deaths + "<br/>");
                            sb.Append("Kdr: " + playerInfo.Kdr + "<br/>");
                            sb.Append("Ping: " + playerInfo.Ping + "<br/>");
                            sb.Append("</p>");
                            sb.Append("<p>");
                            sb.Append("SoldierName: " + playerInfo.SoldierName + "<br/>");
                            sb.Append("EA GUID: " + playerInfo.GUID + "<br/>");
                            if (record.target_player.PBPlayerInfo != null) {
                                sb.Append("PB GUID: " + record.target_player.PBPlayerInfo.GUID + "<br/>");
                                sb.Append("IP: " + record.target_player.PBPlayerInfo.Ip.Split(':')[0] + "<br/>");
                                sb.Append("Country: " + record.target_player.PBPlayerInfo.PlayerCountry + "<br/>");
                            }
                            String processedCustomHTML = Plugin.ReplacePlayerInformation(CustomHTMLAddition, record.target_player);
                            sb.Append(processedCustomHTML);
                            sb.Append("</p>");
                            //TODO: Add chat back for ADK usage.
                            if (record.target_player != null && !Plugin._isTestingAuthorized) {
                                sb.Append("<table>");
                                sb.Append(@"<thead><td>Time</td><td>Player</td><td>Message</td></thead>");
                                sb.Append("<tbody>");
                                if (record.source_player != null) {
                                    foreach (var chatLine in Plugin.FetchConversation(record.source_player.player_id, record.target_player.player_id, 30, 7)) {
                                        sb.Append("<tr>");
                                        sb.Append("<td>" + chatLine.Key.ToShortDateString() + " " + chatLine.Key.ToShortTimeString() + "</td>");
                                        sb.Append("<td>" + chatLine.Value.Key + "</td>");
                                        sb.Append("<td>" + chatLine.Value.Value + "</td>");
                                        sb.Append("</tr>");
                                    }
                                }
                                else {
                                    foreach (var chatLine in Plugin.FetchChat(record.target_player.player_id, 30, 7)) {
                                        sb.Append("<tr>");
                                        sb.Append("<td>" + chatLine.Key.ToShortDateString() + " " + chatLine.Key.ToShortTimeString() + "</td>");
                                        sb.Append("<td>" + record.GetTargetNames() + "</td>");
                                        sb.Append("<td>" + chatLine.Value + "</td>");
                                        sb.Append("</tr>");
                                    }
                                }
                                sb.Append("</tbody>");
                                sb.Append("</table>");
                            }

                            body = sb.ToString();


                            EmailWrite(subject, body);
                        }
                        catch (Exception e) {
                            Plugin.HandleException(new AdKatsException("Error in email sending thread.", e));
                        }
                        Plugin.LogThreadExit();
                    }));
                    //Start the thread
                    Plugin.StartAndLogThread(emailSendingThread);
                }
                catch (Exception e) {
                    Plugin.HandleException(new AdKatsException("Error when sending email.", e));
                }
            }

            private void EmailWrite(String subject, String body) {
                try {
                    var email = new MailMessage();

                    email.From = new MailAddress(SenderEmail, "AdKats Report System");

                    Boolean someAdded = false;
                    lock (Plugin._userCache) {
                        foreach (AdKatsUser aUser in Plugin._userCache.Values) {
                            //Check for not null and default values
                            if (Plugin.UserIsAdmin(aUser) && !String.IsNullOrEmpty(aUser.user_email))
                            {
                                if (Regex.IsMatch(aUser.user_email, @"^([\w-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([\w-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$")) {
                                    email.Bcc.Add(new MailAddress(aUser.user_email));
                                    someAdded = true;
                                }
                                else {
                                    Plugin.ConsoleError("Error in user email address: " + aUser.user_email);
                                }
                            }
                        }
                        foreach (String extraEmail in RecipientEmails) {
                            if (String.IsNullOrEmpty(extraEmail.Trim()))
                                continue;

                            if (Regex.IsMatch(extraEmail, @"^([\w-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([\w-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$")) {
                                email.Bcc.Add(new MailAddress(extraEmail));
                                someAdded = true;
                            }
                            else {
                                Plugin.ConsoleError("Error in extra email address: " + extraEmail);
                            }
                        }
                    }
                    if (!someAdded) {
                        Plugin.ConsoleError("Unable to send email. No users with emails have access to player interaction commands.");
                        return;
                    }

                    email.Subject = subject;
                    email.Body = body;
                    email.IsBodyHtml = true;
                    email.BodyEncoding = Encoding.UTF8;

                    QueueEmailForSending(email);
                }
                catch (Exception e) {
                    Plugin.ConsoleError("Error while sending email: " + e);
                }
            }

            private void QueueEmailForSending(MailMessage email) {
                Plugin.DebugWrite("Entering QueueEmailForSending", 7);
                try {
                    if (Plugin._pluginEnabled) {
                        Plugin.DebugWrite("Preparing to queue email for processing", 6);
                        lock (_EmailProcessingQueue) {
                            _EmailProcessingQueue.Enqueue(email);
                            Plugin.DebugWrite("Email queued for processing", 6);
                            //Start the processing thread if not already running
                            if (_EmailProcessingThread == null || !_EmailProcessingThread.IsAlive) {
                                _EmailProcessingThread = new Thread(EmailProcessingThreadLoop) {
                                    IsBackground = true
                                };
                                Plugin.StartAndLogThread(_EmailProcessingThread);
                            }
                            _EmailProcessingWaitHandle.Set();
                        }
                    }
                }
                catch (Exception e) {
                    Plugin.HandleException(new AdKatsException("Error while queueing email for processing.", e));
                }
                Plugin.DebugWrite("Exiting QueueEmailForSending", 7);
            }

            public void EmailProcessingThreadLoop() {
                try {
                    Plugin.DebugWrite("EMAIL: Starting Email Handling Thread", 1);
                    Thread.CurrentThread.Name = "EmailHandling";
                    DateTime loopStart = Plugin.UtcDbTime();
                    while (true) {
                        try {
                            Plugin.DebugWrite("EMAIL: Entering Email Handling Thread Loop", 7);
                            if (!Plugin._pluginEnabled) {
                                Plugin.DebugWrite("EMAIL: Detected AdKats not enabled. Exiting thread " + Thread.CurrentThread.Name, 6);
                                break;
                            }

                            //Get all unprocessed inbound emails
                            var inboundEmailMessages = new Queue<MailMessage>();
                            if (_EmailProcessingQueue.Any()) {
                                Plugin.DebugWrite("EMAIL: Preparing to lock inbound mail queue to retrive new mail", 7);
                                lock (_EmailProcessingQueue) {
                                    Plugin.DebugWrite("EMAIL: Inbound mail found. Grabbing.", 6);
                                    //Grab all mail in the queue
                                    inboundEmailMessages = new Queue<MailMessage>(_EmailProcessingQueue.ToArray());
                                    //Clear the queue for next run
                                    _EmailProcessingQueue.Clear();
                                }
                            }
                            else {
                                Plugin.DebugWrite("EMAIL: No inbound mail. Waiting for Input.", 6);
                                //Wait for input
                                if ((Plugin.UtcDbTime() - loopStart).TotalMilliseconds > 1000)
                                    Plugin.DebugWrite("Warning. " + Thread.CurrentThread.Name + " thread processing completed in " + ((int)((Plugin.UtcDbTime() - loopStart).TotalMilliseconds)) + "ms", 4);
                                _EmailProcessingWaitHandle.Reset();
                                _EmailProcessingWaitHandle.WaitOne(TimeSpan.FromSeconds(5));
                                loopStart = Plugin.UtcDbTime();
                                continue;
                            }

                            //Loop through all mails in order that they came in
                            while (inboundEmailMessages.Any()) {
                                if (!Plugin._pluginEnabled) {
                                    break;
                                }
                                Plugin.DebugWrite("EMAIL: begin reading mail", 6);
                                MailMessage message = inboundEmailMessages.Dequeue();
                                if (Plugin._debugLevel >= 5) {
                                    Plugin.ConsoleWrite("EMAIL: server: " + SMTPServer);
                                    Plugin.ConsoleWrite("EMAIL: port: " + SMTPPort);
                                    Plugin.ConsoleWrite("EMAIL: user/pass: " + ((!String.IsNullOrEmpty(SMTPUser) && !String.IsNullOrEmpty(SMTPPassword)) ? "OK" : "INVALID"));
                                    Plugin.ConsoleWrite("EMAIL: details sender: " + message.Sender);
                                    Plugin.ConsoleWrite("EMAIL: details from: " + message.From);
                                    Plugin.ConsoleWrite("EMAIL: details to: " + message.To);
                                    Plugin.ConsoleWrite("EMAIL: details cc: " + message.CC);
                                    Plugin.ConsoleWrite("EMAIL: details bcc: " + message.Bcc);
                                    Plugin.ConsoleWrite("EMAIL: details subject: " + message.Subject);
                                    Plugin.ConsoleWrite("EMAIL: details body: " + message.Body);
                                }
                                //Dequeue the first/next mail
                                var smtp = new SmtpClient(SMTPServer, SMTPPort) {
                                    EnableSsl = UseSSL,
                                    Timeout = 10000,
                                    DeliveryMethod = SmtpDeliveryMethod.Network,
                                    UseDefaultCredentials = false,
                                    Credentials = new NetworkCredential(SMTPUser, SMTPPassword)
                                };
                                smtp.SendCompleted += new SendCompletedEventHandler(smtp_SendCompleted);

                                Plugin.DebugWrite("Sending notification email. Please wait.", 1);

                                smtp.Send(message);

                                Plugin.DebugWrite("A notification email has been sent.", 1);

                                if (inboundEmailMessages.Any()) {
                                    //Wait 5 seconds between loops
                                    Plugin._threadMasterWaitHandle.WaitOne(5000);
                                }
                            }
                        }
                        catch (Exception e) {
                            if (e is ThreadAbortException) {
                                Plugin.HandleException(new AdKatsException("mail processing thread aborted. Exiting."));
                                break;
                            }
                            Plugin.HandleException(new AdKatsException("Error occured in mail processing thread. skipping loop.", e));
                        }
                    }
                    Plugin.DebugWrite("EMAIL: Ending mail Processing Thread", 1);
                    Plugin.LogThreadExit();
                }
                catch (Exception e) {
                    Plugin.HandleException(new AdKatsException("Error occured in mail processing thread.", e));
                }
            }

            private void smtp_SendCompleted(object sender, System.ComponentModel.AsyncCompletedEventArgs e) {
                if (e.Cancelled == true || e.Error != null) {
                    Plugin.HandleException(new AdKatsException("Error occured in mail processing. Sending Canceled.", e.Error));
                }
            }
        }

        public class IPAPILocation {
            public String IP;
            public String city;
            public String country;
            public String countryCode;
            public String isp;
            public Double lat;
            public Double lon;
            public String message;
            public String org;
            public String query;
            public String region;
            public String regionName;
            public String status;
            public String timezone;
            public String zip;

            public IPAPILocation(String ip) {
                if (String.IsNullOrEmpty(ip)) {
                    throw new NoNullAllowedException("Location IP must not be null.");
                }
                IP = ip;
            }
        }

        internal class MetabansAPI {
            public delegate void ExecuteCommandHandler(params string[] commands);

            public delegate void RequestSuccessHandler(Hashtable request, Hashtable data);

            private static string METABANS_API_HREF = "http://metabans.com/mb-api.php";

            private readonly string ApiKey;
            private readonly enumBoolOnOff Debug;
            private readonly string Username;
            private readonly ArrayList m_requests;

            public MetabansAPI(string Username, string ApiKey, enumBoolOnOff Debug) {
                m_requests = new ArrayList();

                // if username + apikey == "", load from xml file.

                this.Username = Username;
                this.ApiKey = ApiKey;
                this.Debug = Debug;
            }

            // You must have this event registered to see output of the Debug.

            public event ExecuteCommandHandler ExecuteCommand;

            public event RequestSuccessHandler mb_sight_player_ok;
            public event RequestSuccessHandler mb_assess_player_ok;

            // You may implement more functions if you need them at http://wiki.metabans.com/API
            // Just remember to change the API version and publish your changes on the forums

            public MetabansAPI mb_assess_player(int player_id, AssessmentTypes assessment_type, string reason, int assessment_length) {
                var hash = new Hashtable();
                hash.Add("action", "mb_assess_player");
                hash.Add("player_id", player_id.ToString());
                hash.Add("assessment_type", assessment_type.ToString());
                hash.Add("reason", reason);
                hash.Add("assessment_length", assessment_length.ToString());

                m_requests.Add(hash);

                return this;
            }

            public MetabansAPI mb_assess_player(SupportedGames game_name, string player_uid, AssessmentTypes assessment_type, string reason, int assessment_length) {
                var hash = new Hashtable();
                hash.Add("action", "mb_assess_player");
                hash.Add("game_name", game_name.ToString());
                hash.Add("player_uid", player_uid);
                hash.Add("assessment_type", assessment_type.ToString());
                hash.Add("reason", reason);
                hash.Add("assessment_length", assessment_length.ToString());

                m_requests.Add(hash);

                return this;
            }

            // You shouldn't ever need to sight a player.  Only the main Metabans plugin should ever need to do this.
            public MetabansAPI mb_sight_player(SupportedGames game_name, string player_uid, string player_name, string group_name, string player_ip, string alternate_uid) {
                var hash = new Hashtable();
                hash.Add("action", "mb_sight_player");
                hash.Add("game_name", game_name.ToString());
                hash.Add("player_uid", player_uid);
                hash.Add("player_name", player_name);
                hash.Add("group_name", group_name);

                if (player_ip != null) {
                    hash.Add("player_ip", player_ip.Split(':')[0]);
                }

                hash.Add("alternate_uid", alternate_uid);

                m_requests.Add(hash);

                return this;
            }

            private static string GenerateSalt() {
                var random = new Random();
                var salt = new byte[random.Next(24, 48)];

                for (int i = 0; i < salt.Length; i++) {
                    salt[i] = (byte) random.Next(1, 254);
                }

                return SHA1.Data(salt);
            }

            private string GeneratePostData() {
                var postBuilder = new StringBuilder();

                postBuilder.AppendFormat("&username={0}", Uri.EscapeUriString(Username));

                string salt = MetabansAPI.GenerateSalt();
                postBuilder.AppendFormat("&salt={0}", Uri.EscapeUriString(salt));
                postBuilder.AppendFormat("&apikey={0}", Uri.EscapeUriString(SHA1.String(salt + ApiKey)));
                postBuilder.Append("&options=mirror");

                for (int offset = 0; offset < m_requests.Count; offset++) {
                    if (m_requests[offset] is Hashtable) {
                        foreach (DictionaryEntry entry in (Hashtable) m_requests[offset]) {
                            if (entry.Value != null) {
                                postBuilder.AppendFormat("&{0}={1}", Uri.EscapeUriString(String.Format("requests[{0}][{1}]", offset, entry.Key)), Uri.EscapeUriString(entry.Value.ToString()));
                            }
                        }
                    }
                }

                return postBuilder.ToString();
            }

            private void request_RequestComplete(MetabansRequest sender) {
                var table = (Hashtable) JSON.JsonDecode(Encoding.UTF8.GetString(sender.CompleteFileData));

                try {
                    if (Debug == enumBoolOnOff.On && ExecuteCommand != null) {
                        ExecuteCommand("procon.protected.pluginconsole.write", "^4Metabans API: Received sync response, beginning parse");
                    }

                    foreach (Hashtable response in (ArrayList) table["responses"]) {
                        if (response.ContainsKey("status") == true && (string) response["status"] == "OK") {
                            if (response.ContainsKey("request") == true && response.ContainsKey("data") == true) {
                                var request = (Hashtable) response["request"];
                                var data = (Hashtable) response["data"];

                                if (request.ContainsKey("action") == true) {
                                    switch ((string) request["action"]) {
                                        case "mb_sight_player":
                                            if (mb_sight_player_ok != null) {
                                                mb_sight_player_ok(request, data);
                                            }
                                            break;
                                        case "mb_assess_player":
                                            if (mb_assess_player_ok != null) {
                                                mb_assess_player_ok(request, data);
                                            }
                                            break;
                                    }
                                }
                            }
                        }
                        else if (response.ContainsKey("error") == true) {
                            if ( /*this.Debug == enumBoolOnOff.On && */ExecuteCommand != null) {
                                // This is an error because of information sent to the metabans (like api key error or something)
                                // not an actual problem that requires debugging.
                                ExecuteCommand("procon.protected.pluginconsole.write", "^1Metabans API: Response error; " + (string) ((Hashtable) response["error"])["message"]);
                            }
                        }
                    }

                    if (Debug == enumBoolOnOff.On && ExecuteCommand != null) {
                        ExecuteCommand("procon.protected.pluginconsole.write", "^4Metabans API: Received sync and parse completed");
                    }
                }
                catch (Exception e) {
                    if (Debug == enumBoolOnOff.On && ExecuteCommand != null) {
                        ExecuteCommand("procon.protected.pluginconsole.write", "^1Metabans API (request_RequestComplete): " + e.Message);
                    }
                }
            }

            private void request_RequestError(MetabansRequest sender) {
                if (Debug == enumBoolOnOff.On && ExecuteCommand != null) {
                    ExecuteCommand("procon.protected.pluginconsole.write", "^1Metabans API request_RequestError: " + sender.Error);
                }
            }

            public MetabansAPI Post() {
                var request = new MetabansRequest(MetabansAPI.METABANS_API_HREF);
                request.RequestComplete += new MetabansRequest.RequestEventDelegate(request_RequestComplete);
                request.RequestError += new MetabansRequest.RequestEventDelegate(request_RequestError);
                request.Method = "POST";
                request.RequestContent = GeneratePostData();

                if (Debug == enumBoolOnOff.On && ExecuteCommand != null) {
                    ExecuteCommand("procon.protected.pluginconsole.write", "^4Metabans API: Post " + Uri.EscapeUriString(request.RequestContent));
                }

                request.BeginRequest();

                return this;
            }
        }

        // This is similar to CDownloadFile but has some POST options included
        internal class MetabansRequest {
            public delegate void RequestEventDelegate(MetabansRequest sender);

            private const int INT_BUFFER_SIZE = UInt16.MaxValue;
            public object AdditionalData;

            public int BytesDownloaded;

            public byte[] CompleteFileData;
            public string DownloadSource;

            public string Error;
            public bool FileDownloading;
            public int FileSize;

            /// <summary>
            ///     The WebRequestMethods.Http string representing the type of
            ///     method to use in the request.  Default is Get.
            /// </summary>
            public string Method;

            /// <summary>
            ///     Optional range to include in the request header
            /// </summary>
            public int? Range;

            /// <summary>
            ///     Optional referrer to include in the request header
            /// </summary>
            public string Referrer = "PRoCon Metabans Plugin/1.0.6.0";

            /// <summary>
            ///     The contents of a POST request
            /// </summary>
            public string RequestContent;

            public bool UnknownSize;
            private System.Timers.Timer m_progressTimer;
            private Stream m_responseStream;

            private int m_timeout;
            private HttpWebRequest m_webRequest;
            private WebResponse m_webResponse;
            private byte[] ma_bBufferStream;

            public MetabansRequest(string downloadSource) {
                DownloadSource = downloadSource;

                m_timeout = 30000;
                Method = WebRequestMethods.Http.Get;
            }

            /// <summary>
            ///     ReadTimeout of the stream in milliseconds.  Default is 10 seconds.
            /// </summary>
            public int Timeout {
                get { return m_timeout; }
                set {
                    m_timeout = value;

                    if (m_responseStream != null) {
                        m_responseStream.ReadTimeout = value;
                    }
                }
            }

            public string FileName {
                get {
                    string strReturnFileName = String.Empty;

                    if (DownloadSource.Length > 0) {
                        strReturnFileName = DownloadSource.Substring(DownloadSource.LastIndexOf("/") + 1, (DownloadSource.Length - DownloadSource.LastIndexOf("/") - 1));
                    }

                    return strReturnFileName;
                }
            }

            public event RequestEventDelegate RequestComplete;
            public event RequestEventDelegate RequestError;
            public event RequestEventDelegate RequestDiscoveredFileSize;
            public event RequestEventDelegate RequestProgressUpdate;

            public void EndDownload() {
                FileDownloading = false;
            }

            private void RequestTimeoutCallback(object state, bool timedOut) {
                if (timedOut == true) {
                    var cdfParent = (MetabansRequest) state;

                    if (cdfParent != null) {
                        try {
                            cdfParent.m_webRequest.Abort();
                        }
                        catch (Exception e) {
                            if (RequestError != null) {
                                Error = e.Message;

                                RequestError(this);
                            }
                        }
                    }
                }
            }

            public void BeginRequest() {
                try {
                    new Thread(new ThreadStart(BeginRequestCallback)).Start();
                }
                catch (Exception e) {
                    if (RequestError != null) {
                        Error = e.Message;

                        RequestError(this);
                    }
                }
            }

            private void BeginRequestCallback() {
                UnknownSize = true;

                BytesDownloaded = 0;
                FileSize = 1;

                FileDownloading = true;

                ma_bBufferStream = new byte[MetabansRequest.INT_BUFFER_SIZE];

                try {
                    m_webRequest = (HttpWebRequest) WebRequest.Create(DownloadSource);
                    m_webRequest.Method = Method;

                    if (Range != null) {
                        m_webRequest.AddRange((int) Range);
                    }

                    if (Referrer != null) {
                        m_webRequest.UserAgent = Referrer;
                    }

                    m_webRequest.Headers.Add(System.Net.HttpRequestHeader.AcceptEncoding, "gzip");

                    try {
                        m_webRequest.Proxy = null;
                    }
                    catch (Exception) {
                    }

                    if (RequestContent != null && RequestContent.Length > 0) {
                        m_webRequest.ContentType = "application/x-www-form-urlencoded";
                        m_webRequest.ContentLength = RequestContent.Length;

                        Stream newStream = m_webRequest.GetRequestStream();
                        // Send the data.
                        newStream.Write(Encoding.UTF8.GetBytes(RequestContent), 0, RequestContent.Length);
                        newStream.Close();
                    }

                    if (m_webRequest != null) {
                        IAsyncResult arResult = m_webRequest.BeginGetResponse(new AsyncCallback(ResponseCallback), this);
                        ThreadPool.RegisterWaitForSingleObject(arResult.AsyncWaitHandle, new WaitOrTimerCallback(RequestTimeoutCallback), this, m_timeout, true);
                    }
                }
                catch (Exception e) {
                    Console.WriteLine(DownloadSource);
                    Console.WriteLine(e.StackTrace);

                    if (RequestError != null) {
                        Error = e.Message;

                        RequestError(this);
                    }
                }
            }

            private void ResponseCallback(IAsyncResult ar) {
                //Request cdfParent = (Request)ar.AsyncState;

                try {
                    m_webResponse = m_webRequest.EndGetResponse(ar);

                    string strContentLength = null;
                    if ((strContentLength = m_webResponse.Headers["Content-Length"]) != null) {
                        FileSize = Convert.ToInt32(strContentLength);
                        CompleteFileData = new byte[FileSize];

                        UnknownSize = false;

                        if (RequestDiscoveredFileSize != null) {
                            RequestDiscoveredFileSize(this);
                        }
                    }
                    else {
                        CompleteFileData = new byte[0];
                    }

                    m_responseStream = m_webResponse.GetResponseStream();

                    if (m_webResponse.Headers.Get("Content-Encoding") != null && m_webResponse.Headers.Get("Content-Encoding").ToLower() == "gzip") {
                        m_responseStream = new GZipStream(m_responseStream, CompressionMode.Decompress);
                    }

                    IAsyncResult arResult = m_responseStream.BeginRead(ma_bBufferStream, 0, MetabansRequest.INT_BUFFER_SIZE, new AsyncCallback(ReadCallBack), this);

                    ThreadPool.RegisterWaitForSingleObject(arResult.AsyncWaitHandle, new WaitOrTimerCallback(ReadTimeoutCallback), this, m_timeout, true);
                }
                catch (Exception e) {
                    FileDownloading = false;
                    if (RequestError != null) {
                        Error = e.Message;

                        RequestError(this);
                    }
                }
            }

            private void ReadTimeoutCallback(object state, bool timedOut) {
                if (timedOut == true) {
                    var cdfParent = (MetabansRequest) state;
                    if (cdfParent != null && cdfParent.m_responseStream != null) {
                        cdfParent.m_responseStream.Close();

                        if (cdfParent.RequestError != null) {
                            cdfParent.Error = "Read Timeout";

                            cdfParent.RequestError(cdfParent);
                        }
                    }
                }
            }

            private void ReadCallBack(IAsyncResult ar) {
                if (FileDownloading == true) {
                    try {
                        int iBytesRead = -1;
                        if ((iBytesRead = m_responseStream.EndRead(ar)) > 0) {
                            if (UnknownSize == true) {
                                var resizedFileData = new byte[CompleteFileData.Length + iBytesRead];

                                CompleteFileData.CopyTo(resizedFileData, 0);

                                CompleteFileData = resizedFileData;

                                // Array.Resize<byte>(ref cdfParent.CompleteFileData, cdfParent.CompleteFileData.Length + iBytesRead);
                            }

                            Array.Copy(ma_bBufferStream, 0, CompleteFileData, BytesDownloaded, iBytesRead);
                            BytesDownloaded += iBytesRead;

                            IAsyncResult arResult = m_responseStream.BeginRead(ma_bBufferStream, 0, MetabansRequest.INT_BUFFER_SIZE, new AsyncCallback(ReadCallBack), this);

                            ThreadPool.RegisterWaitForSingleObject(arResult.AsyncWaitHandle, new WaitOrTimerCallback(ReadTimeoutCallback), this, m_timeout, true);
                        }
                        else {
                            FileDownloading = false;
                            if (RequestComplete != null) {
                                //FrostbiteConnection.RaiseEvent(cdfParent.DownloadComplete.GetInvocationList(), cdfParent);
                                RequestComplete(this);
                            }

                            m_responseStream.Close();
                            m_responseStream.Dispose();
                            m_responseStream = null;
                        }
                    }
                    catch (Exception e) {
                        FileDownloading = false;
                        if (RequestError != null) {
                            Error = e.Message;

                            //FrostbiteConnection.RaiseEvent(cdfParent.DownloadError.GetInvocationList(), cdfParent);
                            RequestError(this);
                        }
                    }
                }
            }
        }

        internal static class SHA1 {
            private static readonly System.Security.Cryptography.SHA1 HASHER = System.Security.Cryptography.SHA1.Create();

            public static string Data(byte[] data) {
                var stringifyHash = new StringBuilder();
                byte[] hash = SHA1.HASHER.ComputeHash(data);

                for (int x = 0; x < hash.Length; x++) {
                    stringifyHash.Append(hash[x].ToString("x2"));
                }

                return stringifyHash.ToString();
            }

            public static string String(string data) {
                return SHA1.Data(Encoding.UTF8.GetBytes(data));
            }
        }

        public class StatLibrary {
            private readonly AdKats Plugin;
            public Dictionary<String, StatLibraryWeapon> Weapons;

            public StatLibrary(AdKats plugin) {
                Plugin = plugin;
            }

            public Boolean PopulateWeaponStats() {
                try {
                    //Get Weapons
                    Hashtable statTable = FetchWeaponDefinitions();
                    var statData = (ArrayList) statTable[Plugin._gameVersion.ToString()];
                    if (statData != null && statData.Count > 0) {
                        var tempWeapons = new Dictionary<String, StatLibraryWeapon>();
                        foreach (Hashtable currentWeapon in statData) {
                            //Create new construct
                            StatLibraryWeapon weapon;
                            weapon = new StatLibraryWeapon {
                                id = (String) currentWeapon["id"],
                                damage_max = (Double) currentWeapon["damage_max"],
                                damage_min = (Double) currentWeapon["damage_min"]
                            };
                            tempWeapons.Add(weapon.id, weapon);
                        }
                        if (tempWeapons.Count > 0) {
                            Weapons = tempWeapons;
                            return true;
                        }
                    }
                }
                catch (Exception e) {
                    Plugin.HandleException(new AdKatsException("Error while fetching weapon stats for " + Plugin._gameVersion, e));
                }
                return false;
            }

            private Hashtable FetchWeaponDefinitions() {
                Hashtable statTable = null;
                using (var client = new WebClient())
                {
                    String weaponInfo;
                    Plugin.DebugWrite("Fetching weapon statistic definitions...", 2);
                    try
                    {
                        weaponInfo = client.DownloadString("https://raw.github.com/AdKats/AdKats/master/adkatsweaponstats.json");
                        Plugin.DebugWrite("Weapon statistic definitions fetched.", 1);
                    }
                    catch (Exception)
                    {
                        try
                        {
                            weaponInfo = client.DownloadString("http://api.gamerethos.net/adkats/fetch/weapons");
                            Plugin.DebugWrite("Weapon statistic definitions fetched from backup location.", 1);
                        }
                        catch (Exception)
                        {
                            return null;
                        }
                    }
                    try {
                        statTable = (Hashtable)JSON.JsonDecode(weaponInfo);
                    }
                    catch (Exception e)
                    {
                        Plugin.HandleException(new AdKatsException("Error while parsing weapon statistic definitions.", e));
                        return null;
                    }
                }
                return statTable;
            }
        }

        public class StatLibraryWeapon {
            public Double damage_max = -1;
            public Double damage_min = -1;
            public String id = null;
        }
    }
}